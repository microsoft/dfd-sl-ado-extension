// Type definitions for Microsoft Visual Studio Services v141.20180928.1721
// Project: https://www.visualstudio.com/integrate/extensions/overview
// Definitions by: Microsoft <vsointegration@microsoft.com>

/// <reference types='knockout' />
/// <reference types='jquery' />
/// <reference types='jqueryui' />
/// <reference types='q' />
/// <reference types='requirejs' />
/// <reference types='react' />
/// <reference types='mousetrap' />
//----------------------------------------------------------
// Common interfaces specific to WebPlatform area
//----------------------------------------------------------

/**
* VSS-specific options for VSS ajax requests
*/
interface IVssAjaxOptions {

    /*
    * Auth token manager that can be used to get and attach auth tokens to requests
    */
    authTokenManager?: IAuthTokenManager<any>;

    /**
     * If true, textStatus and jqXHR are added to the success callback. In this case, spread (instead of then) needs to be used (default false).
     */
    useAjaxResult?: boolean;

    /**
     * If true, the progress indicator will be shown while the request is executing. Defaults to true.
     */
    showProgressIndicator?: boolean;

    /**
     * Current session id. Defaults to pageContext.diagnostics.sessionId.
     */
    sessionId?: string;

    /**
     * Current command for activity logging.
     */
    command?: string;
}

/**
* Event listener for VSS ajax events. Gets notified before and after each request
*/
interface IVssAjaxEventListener {

    /**
    * Method invoked before a request is sent
    *
    * @param requestId A unique id that can be used to track this particular request (id is unique among all clients)
    * @param requestUrl Url of the request that is about to be issued
    * @param ajaxOptions Ajax settings/options for the request
    * @param vssRequestOptions Additional VSS-specific options supplied in the request
    */
    beforeRequest?: (requestId: number, requestUrl: string, ajaxOptions: JQueryAjaxSettings, vssRequestOptions: IVssAjaxOptions) => void;

    /**
    * Method invoked when a response has been received
    *
    * @param requestId A unique id that can be used to track this particular request (id is unique among all clients)
    * @param data The response data
    * @param textStatus A string indicating status of the request
    * @param jqXHR: The jQuery XHR object for the request
    * @param vssRequestOptions Additional VSS-specific options supplied in the request
    */
    responseReceived?: (requestId: number, data: any, textStatus: string, jqXHR: JQueryXHR, vssRequestOptions: IVssAjaxOptions) => void;
    
    /**
    * Method invoked after a response has been received and its callback/promise has been invoked
    *
    * @param requestId A unique id that can be used to track this particular request (id is unique among all clients)
    * @param data The response data
    * @param textStatus A string indicating status of the request
    * @param jqXHR: The jQuery XHR object for the request
    * @param vssRequestOptions Additional VSS-specific options supplied in the request
    */
    postResponseCallback?: (requestId: number, data: any, textStatus: string, jqXHR: JQueryXHR, vssRequestOptions: IVssAjaxOptions) => void;
}

/**
* Interface for a class that can fetch auth tokens to be used in AJAX requests.
*/
interface IAuthTokenManager<TToken> {

    /**
    * Get the auth token to use for this request.
    *
    * @param refresh If true refresh the token (i.e. request a new one - don't use a cached token)
    * @param webContext WebContext to use when getting auth token. If not specified, default page context is used.
    */
    getAuthToken(refresh?: boolean, webContext?: any): IPromise<TToken>;
    
    /**
     * Gets the authorization header to use in a request from the given token
     *
     * @param sessionToken Used for token key.
     * @return the value to use for the Authorization header in a request.
     */
    getAuthorizationHeader(sessionToken: TToken): string;
}

/**
* A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method,
* which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.
*/
interface IPromise<T> {
    /**
     * Compatible with A+ promises and Q promises
     */
    then<TResult1 = T>(
        onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, 
        onrejected?: ((reason: any) => any | PromiseLike<any>) | undefined | null,
        onProgress?: (progress: any) => any
    ): PromiseLike<TResult1>;
}
//----------------------------------------------------------
// Common interfaces specific to WebPlatform area
//----------------------------------------------------------

/**
* Interface for a single XDM channel
*/
interface IXDMChannel {
    
    /**
    * Invoke a method via RPC. Lookup the registered object on the remote end of the channel and invoke the specified method.
    *
    * @param method Name of the method to invoke
    * @param instanceId unique id of the registered object
    * @param params Arguments to the method to invoke
    * @param instanceContextData Optional context data to pass to a registered object's factory method
    */
    invokeRemoteMethod<T>(methodName: string, instanceId: string, params?: any[], instanceContextData?: Object): IPromise<T>;

    /**
    * Get a proxied object that represents the object registered with the given instance id on the remote side of this channel.
    *
    * @param instanceId unique id of the registered object
    * @param contextData Optional context data to pass to a registered object's factory method
    */
    getRemoteObjectProxy<T>(instanceId: string, contextData?: Object): IPromise<T>;

    /**
    * Get the object registry to handle messages from this specific channel.
    * Upon receiving a message, this channel registry will be used first, then
    * the global registry will be used if no handler is found here.
    */
    getObjectRegistry(): IXDMObjectRegistry;
}

/**
* Registry of XDM channels kept per target frame/window
*/
interface IXDMChannelManager {

    /**
    * Add an XDM channel for the given target window/iframe
    *
    * @param window Target iframe window to communicate with
    * @param targetOrigin Url of the target iframe (if known)
    */
    addChannel(window: Window, targetOrigin?: string): IXDMChannel;

    /**
    * Removes an XDM channel, allowing it to be disposed
    *
    * @param channel The channel to remove from the channel manager
    */
    removeChannel(channel: IXDMChannel);
}

/**
* Registry of XDM objects that can be invoked by an XDM channel
*/
interface IXDMObjectRegistry {
    
    /**
    * Register an object (instance or factory method) exposed by this frame to callers in a remote frame
    *
    * @param instanceId unique id of the registered object
    * @param instance Either: (1) an object instance, or (2) a function that takes optional context data and returns an object instance.
    */
    register(instanceId: string, instance: Object | { (contextData?: any): Object; }): void;

    /**
    * Unregister an object (instance or factory method) that was previously registered by this frame
    *
    * @param instanceId unique id of the registered object
    */
    unregister(instanceId: string): void;

    /**
    * Get an instance of an object registered with the given id
    *
    * @param instanceId unique id of the registered object
    * @param contextData Optional context data to pass to the contructor of an object factory method
    */
    getInstance<T>(instanceId: string, contextData?: Object): T;
}

/**
* Options for the extension's initialization method
*/
interface IExtensionInitializationOptions {

    /**
    * Set to true if the extension will explicitly call notifyLoadSucceeded or notifyLoadFailed
    * itself to indicate that the extension is done loading (stops UI loading indicator in the host).
    * If false (the default) the extension is considered ready as soon as init is called.
    */
    explicitNotifyLoaded?: boolean;

    /**
    * Set to true if the extension is going to consume any VSS script libraries.
    * For example, controls, REST clients, services, etc.
    * This pulls in the script loader and configuration data from the host frame so that
    * 'require' statements can be used to load VSTS modules. A call to VSS.require will
    * effectively turn this option on, even if not specified in the VSS.init handshake.
    */
    usePlatformScripts?: boolean;

    /**
    * Set to true if the extension desires to use VSS platform CSS styles. If not explicitly set,
    * the default value is the value of 'usePlatformScripts'.
    */
    usePlatformStyles?: boolean;

    /**
    * Extension-specific AMD module loader configuration. This configuration
    * will be merged with the VSTS-specific configuration.
    */
    moduleLoaderConfig?: ModuleLoaderConfiguration;

    /**
    * Optional callback method that gets invoked when this extension frame is reused by another contribution
    * which shares the same URI of the contribution that originally caused this extension frame to be loaded.
    */
    extensionReusedCallback?: (contribution: Contribution) => void;

    /**
     * If true, send back the theme data as part of the initial handshake
     */
    applyTheme?: boolean;
}

/**
* Storage that can be leveraged by sandboxed extension content. The host frame will
* store this data in localStorage for the extension's publisher id.
*/
interface ISandboxedStorage {
    /**
    * Used by the VSS.SDK to shim localStorage for sandboxed content - for a given publisher.
    */
    localStorage?: IDictionaryStringTo<string>;
}

/**
* Data passed from the host to an extension frame via the initial handshake
*/
interface IHostHandshakeData {

    /**
    * Static context information about the current page
    */
    pageContext: PageContext;

    /**
    * Initial configuration for the extension frame
    */
    initialConfig?: any;

    /**
    * Context information about the extension
    */
    extensionContext: IExtensionContext;

    /**
    * The contribution that caused the extension frame to be loaded.
    */
    contribution: Contribution;

    /**
    * Initial sandboxed-storage data for the current extension's publisher. 
    */
    sandboxedStorage?: ISandboxedStorage;

    /**
     * CSS variable values for the current theme
     */
    themeData?: { [key: string]: string };
}

/**
* Data passed to the host from an extension frame via the initial handshake
*/
interface IExtensionHandshakeData {

    /**
    * If true, consider the extension loaded upon completion of the initial handshake.
    */
    notifyLoadSucceeded: boolean;

    /**
    * Optional callback method that gets invoked when this extension frame is reused by another contribution
    * which shares the same URI of the contribution that originally caused this extension frame to be loaded.
    */
    extensionReusedCallback?: (contribution: Contribution) => void;

    /**
    * The version of the VSS.SDK javascript file being used by the extension
    */
    vssSDKVersion: number;
}

/**
* Information about a control interface that is exposed across iframe boundaries
*/
interface IExternalControlInterfaceInfo {
    methodNames: string[];
}

/**
* Context about the app that owns the content that is being hosted
*/
interface IExtensionContext {
    /**
    * Friendly unique id of the publisher
    */
    publisherId: string;

    /**
    * Friendly id of the extension (unique within the publisher)
    */
    extensionId: string;

    /**
    * Version of the extension
    */
    version: string;

    /**
    * The base uri to be used with relative urls in contribution properties
    */
    baseUri: string;
}

/**
* Context passed to GetServiceInstance
*/
interface IDefaultGetServiceContext {

    /**
    * The web context to be used in the get service call
    */
    webContext: WebContext;

    /**
    * The extension context, i.e. publisher id, extension id, etc.
    */
    extensionContext: IExtensionContext;

    /**
    * Options that were passed to the host management service, 
    * contains the registered VSS auth application id
    */
    hostManagementServiceOptions: IHostManagementServiceOptions;
}

/**
* Options passed to the host management service
*/
interface IHostManagementServiceOptions extends IExtensionContext {

    /**
    * The registered VSS auth application id
    */
    registrationId: string;

    /**
    * The contribution id
    */
    contributionId: string;

    /**
    * The initial config object for the contribution instance
    */
    initialConfig: any;
}

/**
* Session token whose value can be added to the Authorization header in requests to VSTS endpoints
*/
interface ISessionToken {

    /**
    * The registered VSS auth application id
    */
    appId: string;

    /**
    * Name describing the token
    */
    name: string;

    /**
    * Token value
    */
    token: string;
}

/**
* A Contribution with its containing extension
*/
interface IExtensionContribution extends Contribution {

    /**
    * The extension that owns this contribution
    */
    extension: ExtensionManifest;
}

/**
* Information about an individual contribution that contributes one or more services registered by id.
*/
interface IServiceContribution extends IExtensionContribution {
    
    /**
    * Get the instance of an object registered by this contribution
    *
    * @param objectId Id of the registered object (defaults to the id property of the contribution)
    * @param context Optional context to use when getting the object.
    */
    getInstance<T>(objectId?: string, context?: any): IPromise<T>;
}

interface IHostDialogOptions {

    height?: number;
    width?: number;
    draggable?: boolean;
    resizable?: boolean;
    title?: string;
    modal?: boolean;
    buttons?: IDictionaryStringTo<any>;
    open?: Function;
    close?: Function;
    getDialogResult?: () => any;
    okCallback?: (result: any) => void;
    cancelCallback?: Function;
    okText?: string;
    cancelText?: string;
}

interface IExternalDialog {
    
    /**
    * Gets an object registered in the dialog's contribution control.
    *
    * @param instanceId Id of the instance to get
    * @param contextData Optional data to pass to the extension for it to use when creating the instance
    * @return Promise that is resolved to the instance (a proxy object that talks to the instance)
    */
    getContributionInstance<T>(instanceId: string, contextData?: any): IPromise<T>;

    /**
    * Close the dialog
    */
    close();

    /**
    * Update the title of the dialog
    *
    * @param title New dialog title
    */
    setTitle(title: string);

    /**
    * Update the enablement of the OK button
    */
    updateOkButton(enabled: boolean);
}

/**
 * Represents a button used in IHostDialogService.openMessageDialog().
 */
interface IMessageDialogButton {
    /**
     * Used as HTML id of the button.
     */
    id: string;
    /**
     * Text to display on the button.
     */
    text: string;
    /**
     * When true, the dialog's promise is rejected instead of resolved when this button is clicked.
     */
    reject?: boolean;
    /**
     * Specifies how the button should look. 
     * Possible values: 
     *   (undefined) - Default
     *   "warning" - Red
     */
    style?: string;
}

/**
 * Used by IHostDialogService.openMessageDialog().
 */
interface IOpenMessageDialogOptions {
    /**
     * Array of buttons to show. Default is [Button.Ok, Button.Cancel]
     */
    buttons?: IMessageDialogButton[];
    /**
     * Button to use when the user presses the Esc key. Default is the last button.
     */
    escapeButton?: IMessageDialogButton;
    /**
     * If this is set, the user will be presented with a text box. Non-rejecting buttons will be disabled until the user types in this string.
     */
    requiredTypedConfirmation?: string;
    /**
     * Text for the title bar of the dialog. Default is "Confirm".
     */
    title?: string;
    /**
     * Width of dialog in px.
     */
    width?: number;
    /**
     * Height of dialog in px.
     */
    height?: number;
    /**
     * Use Bowtie styling. Default is true.
     */
    useBowtieStyle?: boolean;
}

/**
 * Result returned when a MessageDialog is closed.
 */
interface IMessageDialogResult {
    /**
     * Button that was clicked to dismiss the dialog.
     */
    button: IMessageDialogButton;
}

/**
* Service which manages showing dialogs in the parent frame
*/
interface IHostDialogService {
    
    /**
    * Open a modal dialog in the host frame which will get its content from a contributed control.
    * 
    * @param contributionId The id of the control contribution to host in the dialog
    * @param dialogOptions options.title - title of dialog
    * @param contributionConfig Initial configuration to pass to the contribution control.
    * @param postContent Optional data to post to the contribution endpoint. If not specified, a GET request will be performed.
    */
    openDialog(contributionId: string, dialogOptions: IHostDialogOptions, contributionConfig?: Object, postContent?: Object): IPromise<IExternalDialog>;

    /**
     * Open a modal dialog in the host frame which will display the supplied message.
     * @param message the message to display in the dialog. 
     * @param methodOptions options affecting the dialog
     * @returns a promise that is resolved when the user accepts the dialog (Ok, Yes, any button with Button.reject===false), or rejected if the user does not (Cancel, No, any button with Button.reject===true).
     */
    openMessageDialog(message: string, options?: IOpenMessageDialogOptions): IPromise<IMessageDialogResult>;

    buttons: {
        /**
         * Localized Ok button.
         */
        ok: IMessageDialogButton;
        /**
         * Localized Cancel button.
         */
        cancel: IMessageDialogButton;
        /**
         * Localized Yes button.
         */
        yes: IMessageDialogButton;
        /**
         * Localized No button.
         */
        no: IMessageDialogButton;
    }
}

/**
* Service which allows interaction with the browser location and navigation of the host frame
*/
interface IHostNavigationService {
    
    /**
    * Update the current history entry
    *
    * @param action The "action" state parameter. This is the _a key in the url or "action" in the current state dictionary
    * @param data The history entry's new state key/value pairs
    * @param replaceHistoryEntry If true, replace the current history entry. Otherwise, add a new history entry.
    * @param mergeWithCurrentState If true, the supplied data just modify the existing/current state. If false, they replace all existing key/value pairs.
    * @param windowTitle The new window title. A null or empty value indicates to leave the title unchanged.
    * @param suppressNavigate If true, don't trigger any of the attached navigate event handlers due to this update.
    */
    updateHistoryEntry(action: string, data?: IDictionaryStringTo<any>, replaceHistoryEntry?: boolean, mergeWithCurrentState?: boolean, windowTitle?: string, suppressNavigate?: boolean): void;

    /**
    * Get the current navigation state dictionary. Uses query parameters and hash parameters.
    */
    getCurrentState(): any;

    /**
    * Attach a new navigate handler
    *
    * @param action The action that the handler applies to (or null to listen for all events)
    * @param handler The method called whenever a navigation event occurs with the matching action value
    * @param checkCurrentState If true, immediately invoke the handler if the current state is appropriate (has the matching action value)
    */
    attachNavigate(action: string, handler: IFunctionPPR<any, any, void>, checkCurrentState?: boolean): void;

    /**
    * Remove a navigate handler
    *
    * @param action The action that the handler applies to (or null for global handlers)
    * @param handler The method called whenever a navigation event occurs with the matching action value
    */
    detachNavigate(action: string, handler?: IFunctionPPR<any, any, void>): void;

    /**
    * Add a callback to be invoked each time the hash navigation has changed
    *
    * @param callback Method invoked on each navigation hash change
    */
    onHashChanged(callback: (hash: string) => void): void;
    
    /**
    * Gets the current hash.
    */
    getHash(): Q.Promise<string>;

    /**
     * Reloads the parent frame
     */
    reload(): void;

    /**
    * Sets the provided hash from the hosted content.
    */
    setHash(hash: string): void;

    /**
    * Replace existing hash with the provided hash from the hosted content.
    */
    replaceHash(hash: string): void;

    /**
    * Update the host document's title (appears as the browser tab title).
    *
    * @param title The new title of the window
    */
    setWindowTitle(title: string): void;

    /**
     * Open a new window to the specified url
     *
     * @param url Url of the new window
     * @param features Comma-separated list of features/specs sent as the 3rd parameter to window.open. For example: "height=400,width=400".
     */
    openNewWindow(url: string, features: string): void;

    /**
     * Navigate the parent page to the specified url
     *
     * @param url Url to navigate to
     */
    navigate(url: string): void;
}

/**
* Service which allows for getting and setting of extension data
*/
interface IExtensionDataService {

    /**
    * Returns a promise for retrieving a setting at the provided key and scope
    *
    * @param key The key to retrieve a value for
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    getValue<T>(key: string, documentOptions?: IDocumentOptions): IPromise<T>;

    /**
    * Returns a promise for saving a setting at the provided key and scope
    *
    * @param key The key to save a value for
    * @param value The value to save
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    setValue<T>(key: string, value: T, documentOptions?: IDocumentOptions): IPromise<T>;

    /**
    * Returns a promise for getting a document with the provided id in the provided collection
    *
    * @param collectionName The name of the collection where the document lives
    * @param id The id of the document in the collection
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    getDocument(collectionName: string, id: string, documentOptions?: IDocumentOptions): IPromise<any>;

    /**
    * Returns a promise for getting all of the documents in the provided collection
    *
    * @param collectionName The name of the collection where the document lives
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    getDocuments(collectionName: string, documentOptions?: IDocumentOptions): IPromise<any[]>;

    /**
    * Returns a promise for creating a document in the provided collection
    *
    * @param collectionName The name of the collection where the document lives
    * @param doc The document to store
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    createDocument(collectionName: string, doc: any, documentOptions?: IDocumentOptions): IPromise<any>;

    /**
    * Returns a promise for setting a document in the provided collection
    * Creates the document if it does not exist, otherwise updates the existing document with the id provided
    *
    * @param collectionName The name of the collection where the document lives
    * @param doc The document to store
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    setDocument(collectionName: string, doc: any, documentOptions?: IDocumentOptions): IPromise<any>;

    /**
    * Returns a promise for updating a document in the provided collection
    * A document with the id provided must exist
    *
    * @param collectionName The name of the collection where the document lives
    * @param doc The document to store
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    updateDocument(collectionName: string, doc: any, documentOptions?: IDocumentOptions): IPromise<any>;

    /**
    * Returns a promise for deleting the document at the provided scope, collection and id
    *
    * @param collectionName The name of the collection where the document lives
    * @param id The id of the document in the collection
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    deleteDocument(collectionName: string, id: string, documentOptions?: IDocumentOptions): IPromise<void>;
}

/**
* Interface for options that can be supplied with document actions
*/
interface IDocumentOptions {
    /**
    * The scope of where the document is stored. Can be Default or User.
    */
    scopeType: string;

    /**
    * The value of the scope where the document is stored. Can be Current or Me.
    */
    scopeValue?: string;

    /**
    * The default value to return when using getValue(). If the document has no value,
    * this value will be used instead.
    */
    defaultValue?: any;
}

/**
* Interface for a registered object that contributes menu item(s)
*/
interface IContributedMenuSource {

    /**
    * Get an array of menu items for the given context
    *
    * @param context Menu-specific context information
    * @return Array of menu items or a promise for the array
    */
    getMenuItems(context: any): IContributedMenuItem[] | IPromise<IContributedMenuItem[]>;

    /**
    * Handle a menu item from this menu source being clicked. This is only invoked when the
    * contributed menu item does not have an "action" method.
    *
    * @param actionContext Menu-specific context information
    */
    execute?(actionContext: any);
}

/**
* An individual contributed menu item
*/
interface IContributedMenuItem {

    /**
    * Menu-item specific identifier
    */
    id?: string;

    /**
    * Text to display in the menu item
    */
    text?: string;

    /**
    * Tooltip to display for the menu item
    */
    title?: string;

    /**
    * Set to true if this menu item is just a separator
    */
    separator?: boolean;

    /**
    * Set to true if this menu item should be disabled
    */
    disabled?: boolean;

    /**
     * If true, the menu item will not be displayed.
     */
    hidden?: boolean;

    /**
    * Url to an icon image or css class for the image cell
    */
    icon?: string;

    /**
    * If true, do not render an icon or space for an icon.
    */
    noIcon?: boolean;

    /**
    * If this menu item has a sub menu, these are the contributed child items
    */
    childItems?: IContributedMenuItem[] | IPromise<IContributedMenuItem[]>;

    /**
    * Id of the menu group that this item should be placed in.
    */
    groupId?: string;

    /**
    * If specified, create an <a> tag around this menu item with the specified href.
    */
    href?: string;

    /**
    * Method invoked when the menu item is clicked.
    *
    * @param actionContext Menu-specific context information
    */
    action?: (actionContext: any) => void;

    /**
     * If specified, aria-label attribute will be added to menu item
     */
    ariaLabel?: string;
}
interface IContributedTab {
    /**
     * Determines if this tab should be displayed
     * @param context Context information
     * @return boolean Return true not to show this tab.
     */
    isInvisible?: (context?: any) => boolean | IPromise<boolean>;

    /**
     * Page title, which will be displayed above the list of Tabs
     * @param context Context information
     * @return string The unescaped page title
     */
    pageTitle: string | IPromise<string> | ((context?: any) => string | IPromise<string>);

    /**
     * Name of the tab
     * @param context Context information
     * @return string The unescaped text that appears as the name of the tab
     */
    name: string | IPromise<string> | ((context?: any) => string | IPromise<string>);

    /**
     * Title text for the tab, i.e., the tooltip
     * @param context Context information
     * @return string The tooltip text
     */
    title?: string | IPromise<string> | ((context?: any) => string | IPromise<string>);

    /**
     * Optional group key for the tab
     * @param context Context information
     * @return string The group key
     */
    groupKey?: string | IPromise<string> | ((context?: any) => string | IPromise<string>);

    /**
     * URI to the page that this tab will display (i.e. in a frame)
     */
    uri: string;

    /**
     * Function that is invoked when there is a new context available for the extension.
     */
    updateContext: (context: any) => void | IPromise<void>;

    /**
     * Determines if this tab should be disabled
     * @param context Context information
     * @return boolean Return true to disable this tab.
     */
    isDisabled?: (context?: any) => boolean | IPromise<boolean>;
    
    /**
     * Returns a unique string used to identify this tab. May be ignored from non-trusted extensions.
     */
    itemKey?: (context?: any) => string | IPromise<string>;

    /**
     * Returns a context object that will be passed to contributed view actions and commands for
     * this pivot.
     */
    getActionContext?: () => any;
}

/**
 * A navigation element which appears in the header section.
 * @exemptedapi
 */
interface IContributedHub extends Hub {
    /**
     * Specifies the target hub id where the children are attached to the target hub.
     */
    targetHubId?: string;

    /**
     * Hubs resolved by this container hub.
     */
    children: IContributedHub[] | (()=> IPromise<IContributedHub[]>);

    /**
     * Specifies whether a separator is displayed before this hub or not.
     */
    beforeSeparator?: boolean;
    
    /**
     * Specifies whether a separator is displayed after this hub or not.
     */
    afterSeparator?: boolean;

    /**
     * Specifies whether this hub is a default hub or not (rendered differently).
     */
    isDefault?: boolean;

    /**
    * If true, the hub element should be rendered as a disabled element.
    */
    disabled: boolean;
}

/**
* Context passed to hubs-providers in calls to get hubs
*/
interface IHubsProviderContext {
    /**
    * The contribution id of the owning control
    */
    contributionId: string;

    /**
    * Method that can be called when hubs change in order to update the owning control
    */
    refreshDelegate?: Function;
}

/**
 * The contract for hub providers which are expected to provide a container hub.
 * @exemptedapi
 */
interface IHubsProvider {
    /**
     * Container hub specified by this provider. Container decides where to display child hubs in the header.
     */
    getContainerHub(context: IHubsProviderContext): IContributedHub | IPromise<IContributedHub>;
}

//----------------------------------------------------------
// Generated file, DO NOT EDIT.
// To regenerate this file, run "GenerateConstants.cmd" .

// Generated data for the following assemblies:
// Microsoft.TeamFoundation.Server.WebAccess.Platform
// Microsoft.VisualStudio.Services.ExtensionManagement.WebApi
//----------------------------------------------------------


/**
* Model to represent a public access uri
*/
interface AccessPointModel {
    /**
    * Host name and port number of the url
    */
    authority: string;
    /**
    * Url scheme (http, https, ...)
    */
    scheme: string;
    /**
    * Full url
    */
    uri: string;
}

interface AcquisitionOperation {
    /**
    * State of the the AcquisitionOperation for the current user
    */
    operationState: any;
    /**
    * AcquisitionOperationType: install, request, buy, etc...
    */
    operationType: any;
    /**
    * Optional reason to justify current state. Typically used with Disallow state.
    */
    reason: string;
    /**
    * List of reasons indicating why the operation is not allowed.
    */
    reasons: any[];
}

/**
* Model used to configure how TFS reports usage data to Application Insights
*/
interface AppInsightsConfiguration {
    /**
    * If true, automatically call "trackPage" when the page is loaded
    */
    autoTrackPage: boolean;
    /**
    * Optional data used to override the default values sent to trackPage
    */
    customTrackPageData: AppInsightsCustomTrackPageData;
    /**
    * Set to false if app insights reporting is not enabled/configured
    */
    enabled: boolean;
    /**
    * The url from which to retrieve app insights scripts
    */
    insightsScriptUrl: string;
    /**
    * The instrumentation key used to track this deployment's usage
    */
    instrumentationKey: string;
    /**
    * If true, include collection, project, and team info in the track-page urls
    */
    trackProjectInfo: boolean;
}

/**
* Model that can be used to customize the values sent to AppInsights via "trackPage"
*/
interface AppInsightsCustomTrackPageData {
    alias: string;
    metrics: { [key: string]: any; };
    pageName: string;
    properties: { [key: string]: string; };
}

/**
* Representaion of a ContributionNode that can be used for serialized to clients.
*/
interface ClientContribution {
    /**
    * Description of the contribution/type
    */
    description: string;
    /**
    * Fully qualified identifier of the contribution/type
    */
    id: string;
    /**
    * Includes is a set of contributions that should have this contribution included in their targets list.
    */
    includes: string[];
    /**
    * Properties/attributes of this contribution
    */
    properties: any;
    /**
    * The ids of the contribution(s) that this contribution targets. (parent contributions)
    */
    targets: string[];
    /**
    * Id of the Contribution Type
    */
    type: string;
}

/**
* Representaion of a ContributionNode that can be used for serialized to clients.
*/
interface ClientContributionNode {
    /**
    * List of ids for contributions which are children to the current contribution.
    */
    children: string[];
    /**
    * Contribution associated with this node.
    */
    contribution: ClientContribution;
    /**
    * List of ids for contributions which are parents to the current contribution.
    */
    parents: string[];
}

interface ClientContributionProviderDetails {
    /**
    * Friendly name for the provider.
    */
    displayName: string;
    /**
    * Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
    */
    name: string;
    /**
    * Properties associated with the provider
    */
    properties: { [key: string]: string; };
    /**
    * Version of contributions assoicated with this contribution provider.
    */
    version: string;
}

/**
* A client data provider are the details needed to make the data provider request from the client.
*/
interface ClientDataProviderQuery {
    context: DataProviderContext;
    contributionIds: string[];
    /**
    * The Id of the service instance type that should be communicated with in order to resolve the data providers from the client given the query values.
    */
    queryServiceInstanceType: string;
}

/**
* Web Access configuration data. This information is used to process requests on the server.  This data is also placed in a json island on each page in order for JavaScript to know key configuration data required to things like construct proper urls
*/
interface ConfigurationContext {
    /**
    * MVC api configuration
    */
    api: ConfigurationContextApis;
    /**
    * Optional name of the client (e.g. TEE) hosting the page
    */
    clientHost: string;
    isHosted: boolean;
    /**
    * Current mail settings for TFS
    */
    mailSettings: TfsMailSettings;
    /**
    * Server resource paths
    */
    paths: ConfigurationContextPaths;
    /**
    * Indicates what URL format to use.
    */
    useCodexDomainUrls: boolean;
}

/**
* MVC api configuration
*/
interface ConfigurationContextApis {
    /**
    * Specifies the path prefix for the area
    */
    areaPrefix: string;
    /**
    * Specifies the path prefix for the controller
    */
    controllerPrefix: string;
    /**
    * Api-version for legacy rpc-style web access api controllers See WebApiVersionClient for the version coming from the client/browser.  The return value is a positive whole number >= 1.
    */
    webApiVersion: string;
}

/**
* Paths to server resources
*/
interface ConfigurationContextPaths {
    /**
    * Path (no CDN) to versioned static content
    */
    cdnFallbackStaticRootTfs: string;
    /**
    * Relative path to the _content path of the web application
    */
    resourcesPath: string;
    /**
    * Relative path to the root of the web application
    */
    rootPath: string;
    /**
    * Absolute path to build static content URLs from. May be relative or fully-qualified.
    */
    staticContentRootPath: string;
    /**
    * Static content version stamp
    */
    staticContentVersion: string;
    /**
    * Relative path to unversioned 3rd party static content
    */
    staticRoot3rdParty: string;
    /**
    * Relative path to versioned static content
    */
    staticRootTfs: string;
}

declare enum ContextHostType {
    Unknown = 0,
    /**
    * The Deployment Host
    */
    Deployment = 1,
    /**
    * A legacy name for the Organization host. Use ContextHostType.Organization instead.
    */
    Application = 2,
    /**
    * The Organization host
    */
    Organization = 2,
    /**
    * The Project Collection
    */
    ProjectCollection = 4,
}

interface ContextIdentifier {
    id: string;
    name: string;
}

/**
* A feature that can be enabled or disabled
*/
interface ContributedFeature {
    /**
    * Named links describing the feature
    */
    _links: any;
    /**
    * If true, the feature is enabled unless overridden at some scope
    */
    defaultState: boolean;
    /**
    * Rules for setting the default value if not specified by any setting/scope. Evaluated in order until a rule returns an Enabled or Disabled state (not Undefined)
    */
    defaultValueRules: ContributedFeatureValueRule[];
    /**
    * The description of the feature
    */
    description: string;
    /**
    * Handler for listening to setter calls on feature value. These listeners are only invoked after a successful set has occured
    */
    featureStateChangedListeners: ContributedFeatureListener[];
    /**
    * The full contribution id of the feature
    */
    id: string;
    /**
    * If this is set to true, then the id for this feature will be added to the list of claims for the request.
    */
    includeAsClaim: boolean;
    /**
    * The friendly name of the feature
    */
    name: string;
    /**
    * Suggested order to display feature in.
    */
    order: number;
    /**
    * Rules for overriding a feature value. These rules are run before explicit user/host state values are checked. They are evaluated in order until a rule returns an Enabled or Disabled state (not Undefined)
    */
    overrideRules: ContributedFeatureValueRule[];
    /**
    * The scopes/levels at which settings can set the enabled/disabled state of this feature
    */
    scopes: ContributedFeatureSettingScope[];
    /**
    * The service instance id of the service that owns this feature
    */
    serviceInstanceType: string;
    /**
    * Tags associated with the feature.
    */
    tags: string[];
}

/**
* The current state of a feature within a given scope
*/
declare enum ContributedFeatureEnabledValue {
    /**
    * The state of the feature is not set for the specified scope
    */
    Undefined = -1,
    /**
    * The feature is disabled at the specified scope
    */
    Disabled = 0,
    /**
    * The feature is enabled at the specified scope
    */
    Enabled = 1,
}

interface ContributedFeatureHandlerSettings {
    /**
    * Name of the handler to run
    */
    name: string;
    /**
    * Properties to feed to the handler
    */
    properties: any;
}

/**
* An identifier and properties used to pass into a handler for a listener or plugin
*/
interface ContributedFeatureListener {
    name: string;
    properties: any;
}

/**
* The scope to which a feature setting applies
*/
interface ContributedFeatureSettingScope {
    /**
    * The name of the settings scope to use when reading/writing the setting
    */
    settingScope: string;
    /**
    * Whether this is a user-scope or this is a host-wide (all users) setting
    */
    userScoped: boolean;
}

/**
* A contributed feature/state pair
*/
interface ContributedFeatureState {
    /**
    * The full contribution id of the feature
    */
    featureId: string;
    /**
    * True if the effective state was set by an override rule (indicating that the state cannot be managed by the end user)
    */
    overridden: boolean;
    /**
    * Reason that the state was set (by a plugin/rule).
    */
    reason: string;
    /**
    * The scope at which this state applies
    */
    scope: ContributedFeatureSettingScope;
    /**
    * The current state of this feature
    */
    state: ContributedFeatureEnabledValue;
}

/**
* A query for the effective contributed feature states for a list of feature ids
*/
interface ContributedFeatureStateQuery {
    /**
    * The list of feature ids to query
    */
    featureIds: string[];
    /**
    * The query result containing the current feature states for each of the queried feature ids
    */
    featureStates: { [key: string]: ContributedFeatureState; };
    /**
    * A dictionary of scope values (project name, etc.) to use in the query (if querying across scopes)
    */
    scopeValues: { [key: string]: string; };
}

/**
* A rule for dynamically getting the enabled/disabled state of a feature
*/
interface ContributedFeatureValueRule {
    name: string;
    properties: any;
}

/**
* Page context configuration that can be contributed by remote services (different VSTS services delivering content to the page)
*/
interface ContributedServiceContext {
    /**
    * Dynamic bundles to include from this service
    */
    bundles: DynamicBundlesCollection;
    /**
    * Specifies the prefixes for CSS modules that should map to the current service. e.g. "VSS/LoaderPlugins/Css!EMS:ExtensionManagement" would map to ExtensionManagement.css under the themed content path of this service if "EMS" is in the CSSModulePrefixes list.
    */
    cssModulePrefixes: string[];
    /**
    * Feature flag states to include by default in page data (avoids AJAX lookup)
    */
    featureAvailability: FeatureAvailabilityContext;
    /**
    * Module loader configuration which may be merged-in with the parent host (if injected into the DOM) Because the config may be merged with the host config, each root area path must be explicitly defined here rather than relying on basePath as a catch-all.
    */
    moduleLoaderConfig: ModuleLoaderConfiguration;
    /**
    * Paths to resources on this service
    */
    paths: ConfigurationContextPaths;
    /**
    * Lookup of urls for different services (at different host levels)
    */
    serviceLocations: ServiceLocations;
    /**
    * The root url of the service that can be used to resolve relative links when this content is hosted in another site.
    */
    serviceRootUrl: string;
    /**
    * Instance id of the service
    */
    serviceTypeId: string;
}

/**
* An individual contribution made by an extension
*/
interface Contribution {
    /**
    * List of constraints (filters) that should be applied to the availability of this contribution
    */
    constraints: ContributionConstraint[];
    description: string;
    id: string;
    /**
    * Includes is a set of contributions that should have this contribution included in their targets list.
    */
    includes: string[];
    /**
    * Properties/attributes of this contribution
    */
    properties: any;
    /**
    * List of demanded claims in order for the user to see this contribution (like anonymous, public, member...).
    */
    restrictedTo: string[];
    /**
    * The ids of the contribution(s) that this contribution targets. (parent contributions)
    */
    targets: string[];
    /**
    * Id of the Contribution Type
    */
    type: string;
    visibleTo: string[];
}

/**
* Base class shared by contributions and contribution types
*/
interface ContributionBase {
    /**
    * Description of the contribution/type
    */
    description: string;
    /**
    * Fully qualified identifier of the contribution/type
    */
    id: string;
    /**
    * VisibleTo can be used to restrict whom can reference a given contribution/type. This value should be a list of publishers or extensions access is restricted too.  Examples: "ms" - Means only the "ms" publisher can reference this. "ms.vss-web" - Means only the "vss-web" extension from the "ms" publisher can reference this.
    */
    visibleTo: string[];
}

/**
* Specifies a constraint that can be used to dynamically include/exclude a given contribution
*/
interface ContributionConstraint {
    /**
    * An optional property that can be specified to group constraints together. All constraints within a group are AND'd together (all must be evaluate to True in order for the contribution to be included). Different groups of constraints are OR'd (only one group needs to evaluate to True for the contribution to be included).
    */
    group: number;
    /**
    * Fully qualified identifier of a shared constraint
    */
    id: string;
    /**
    * If true, negate the result of the filter (include the contribution if the applied filter returns false instead of true)
    */
    inverse: boolean;
    /**
    * Name of the IContributionFilter plugin
    */
    name: string;
    /**
    * Properties that are fed to the contribution filter class
    */
    properties: any;
    /**
    * Constraints can be optionally be applied to one or more of the relationships defined in the contribution. If no relationships are defined then all relationships are associated with the constraint. This means the default behaviour will elimiate the contribution from the tree completely if the constraint is applied.
    */
    relationships: string[];
}

/**
* Represents different ways of including contributions based on licensing
*/
declare enum ContributionLicensingBehaviorType {
    /**
    * Default value - only include the contribution if the user is licensed for the extension
    */
    OnlyIfLicensed = 0,
    /**
    * Only include the contribution if the user is NOT licensed for the extension
    */
    OnlyIfUnlicensed = 1,
    /**
    * Always include the contribution regardless of whether or not the user is licensed for the extension
    */
    AlwaysInclude = 2,
}

/**
* A query that can be issued for contribution nodes
*/
interface ContributionNodeQuery {
    /**
    * The contribution ids of the nodes to find.
    */
    contributionIds: string[];
    /**
    * Indicator if contribution provider details should be included in the result.
    */
    includeProviderDetails: boolean;
    /**
    * Query options tpo be used when fetching ContributionNodes
    */
    queryOptions: any;
}

/**
* Result of a contribution node query.  Wraps the resulting contribution nodes and provider details.
*/
interface ContributionNodeQueryResult {
    /**
    * Map of contribution ids to corresponding node.
    */
    nodes: { [key: string]: ClientContributionNode; };
    /**
    * Map of provder ids to the corresponding provider details object.
    */
    providerDetails: { [key: string]: ClientContributionProviderDetails; };
}

/**
* Item representing a contribution path. Can be of type default, resource or bundle
*/
interface ContributionPath {
    /**
    * Type if this contribution path
    */
    pathType: ContributionPathType;
    /**
    * Replace value for this contribution path
    */
    value: string;
}

/**
* Type of the contribution path
*/
declare enum ContributionPathType {
    Default = 0,
    Resource = 1,
    ThirdParty = 2,
}

/**
* Description about a property of a contribution type
*/
interface ContributionPropertyDescription {
    /**
    * Description of the property
    */
    description: string;
    /**
    * Name of the property
    */
    name: string;
    /**
    * True if this property is required
    */
    required: boolean;
    /**
    * The type of value used for this property
    */
    type: ContributionPropertyType;
}

/**
* The type of value used for a property
*/
declare enum ContributionPropertyType {
    /**
    * Contribution type is unknown (value may be anything)
    */
    Unknown = 0,
    /**
    * Value is a string
    */
    String = 1,
    /**
    * Value is a Uri
    */
    Uri = 2,
    /**
    * Value is a GUID
    */
    Guid = 4,
    /**
    * Value is True or False
    */
    Boolean = 8,
    /**
    * Value is an integer
    */
    Integer = 16,
    /**
    * Value is a double
    */
    Double = 32,
    /**
    * Value is a DateTime object
    */
    DateTime = 64,
    /**
    * Value is a generic Dictionary/JObject/property bag
    */
    Dictionary = 128,
    /**
    * Value is an array
    */
    Array = 256,
    /**
    * Value is an arbitrary/custom object
    */
    Object = 512,
}

interface ContributionProviderDetails {
    /**
    * Friendly name for the provider.
    */
    displayName: string;
    /**
    * Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
    */
    name: string;
    /**
    * Properties associated with the provider
    */
    properties: { [key: string]: string; };
    /**
    * Version of contributions assoicated with this contribution provider.
    */
    version: string;
}

interface ContributionsPageData {
    contributions: PageContribution[];
    providerDetails: { [key: string]: PageContributionProviderDetails; };
    queriedContributionIds: string[];
}

/**
* A contribution type, given by a json schema
*/
interface ContributionType {
    description: string;
    id: string;
    /**
    * Controls whether or not contributions of this type have the type indexed for queries. This allows clients to find all extensions that have a contribution of this type.  NOTE: Only TrustedPartners are allowed to specify indexed contribution types.
    */
    indexed: boolean;
    /**
    * Friendly name of the contribution/type
    */
    name: string;
    /**
    * Describes the allowed properties for this contribution type
    */
    properties: { [key: string]: ContributionPropertyDescription; };
    visibleTo: string[];
}

/**
* Contains lists of script and css references that need to be included on the page in order for the controls used by the page to work.
*/
interface CoreReferencesContext {
    /**
    * Core 3rd party javascript bundle reference
    */
    coreScriptsBundle: JavascriptFileReference;
    /**
    * Core VSS javascript bundle reference for extension frames
    */
    extensionCoreReferences: JavascriptFileReference;
    /**
    * Core javascript files referenced on a page
    */
    scripts: JavascriptFileReference[];
    /**
    * Core CSS files referenced on a page
    */
    stylesheets: StylesheetReference[];
}

/**
* Contextual information that data providers can examine when populating their data
*/
interface DataProviderContext {
    /**
    * Generic property bag that contains context-specific properties that data providers can use when populating their data dictionary
    */
    properties: { [key: string]: any; };
}

interface DataProviderExceptionDetails {
    /**
    * The type of the exception that was thrown.
    */
    exceptionType: string;
    /**
    * Message that is associated with the exception.
    */
    message: string;
    /**
    * The StackTrace from the exception turned into a string.
    */
    stackTrace: string;
}

/**
* A query that can be issued for data provider data
*/
interface DataProviderQuery {
    /**
    * Contextual information to pass to the data providers
    */
    context: DataProviderContext;
    /**
    * The contribution ids of the data providers to resolve
    */
    contributionIds: string[];
}

/**
* Result structure from calls to GetDataProviderData
*/
interface DataProviderResult {
    /**
    * This is the set of data providers that were requested, but either they were defined as client providers, or as remote providers that failed and may be retried by the client.
    */
    clientProviders: { [key: string]: ClientDataProviderQuery; };
    /**
    * Property bag of data keyed off of the data provider contribution id
    */
    data: { [key: string]: any; };
    /**
    * Set of exceptions that occurred resolving the data providers.
    */
    exceptions: { [key: string]: DataProviderExceptionDetails; };
    /**
    * List of data providers resolved in the data-provider query
    */
    resolvedProviders: ResolvedDataProvider[];
    /**
    * Scope name applied to this data provider result.
    */
    scopeName: string;
    /**
    * Scope value applied to this data provider result.
    */
    scopeValue: string;
    /**
    * Property bag of shared data that was contributed to by any of the individual data providers
    */
    sharedData: { [key: string]: any; };
}

interface DaylightSavingsAdjustmentEntry {
    /**
    * Millisecond adjustment from UTC
    */
    offset: number;
    /**
    * Date that the offset adjustment starts
    */
    start: Date;
}

interface DiagnosticsContext {
    /**
    * Id of the current activity
    */
    activityId: string;
    allowStatsCollection: boolean;
    /**
    * Whether or not to enable static content bundling. This is on by default but the value can be overridden with a TFS-BUNDLING cookie or registry entry.
    */
    bundlingEnabled: boolean;
    /**
    * True if the CDN feature flag is enabled.
    */
    cdnAvailable: boolean;
    /**
    * True if the CDN feature flag is enabled and the user has not disabled CDN with a cookie.
    */
    cdnEnabled: boolean;
    clientLogLevel: number;
    debugMode: boolean;
    /**
    * Whether or not to diagnose the bundles.
    */
    diagnoseBundles: boolean;
    inExtensionFallbackMode: boolean;
    isDevFabric: boolean;
    sessionId: string;
    tracePointCollectionEnabled: boolean;
    tracePointProfileEnd: string;
    tracePointProfileStart: string;
    /**
    * Denotes the version of the web platform consumed by this service. Of the form M###.
    */
    webPlatformVersion: string;
}

interface DynamicBundlesCollection {
    scripts: DynamicScriptBundle[];
    scriptsExcludedByPath: string[];
    styles: DynamicCSSBundle[];
}

interface DynamicCSSBundle {
    clientId: string;
    contentLength: number;
    cssFiles: string[];
    fallbackThemeUri: string;
    uri: string;
}

interface DynamicScriptBundle {
    clientId: string;
    contentLength: number;
    integrity: string;
    uri: string;
}

interface ExtendedHostContext {
    authority: string;
    hostType: ContextHostType;
    id: string;
    isAADAccount: boolean;
    name: string;
    relativeUri: string;
    scheme: string;
    uri: string;
}

/**
* Audit log for an extension
*/
interface ExtensionAuditLog {
    /**
    * Collection of audit log entries
    */
    entries: ExtensionAuditLogEntry[];
    /**
    * Extension that the change was made for
    */
    extensionName: string;
    /**
    * Publisher that the extension is part of
    */
    publisherName: string;
}

/**
* An audit log entry for an extension
*/
interface ExtensionAuditLogEntry {
    /**
    * Change that was made to extension
    */
    auditAction: string;
    /**
    * Date at which the change was made
    */
    auditDate: Date;
    /**
    * Extra information about the change
    */
    comment: string;
    /**
    * Represents the user who made the change
    */
    updatedBy: any;
}

interface ExtensionAuthorization {
    id: string;
    scopes: string[];
}

/**
* Represents a single collection for extension data documents
*/
interface ExtensionDataCollection {
    /**
    * The name of the collection
    */
    collectionName: string;
    /**
    * A list of documents belonging to the collection
    */
    documents: any[];
    /**
    * The type of the collection's scope, such as Default or User
    */
    scopeType: string;
    /**
    * The value of the collection's scope, such as Current or Me
    */
    scopeValue: string;
}

/**
* Represents a query to receive a set of extension data collections
*/
interface ExtensionDataCollectionQuery {
    /**
    * A list of collections to query
    */
    collections: ExtensionDataCollection[];
}

interface ExtensionEvent {
    /**
    * The extension which has been updated
    */
    extension: any;
    /**
    * The current version of the extension that was updated
    */
    extensionVersion: string;
    /**
    * Name of the collection for which the extension was requested
    */
    host: ExtensionHost;
    /**
    * Gallery host url
    */
    links: ExtensionEventUrls;
    /**
    * Represents the user who initiated the update
    */
    modifiedBy: any;
    /**
    * The type of update that was made
    */
    updateType: ExtensionUpdateType;
}

/**
* Base class for an event callback for an extension
*/
interface ExtensionEventCallback {
    /**
    * The uri of the endpoint that is hit when an event occurs
    */
    uri: string;
}

/**
* Collection of event callbacks - endpoints called when particular extension events occur.
*/
interface ExtensionEventCallbackCollection {
    /**
    * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension disable has occurred.
    */
    postDisable: ExtensionEventCallback;
    /**
    * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension enable has occurred.
    */
    postEnable: ExtensionEventCallback;
    /**
    * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install has completed.
    */
    postInstall: ExtensionEventCallback;
    /**
    * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension uninstall has occurred.
    */
    postUninstall: ExtensionEventCallback;
    /**
    * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension update has occurred.
    */
    postUpdate: ExtensionEventCallback;
    /**
    * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install is about to occur.  Response indicates whether to proceed or abort.
    */
    preInstall: ExtensionEventCallback;
    /**
    * For multi-version extensions, defines an endpoint that gets called via an OPTIONS request to determine the particular version of the extension to be used
    */
    versionCheck: ExtensionEventCallback;
}

interface ExtensionEventUrls {
    extensionIcon: string;
    extensionPage: string;
    /**
    * Url of the extension management page
    */
    manageExtensionsPage: string;
}

/**
* Set of flags applied to extensions that are relevant to contribution consumers
*/
declare enum ExtensionFlags {
    /**
    * A built-in extension is installed for all VSTS accounts by default
    */
    BuiltIn = 1,
    /**
    * The extension comes from a fully-trusted publisher
    */
    Trusted = 2,
}

interface ExtensionHost {
    id: string;
    name: string;
}

/**
* How an extension should handle including contributions based on licensing
*/
interface ExtensionLicensing {
    /**
    * A list of contributions which deviate from the default licensing behavior
    */
    overrides: LicensingOverride[];
}

/**
* Base class for extension properties which are shared by the extension manifest and the extension model
*/
interface ExtensionManifest {
    /**
    * Uri used as base for other relative uri's defined in extension
    */
    baseUri: string;
    /**
    * List of shared constraints defined by this extension
    */
    constraints: ContributionConstraint[];
    /**
    * List of contributions made by this extension
    */
    contributions: Contribution[];
    /**
    * List of contribution types defined by this extension
    */
    contributionTypes: ContributionType[];
    /**
    * List of explicit demands required by this extension
    */
    demands: string[];
    /**
    * Collection of endpoints that get called when particular extension events occur
    */
    eventCallbacks: ExtensionEventCallbackCollection;
    /**
    * Secondary location that can be used as base for other relative uri's defined in extension
    */
    fallbackBaseUri: string;
    /**
    * Language Culture Name set by the Gallery
    */
    language: string;
    /**
    * How this extension behaves with respect to licensing
    */
    licensing: ExtensionLicensing;
    /**
    * Version of the extension manifest format/content
    */
    manifestVersion: any;
    /**
    * Default user claims applied to all contributions (except the ones which have been speficied restrictedTo explicitly) to control the visibility of a contribution.
    */
    restrictedTo: string[];
    /**
    * List of all oauth scopes required by this extension
    */
    scopes: string[];
    /**
    * The ServiceInstanceType(Guid) of the VSTS service that must be available to an account in order for the extension to be installed
    */
    serviceInstanceType: string;
}

/**
* A request for an extension (to be installed or have a license assigned)
*/
interface ExtensionRequest {
    /**
    * Required message supplied if the request is rejected
    */
    rejectMessage: string;
    /**
    * Date at which the request was made
    */
    requestDate: Date;
    /**
    * Represents the user who made the request
    */
    requestedBy: any;
    /**
    * Optional message supplied by the requester justifying the request
    */
    requestMessage: string;
    /**
    * Represents the state of the request
    */
    requestState: ExtensionRequestState;
    /**
    * Date at which the request was resolved
    */
    resolveDate: Date;
    /**
    * Represents the user who resolved the request
    */
    resolvedBy: any;
}

interface ExtensionRequestEvent {
    /**
    * The extension which has been requested
    */
    extension: any;
    /**
    * Information about the host for which this extension is requested
    */
    host: ExtensionHost;
    /**
    * Name of the collection for which the extension was requested
    */
    hostName: string;
    /**
    * Gallery host url
    */
    links: ExtensionRequestUrls;
    /**
    * The extension request object
    */
    request: ExtensionRequest;
    /**
    * The type of update that was made
    */
    updateType: ExtensionRequestUpdateType;
}

interface ExtensionRequestsEvent {
    /**
    * The extension which has been requested
    */
    extension: any;
    /**
    * Information about the host for which this extension is requested
    */
    host: ExtensionHost;
    /**
    * Gallery host url
    */
    links: ExtensionRequestUrls;
    /**
    * The extension request object
    */
    requests: ExtensionRequest[];
    /**
    * The type of update that was made
    */
    updateType: ExtensionRequestUpdateType;
}

/**
* Represents the state of an extension request
*/
declare enum ExtensionRequestState {
    /**
    * The request has been opened, but not yet responded to
    */
    Open = 0,
    /**
    * The request was accepted (extension installed or license assigned)
    */
    Accepted = 1,
    /**
    * The request was rejected (extension not installed or license not assigned)
    */
    Rejected = 2,
}

declare enum ExtensionRequestUpdateType {
    Created = 1,
    Approved = 2,
    Rejected = 3,
    Deleted = 4,
}

interface ExtensionRequestUrls {
    extensionIcon: string;
    extensionPage: string;
    /**
    * Link to view the extension request
    */
    requestPage: string;
}

/**
* The state of an extension
*/
interface ExtensionState {
    extensionName: string;
    flags: ExtensionStateFlags;
    installationIssues: InstalledExtensionStateIssue[];
    lastUpdated: Date;
    /**
    * The time at which the version was last checked
    */
    lastVersionCheck: Date;
    publisherName: string;
    version: string;
}

/**
* States of an extension Note:  If you add value to this enum, you need to do 2 other things.  First add the back compat enum in value src\Vssf\Sdk\Server\Contributions\InstalledExtensionMessage.cs.  Second, you can not send the new value on the message bus.  You need to remove it from the message bus event prior to being sent.
*/
declare enum ExtensionStateFlags {
    /**
    * No flags set
    */
    None = 0,
    /**
    * Extension is disabled
    */
    Disabled = 1,
    /**
    * Extension is a built in
    */
    BuiltIn = 2,
    /**
    * Extension has multiple versions
    */
    MultiVersion = 4,
    /**
    * Extension is not installed.  This is for builtin extensions only and can not otherwise be set.
    */
    UnInstalled = 8,
    /**
    * Error performing version check
    */
    VersionCheckError = 16,
    /**
    * Trusted extensions are ones that are given special capabilities. These tend to come from Microsoft and can't be published by the general public.  Note: BuiltIn extensions are always trusted.
    */
    Trusted = 32,
    /**
    * Extension is currently in an error state
    */
    Error = 64,
    /**
    * Extension scopes have changed and the extension requires re-authorization
    */
    NeedsReauthorization = 128,
    /**
    * Error performing auto-upgrade. For example, if the new version has demands not supported the extension cannot be auto-upgraded.
    */
    AutoUpgradeError = 256,
    /**
    * Extension is currently in a warning state, that can cause a degraded experience. The degraded experience can be caused for example by some installation issues detected such as implicit demands not supported.
    */
    Warning = 512,
}

declare enum ExtensionUpdateType {
    Installed = 1,
    Uninstalled = 2,
    Enabled = 3,
    Disabled = 4,
    VersionUpdated = 5,
    ActionRequired = 6,
    ActionResolved = 7,
}

interface ExtensionUrls {
    /**
    * Url of the extension icon
    */
    extensionIcon: string;
    /**
    * Link to view the extension details page
    */
    extensionPage: string;
}

interface FeatureAvailabilityContext {
    featureStates: { [key: string]: boolean; };
}

interface GlobalizationContext {
    culture: string;
    /**
    * Gets the explicitly-set theme, or the empty string if a theme was not explicitly set. An explicitly-set theme is set either in the query string (?theme=[themename]) or in the user's profile. However, the default theme set in the profile is not considered to be an explicitly-set theme.
    */
    explicitTheme: string;
    theme: string;
    timeZoneId: string;
    timezoneOffset: number;
    typeAheadDisabled: boolean;
}

interface HostContext {
    id: string;
    name: string;
    relativeUri: string;
    uri: string;
}

/**
* Model representing a hub in VSTS pages' navigation menu
*/
interface Hub {
    ariaLabel: string;
    builtIn: boolean;
    groupId: string;
    hidden: boolean;
    icon: string;
    id: string;
    isSelected: boolean;
    name: string;
    order: any;
    supportsXHRNavigate: boolean;
    uri: string;
}

/**
* Model representing a hub group in VSTS pages' navigation menu
*/
interface HubGroup {
    builtIn: boolean;
    hasHubs: boolean;
    hidden: boolean;
    icon: string;
    id: string;
    name: string;
    nonCollapsible: boolean;
    order: any;
    uri: string;
}

/**
* Context information containing the relevant hubs and hub groups for a given context
*/
interface HubsContext {
    allHubs: Hub[];
    hubGroups: HubGroup[];
    hubGroupsCollectionContributionId: string;
    hubs: Hub[];
    pinningPreferences: PinningPreferences;
    selectedHubGroupId: string;
    selectedHubId: string;
    selectedNavigationIds: string[];
}

/**
* Model to represent a TeamFoundationIdentity
*/
interface IdentityModel {
    /**
    * Custom display name
    */
    customDisplayName: string;
    /**
    * Display name
    */
    displayName: string;
    /**
    * Email address
    */
    email: string;
    /**
    * Unique team foundation id
    */
    id: string;
    /**
    * Is the identity active
    */
    isActive: boolean;
    /**
    * Is the identity a group/team
    */
    isContainer: boolean;
    /**
    * The provider's display name for this identity
    */
    providerDisplayName: string;
    /**
    * Unique name for this identity
    */
    uniqueName: string;
}

/**
* Represents a VSTS extension along with its installation state
*/
interface InstalledExtension {
    baseUri: string;
    constraints: ContributionConstraint[];
    contributions: Contribution[];
    contributionTypes: ContributionType[];
    demands: string[];
    eventCallbacks: ExtensionEventCallbackCollection;
    /**
    * The friendly extension id for this extension - unique for a given publisher.
    */
    extensionId: string;
    /**
    * The display name of the extension.
    */
    extensionName: string;
    fallbackBaseUri: string;
    /**
    * This is the set of files available from the extension.
    */
    files: any[];
    /**
    * Extension flags relevant to contribution consumers
    */
    flags: ExtensionFlags;
    /**
    * Information about this particular installation of the extension
    */
    installState: InstalledExtensionState;
    language: string;
    /**
    * This represents the date/time the extensions was last updated in the gallery. This doesnt mean this version was updated the value represents changes to any and all versions of the extension.
    */
    lastPublished: Date;
    licensing: ExtensionLicensing;
    manifestVersion: any;
    /**
    * Unique id of the publisher of this extension
    */
    publisherId: string;
    /**
    * The display name of the publisher
    */
    publisherName: string;
    /**
    * Unique id for this extension (the same id is used for all versions of a single extension)
    */
    registrationId: string;
    restrictedTo: string[];
    scopes: string[];
    serviceInstanceType: string;
    /**
    * Version of this extension
    */
    version: string;
}

/**
* The state of an installed extension
*/
interface InstalledExtensionState {
    /**
    * States of an installed extension
    */
    flags: ExtensionStateFlags;
    /**
    * List of installation issues
    */
    installationIssues: InstalledExtensionStateIssue[];
    /**
    * The time at which this installation was last updated
    */
    lastUpdated: Date;
}

/**
* Represents an installation issue
*/
interface InstalledExtensionStateIssue {
    /**
    * The error message
    */
    message: string;
    /**
    * Source of the installation issue, for example  "Demands"
    */
    source: string;
    /**
    * Installation issue type (Warning, Error)
    */
    type: InstalledExtensionStateIssueType;
}

/**
* Installation issue type (Warning, Error)
*/
declare enum InstalledExtensionStateIssueType {
    /**
    * Represents an installation warning, for example an implicit demand not supported
    */
    Warning = 0,
    /**
    * Represents an installation error, for example an explicit demand not supported
    */
    Error = 1,
}

/**
* Reference to a javascript file to include on a page
*/
interface JavascriptFileReference {
    /**
    * Condition to check in the case that Url lives on a CDN. The fallback script will be included if this check fails.
    */
    fallbackCondition: string;
    /**
    * Fallback url to use in case Url lives on a CDN
    */
    fallbackUrl: string;
    /**
    * Id of the reference (JQuery, JQueryUI, MicrosoftAjax, etc.)
    */
    identifier: string;
    /**
    * Is this a core javascript file that needs to be included in all child extension frames
    */
    isCoreModule: boolean;
    /**
    * Url of the javascript reference
    */
    url: string;
}

/**
* Class used to wrap arrays in an object.
*/
interface JsonArrayWrapper {
    __wrappedArray: string;
}

/**
* Maps a contribution to a licensing behavior
*/
interface LicensingOverride {
    /**
    * How the inclusion of this contribution should change based on licensing
    */
    behavior: ContributionLicensingBehaviorType;
    /**
    * Fully qualified contribution id which we want to define licensing behavior for
    */
    id: string;
}

interface MicrosoftAjaxConfig {
    cultureInfo: any;
}

/**
* AMD javascript module loader configuration
*/
interface ModuleLoaderConfiguration {
    baseUrl: string;
    contributionPaths: { [key: string]: ContributionPath; };
    paths: { [key: string]: string; };
    shim: { [key: string]: ModuleLoaderShimConfiguration; };
    /**
    * The maximum amount of time (in seconds) the AMD loader will wait for scripts to load.
    */
    waitSeconds: number;
}

/**
* AMD javascript module loader shim configuration
*/
interface ModuleLoaderShimConfiguration {
    deps: string[];
    exports: string;
}

/**
* Structure to specify current navigation context of the executing request. The navigation context content's are generally obtained from the request URL. Some context specifiers such as "Account" can be implicit and might come from current IVssServiceHost.
*/
interface NavigationContext {
    /**
    * A token to show which area the request has been targeted to. By default there are two areas "Admin" and "Api". They can be specified in the URL as _admin and _api respectively.
    */
    area: string;
    /**
    * Command name for the current request's route. Used in telemetry and reporting.
    */
    commandName: string;
    /**
    * Current action route value
    */
    currentAction: string;
    /**
    * Current controller route value
    */
    currentController: string;
    /**
    * Current parameters route value (the path after the controller and action in the url)
    */
    currentParameters: string;
    /**
    * The id of the matched route
    */
    routeId: string;
    /**
    * The templates for the matched route
    */
    routeTemplates: string[];
    /**
    * The set of route values for this request
    */
    routeValues: { [key: string]: string; };
    /**
    * Flag to show top most navigation context. For example the URL http://server:port/collection/project/_controller/action sets the Project bit while the URL http://server:port/collection/project/_admin/_controller/action sets also sets the area property to Admin.
    */
    topMostLevel: NavigationContextLevels;
}

/**
* Flags to show which tokens of the navigation context are present in the current request URL. The request url's context part are formed like http://server:port[/{collection}[/{project}[/{team}]]][/_admin]/_{controller}/{action} The tokens {collection}, {project} and {team} are navigation level tokens whereas _admin segment is a switch to show admin areas of the site.
*/
declare enum NavigationContextLevels {
    None = 0,
    /**
    * Root level in Azure.
    */
    Deployment = 1,
    /**
    * Root level in on premises. Neither of {collection}, {project} and {team} tokens have information
    */
    Application = 2,
    /**
    * Flag to show {collection} token has information.
    */
    Collection = 4,
    /**
    * Flag to show {project} token has information.
    */
    Project = 8,
    /**
    * Flag to show {team} token has information.
    */
    Team = 16,
    /**
    * Sugar for all application levels.
    */
    ApplicationAll = 30,
    /**
    * Sugar for all levels
    */
    All = 31,
}

/**
* Global context placed on each VSSF web page (through json island data) which gives enough information for core TypeScript modules/controls on the page to operate
*/
interface PageContext {
    /**
    * Configuration for reporting telemetry/usage data to App Insights
    */
    appInsightsConfiguration: AppInsightsConfiguration;
    /**
    * Core javascript and css references
    */
    coreReferences: CoreReferencesContext;
    /**
    * Specifies the prefixes for CSS modules that should map to the current service. e.g. "VSS/LoaderPlugins/Css!EMS:ExtensionManagement" would map to ExtensionManagement.css under the themed content path of this service if "EMS" is in the CSSModulePrefixes list.
    */
    cssModulePrefixes: string[];
    /**
    * Diagnostic related information for the current page
    */
    diagnostics: DiagnosticsContext;
    /**
    * Feature flag states to include by default in page data (avoids AJAX lookup)
    */
    featureAvailability: FeatureAvailabilityContext;
    /**
    * Globalization data for the current page based on the current user's settings
    */
    globalization: GlobalizationContext;
    /**
    * Cached set of hubs and hub groups for the given request/navigation-context
    */
    hubsContext: HubsContext;
    /**
    * Configuration needed for Microsoft.Ajax library
    */
    microsoftAjaxConfig: MicrosoftAjaxConfig;
    /**
    * The (AMD) module configuration
    */
    moduleLoaderConfig: ModuleLoaderConfiguration;
    /**
    * Current navigation context.
    */
    navigation: NavigationContext;
    /**
    * The service instance type id for the VSTS service serving this page
    */
    serviceInstanceId: string;
    serviceLocations: ServiceLocations;
    /**
    * Contains global time zone configuration information (e.g. which dates DST changes)
    */
    timeZonesConfiguration: TimeZonesConfiguration;
    /**
    * Web Access configuration
    */
    webAccessConfiguration: ConfigurationContext;
    /**
    * The web context information for the given page request
    */
    webContext: WebContext;
}

interface PageContribution {
    id: string;
    includes: string[];
    properties: any;
    targets: string[];
    type: string;
}

interface PageContributionProviderDetails {
    displayName: string;
    name: string;
    properties: { [key: string]: string; };
}

interface PageXHRData {
    activityId: string;
    bundles: DynamicBundlesCollection;
    contributionsData: ContributionsPageData;
    dataProviderData: DataProviderResult;
    featureAvailability: FeatureAvailabilityContext;
    navigation: NavigationContext;
    performanceTimings: { [key: string]: any; };
    serviceLocations: ServiceLocations;
    staticContentVersion: string;
}

interface PinningPreferences {
    pinnedHubGroupIds: string[];
    pinnedHubs: { [key: string]: string[]; };
    unpinnedHubGroupIds: string[];
    unpinnedHubs: { [key: string]: string[]; };
}

/**
* A request for an extension (to be installed or have a license assigned)
*/
interface RequestedExtension {
    /**
    * The unique name of the extension
    */
    extensionName: string;
    /**
    * A list of each request for the extension
    */
    extensionRequests: ExtensionRequest[];
    /**
    * DisplayName of the publisher that owns the extension being published.
    */
    publisherDisplayName: string;
    /**
    * Represents the Publisher of the requested extension
    */
    publisherName: string;
    /**
    * The total number of requests for an extension
    */
    requestCount: number;
}

/**
* Entry for a specific data provider's resulting data
*/
interface ResolvedDataProvider {
    /**
    * The total time the data provider took to resolve its data (in milliseconds)
    */
    duration: any;
    error: string;
    id: string;
}

interface Scope {
    description: string;
    title: string;
    value: string;
}

/**
* Holds a lookup of urls for different services (at different host levels)
*/
interface ServiceLocations {
    locations: { [key: string]: { [key: number]: string; }; };
}

/**
* Reference to a CSS file to include on a page
*/
interface StylesheetReference {
    /**
    * Url of the high-contrast version of the CSS file
    */
    highContrastUrl: string;
    /**
    * Is this a core stylesheet that needs to be included in child frames
    */
    isCoreStylesheet: boolean;
    /**
    * Url of the CSS file
    */
    url: string;
}

/**
* Information about the extension
*/
interface SupportedExtension {
    /**
    * Unique Identifier for this extension
    */
    extension: string;
    /**
    * Unique Identifier for this publisher
    */
    publisher: string;
    /**
    * Supported version for this extension
    */
    version: string;
}

interface TeamContext {
    id: string;
    name: string;
}

/**
* Data contract to represent a given team foundation service host (account, collection, deployment)
*/
interface TeamFoundationServiceHostModel {
    /**
    * Type of host (deployment, account, collection)
    */
    hostType: any;
    /**
    * Unique id of the host (collection id, account id, etc.)
    */
    instanceId: string;
    /**
    * Name of the host (collection name, account name, etc.)
    */
    name: string;
    /**
    * Path of the service host, relative to the root virtual directory (e.g. DefaultCollection)
    */
    relVDir: string;
    /**
    * Path of the service host relative to the web application root (e.g. /tfs/DefaultCollection)
    */
    vDir: string;
}

interface TfsMailSettings {
    enabled: boolean;
}

/**
* Internal structure to describe IVssServiceHost
*/
interface TfsServiceHostDescriptor {
    hostType: any;
    id: string;
    name: string;
    relVdir: string;
    vdir: string;
}

interface TimeZonesConfiguration {
    daylightSavingsAdjustments: DaylightSavingsAdjustmentEntry[];
}

interface UserContext {
    email: string;
    id: string;
    limitedAccess: boolean;
    name: string;
    subjectId: string;
    subjectType: string;
    uniqueName: string;
}

/**
* Context information for all web access requests
*/
interface WebContext {
    account: HostContext;
    /**
    * Information about the Collection used in the current request (may be null)
    */
    collection: HostContext;
    /**
    * Information about the current request context's host
    */
    host: ExtendedHostContext;
    /**
    * Information about the project used in the current request (may be null)
    */
    project: ContextIdentifier;
    /**
    * Information about the team used in the current request (may be null)
    */
    team: TeamContext;
    /**
    * Information about the current user
    */
    user: UserContext;
}

/**
* Contextual data for web-page-related data providers about the originating (host/source) page
*/
interface WebPageDataProviderPageSource {
    /**
    * List of paths contributed by the host which are available to 3rd party extension developers through VSS.SDK
    */
    contributionPaths: string[];
    /**
    * Diagnostics context (debug mode, activity id, etc.) of the source page
    */
    diagnostics: DiagnosticsContext;
    /**
    * Globalization context (theme, time zone, etc.) of the source page
    */
    globalization: WebPageGlobalizationContext;
    /**
    * The navigation context for the host page that is loading the data provider
    */
    navigation: NavigationContext;
    /**
    * The project context for the host page that is loading the data provider
    */
    project: ContextIdentifier;
    /**
    * Currently selected hubgroup id
    */
    selectedHubGroupId: string;
    /**
    * Currently selected hub id
    */
    selectedHubId: string;
    /**
    * The team context for the host page that is loading the data provider
    */
    team: ContextIdentifier;
    /**
    * The url of the host page that is loading the data provider
    */
    url: string;
}

/**
* Lightweight globalization context for web-page-related data providers
*/
interface WebPageGlobalizationContext {
    /**
    * UI Culture of the host page
    */
    culture: string;
    /**
    * Theme of the host page
    */
    theme: string;
}

interface EventTarget {
    checked: boolean;
    nodeType: number;
}

interface Date {
    toGMTString(): string;
}

interface IErrorCallback {
    (error: any): void;
}

interface IResultCallback extends Function {
}

interface IArgsFunctionR<TResult> {
    (...args: any[]): TResult;
}

interface IFunctionPR<TParam, TResult> {
    (param: TParam): TResult;
}

interface IFunctionPPR<TParam1, TParam2, TResult> {
    (param1: TParam1, param2: TParam2): TResult;
}

interface IFunctionPPPR<TParam1, TParam2, TParam3, TResult> {
    (param1: TParam1, param2: TParam2, param3: TParam3): TResult;
}

interface IComparer<T> extends IFunctionPPR<T, T, number> {
}

interface IDictionaryStringTo<T> {
    [key: string]: T;
}

interface IDictionaryNumberTo<T> {
    [key: number]: T;
}

interface IEventHandler extends Function {
}

interface JQueryEventHandler {
    (eventObject: JQueryEventObject, args?: any): any;
}

interface IWebApiArrayResult {
    count: number;
    value: any[];
}

interface Window {
    ActiveXObject: any;
    DOMParser: any;
    XSLTProcessor: any;
    vsSdkOnLoad:() => void;
}

interface ServerError {
    typeKey?: string;
}

interface TfsError extends Error {
    status?: string;
    stack?: string;
    serverError?: ServerError;
    [key: string]: any;
}

//These variables defined by server.
declare var exports: any;

declare var _disabledPlugins: string[];

interface IWebAccessPlugin {
    namespace: string;
    loadAfter: string;
}

declare var _plugins: IWebAccessPlugin[];
declare var _builtinPlugins: IWebAccessPlugin[];

interface IWebAccessPluginBase {
    namespace: string;
    base: string;
}

declare var _builtInBases: IWebAccessPluginBase[];
declare var _bases: IWebAccessPluginBase[];

interface IDisposable {
    dispose(): void;
}

interface IKeyValuePair<TKey, TValue> {
    key: TKey;
    value: TValue;
}

declare var require: Require;
declare var define: RequireDefine;
declare module "VSS/Accounts/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export interface Account {
    /**
     * Identifier for an Account
     */
    accountId: string;
    /**
     * Name for an account
     */
    accountName: string;
    /**
     * Owner of account
     */
    accountOwner: string;
    /**
     * Current account status
     */
    accountStatus: AccountStatus;
    /**
     * Type of account: Personal, Organization
     */
    accountType: AccountType;
    /**
     * Uri for an account
     */
    accountUri: string;
    /**
     * Who created the account
     */
    createdBy: string;
    /**
     * Date account was created
     */
    createdDate: Date;
    hasMoved: boolean;
    /**
     * Identity of last person to update the account
     */
    lastUpdatedBy: string;
    /**
     * Date account was last updated
     */
    lastUpdatedDate: Date;
    /**
     * Namespace for an account
     */
    namespaceId: string;
    newCollectionId: string;
    /**
     * Organization that created the account
     */
    organizationName: string;
    /**
     * Extended properties
     */
    properties: any;
    /**
     * Reason for current status
     */
    statusReason: string;
}
export interface AccountCreateInfoInternal {
    accountName: string;
    creator: string;
    organization: string;
    preferences: AccountPreferencesInternal;
    properties: any;
    serviceDefinitions: {
        key: string;
        value: string;
    }[];
}
export interface AccountPreferencesInternal {
    culture: any;
    language: any;
    timeZone: any;
}
export enum AccountStatus {
    None = 0,
    /**
     * This hosting account is active and assigned to a customer.
     */
    Enabled = 1,
    /**
     * This hosting account is disabled.
     */
    Disabled = 2,
    /**
     * This account is part of deletion batch and scheduled for deletion.
     */
    Deleted = 3,
    /**
     * This account is not mastered locally and has physically moved.
     */
    Moved = 4
}
export enum AccountType {
    Personal = 0,
    Organization = 1
}
export enum AccountUserStatus {
    None = 0,
    /**
     * User has signed in at least once to the VSTS account
     */
    Active = 1,
    /**
     * User cannot sign in; primarily used by admin to temporarily remove a user due to absence or license reallocation
     */
    Disabled = 2,
    /**
     * User is removed from the VSTS account by the VSTS account admin
     */
    Deleted = 3,
    /**
     * User is invited to join the VSTS account by the VSTS account admin, but has not signed up/signed in yet
     */
    Pending = 4,
    /**
     * User can sign in; primarily used when license is in expired state and we give a grace period
     */
    Expired = 5,
    /**
     * User is disabled; if reenabled, they will still be in the Pending state
     */
    PendingDisabled = 6
}
export var TypeInfo: {
    Account: any;
    AccountStatus: {
        enumValues: {
            "none": number;
            "enabled": number;
            "disabled": number;
            "deleted": number;
            "moved": number;
        };
    };
    AccountType: {
        enumValues: {
            "personal": number;
            "organization": number;
        };
    };
    AccountUserStatus: {
        enumValues: {
            "none": number;
            "active": number;
            "disabled": number;
            "deleted": number;
            "pending": number;
            "expired": number;
            "pendingDisabled": number;
        };
    };
};
}
declare module "VSS/Accounts/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Accounts/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected accountsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} accountId
     * @return IPromise<Contracts.Account>
     */
    getAccount(accountId: string): IPromise<Contracts.Account>;
    /**
     * @param {Contracts.AccountCreateInfoInternal} info
     * @param {boolean} usePrecreated
     * @return IPromise<Contracts.Account>
     */
    createAccount(info: Contracts.AccountCreateInfoInternal, usePrecreated?: boolean): IPromise<Contracts.Account>;
}
export class CommonMethods3_2To5 extends CommonMethods2To5 {
    protected accountsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * Get a list of accounts for a specific owner or a specific member.
     *
     * @param {string} ownerId - ID for the owner of the accounts.
     * @param {string} memberId - ID for a member of the accounts.
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
/**
 * @exemptedapi
 */
export class AccountsHttpClient5 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AccountsHttpClient4_1 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AccountsHttpClient4 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AccountsHttpClient3_2 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class AccountsHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} ownerId
     * @param {string} memberId
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
export class AccountsHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} ownerId
     * @param {string} memberId
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
export class AccountsHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} ownerId
     * @param {string} memberId
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
export class AccountsHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} ownerId
     * @param {string} memberId
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
export class AccountsHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} ownerId
     * @param {string} memberId
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
export class AccountsHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} ownerId
     * @param {string} memberId
     * @param {string} properties
     * @return IPromise<Contracts.Account[]>
     */
    getAccounts(ownerId?: string, memberId?: string, properties?: string): IPromise<Contracts.Account[]>;
}
export class AccountsHttpClient extends AccountsHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return AccountsHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): AccountsHttpClient4_1;
}
declare module "VSS/Adapters/Knockout" {
import Controls = require("VSS/Controls");
export interface ITemplateViewModel extends IDisposable {
    dispose(): void;
}
export class TemplateViewModel implements ITemplateViewModel {
    /**
     * Manager for disposables.
     */
    private _disposalManager;
    constructor();
    /**
     * Disposes all disposables.
     */
    dispose(): void;
    /**
     * Proxy for a knockout subscription to keep track of it to ensure that when the control is disposed, subscription is also disposed.
     */
    subscribe(subscribable: KnockoutSubscribable<any>, callback: (newValue: any) => void): IDisposable;
    /**
     * Proxy for a knockout computed to keep track of it to ensure that when the control is disposed, computed is also disposed.
     */
    computed(func: () => any): KnockoutComputed<any>;
    /**
     * Adds a disposable object to the list
     */
    _addDisposable(disposable: IDisposable): IDisposable;
}
export interface TemplateControlRegistration {
    /**
     * Type of the control to be registered.
     */
    controlType: any;
    /**
     * Delegate used to generate the view model for the registered control.
     */
    viewModelGenerator: (context?: any) => ITemplateViewModel;
}
export interface TemplateControlOptions {
    /**
     * Html template is going to be set as the html content for the element.
     */
    templateHtml?: string;
    /**
     * If templateId is used there needs to be a script element (with type="text/html")
     * in the DOM with the id equal to templateId.
     * This templateId will be used to get the template from the DOM.
     */
    templateId?: string;
}
export interface ITemplateControl {
    /**
     * Applies the template binding on the specified element.
     *
     * @param element Element owning the template and viewmodel to be bound.
     */
    applyBinding(element: JQuery): void;
    /**
     * Perform verious disposals for the control.
     */
    dispose(): void;
}
export class TemplateControl<TViewModel extends ITemplateViewModel> extends Controls.BaseControl implements ITemplateControl {
    /**
     * Registers a template control to be invoked later.
     *
     * @param templateId Id of the template.
     * @param controlType Type of the registered control.
     * @param viewModelGenerator Delegate to generate the viewmodel.
     */
    static registerBinding(templateId: string, controlType: any, viewModelGenerator: (context?: any) => ITemplateViewModel): void;
    /**
     * Creates a new template control using registered control specified by template id.
     *
     * @param templateId Id of the template.
     * @param element Element owning the template and viewmodel to be bound.
     * @param viewModelContext Context used to generate view model.
     * @return New instance of the control.
     */
    static applyRegisteredBinding<TControl extends ITemplateControl, TViewModel extends ITemplateViewModel>(templateId: string, element: JQuery, viewModelContext: any): TControl;
    /**
     * Creates a new template control using the specified type, element and options.
     *
     * @param controlType Type of the control.
     * @param element Element owning the template and viewmodel to be bound.
     * @param viewModel View model used for binding.
     * @param options Template options like templateHtml and templateId.
     * @return New instance of the control.
     */
    static applyBinding<TControl extends ITemplateControl, TViewModel>(controlType: any, element: JQuery, viewModel: TViewModel, options: TemplateControlOptions): TControl;
    /**
     * View model used for binding.
     */
    private _viewModel;
    /**
     * Manager for disposables.
     */
    private _disposalManager;
    /**
     * Do not use this! Instead, use TemplateControl.applyBinding.
     */
    constructor(viewModel: TViewModel, options?: TemplateControlOptions);
    /**
     * Gets the viewmodel bound to this control.
     */
    getViewModel(): TViewModel;
    /**
     * See interface.
     */
    applyBinding(element: JQuery): void;
    /**
     * Proxy for a knockout subscription to keep track of it to ensure that when the control is disposed, subscription is also disposed.
     */
    subscribe(subscribable: KnockoutSubscribable<any>, callback: (newValue: any) => void): IDisposable;
    /**
     * Proxy for a knockout computed to keep track of it to ensure that when the control is disposed, computed is also disposed.
     */
    computed(func: () => any): KnockoutComputed<any>;
    /**
     * See base.
     */
    _cleanup(): void;
    /**
     * Default template binding which is knockout.
     * By overriding this method, a different binding pattern can be used.
     */
    _performBinding(element: JQuery, options: TemplateControlOptions): void;
}
}
declare module "VSS/Ajax" {
export interface JQueryAjaxResult {
    jqXHR: JQueryXHR;
    textStatus: string;
}
export interface JQueryAjaxSuccessResult extends JQueryAjaxResult {
    data: any;
}
export interface JQueryAjaxErrorResult extends JQueryAjaxResult {
    errorThrown: any;
}
/**
* Custom DataTypes that can be used in addition to jQuery's default text, json, xml, etc. types.
* This module provides custom ajaxTransports for these types
*/
export module CustomTransportDataTypes {
    /**
    * Raw binary data returned as an ArrayBuffer
    */
    var Binary: string;
}
/**
* Issue an AJAX request. This is a wrapper around jquery's ajax method that handles VSS authentication
* and triggers events that can be listened to by other modules.
*
* @param requestUrl Url to send the request to
* @param ajaxOptions jQuery.ajax options
* @param vssRequestOptions VSS specific request options
* @param useAjaxResult If true, textStatus and jqXHR are added to the success callback. In this case, spread (instead of then) needs to be used
*/
export function issueRequest(requestUrl: string, ajaxOptions: JQueryAjaxSettings, vssRequestOptions?: IVssAjaxOptions): IPromise<any>;
/**
* Add a listener that gets notified whenever requests from this client begin/end/etc.
*
* @param listener HttpClient listener to add
*/
export function addGlobalListener(listener: IVssAjaxEventListener): void;
/**
* Remove a listener that gets notified whenever requests from this client begin/end/etc.
*
* @param listener HttpClient listener to remove
*/
export function removeGlobalListener(listener: IVssAjaxEventListener): void;
}
declare module "VSS/Artifacts/Constants" {
export module ArtifactTypeNames {
    var TcmResult: string;
    var TcmResultAttachment: string;
    var TcmTest: string;
    var Build: string;
    var VersionedItem: string;
    var LatestItemVersion: string;
    var Changeset: string;
    var Shelveset: string;
    var WorkItem: string;
    var Storyboard: string;
    var Commit: string;
    var CodeReviewId: string;
    var CodeReviewSdkId: string;
    var PullRequestId: string;
    var ProjectDownloadProject: string;
    /**
    * A Git Ref
    */
    var Ref: string;
    var WikiPage: string;
}
export module ToolNames {
    var VersionControl: string;
    var WorkItemTracking: string;
    var RemoteWorkItemTracking: string;
    var TeamBuild: string;
    var TestManagement: string;
    var Requirements: string;
    var Hyperlink: string;
    var Legacy: string;
    var CodeSense: string;
    var Git: string;
    var CodeReview: string;
    var ProjectDownload: string;
    var Wiki: string;
}
}
declare module "VSS/Artifacts/Services" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Service = require("VSS/Service");
export interface IArtifactData {
    uri?: string;
    tool: string;
    type: string;
    id: string;
}
export class Artifact {
    static _execute(artifact: Artifact, webContext: Contracts_Platform.WebContext): void;
    static ACTION_ARTIFACT_EXECUTE: string;
    _data: any;
    _error: any;
    constructor(data: IArtifactData);
    getUri(): string;
    getTool(): string;
    getType(): string;
    getId(): string;
    /**
     * @return
     */
    getTitle(): string;
    setError(error: any): void;
    getError(): any;
    execute(webContext: Contracts_Platform.WebContext): any;
    /**
     * @return
     */
    getUrl(webContext: Contracts_Platform.WebContext): string;
}
export class LinkingUtilities {
    static VSTFS: string;
    static URI_SEPARATOR: string;
    /**
     * Creates an artifact URI using specified artifact.
     *
     * @param artifact Artifact should have the following properties:
     *     - tool: Artifact tool name
     *     - type: Artifact type
     *     - id: Artifact tool specific id
     * @return
     */
    static encodeUri(artifact: any): string;
    /**
     * Decodes the specified artifact URI and creates artifact object which has tool, type and id properties.
     *
     * @param artifactUri URI to decode
     * @return
     */
    static decodeUri(artifactUri: string): IArtifactData;
    /**
     * Decodes a uri component, maintaining backwards compatibility with how URIs were encoded
     * from the rich client and in VS2010 and earlier versions.
     *
     * @param encodedURIComponent URI component to decode
     * @return
     */
    static legacyDecodeURIComponent(encodedURIComponent: string): string;
}
export class ClientLinking extends Service.VssService {
    static MODE_TRANSLATEURL: string;
    static registerArtifactResolver(toolName: string, resolver: any): void;
    static getArtifactResolver(toolName: string): any;
    constructor();
    beginResolveArtifacts(artifactUris: string[], options?: any, callback?: IResultCallback, errorCallback?: IErrorCallback): void;
}
}
declare module "VSS/Authentication/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export enum DelegatedAppTokenType {
    Session = 0,
    App = 1
}
export interface WebSessionToken {
    appId: string;
    extensionName: string;
    force: boolean;
    name: string;
    namedTokenId: string;
    publisherName: string;
    token: string;
    tokenType: DelegatedAppTokenType;
    validTo: Date;
}
export var TypeInfo: {
    DelegatedAppTokenType: {
        enumValues: {
            "session": number;
            "app": number;
        };
    };
    WebSessionToken: any;
};
}
declare module "VSS/Authentication/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Authentication/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected sessionTokenApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.WebSessionToken} sessionToken
     * @return IPromise<Contracts.WebSessionToken>
     */
    createSessionToken(sessionToken: Contracts.WebSessionToken): IPromise<Contracts.WebSessionToken>;
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class AuthenticationHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class AuthenticationHttpClient extends AuthenticationHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
}
declare module "VSS/Authentication/Services" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Authentication_Contracts_Async = require("VSS/Authentication/Contracts");
export module CoreNamedWebSessionTokenIds {
    var Profile: string;
}
/**
* Helper methods for dealing with basic auth
*/
export module BasicAuthHelpers {
    /**
    * Create the Authorization header value given the basic auth credentials
    *
    * @param user The username portion of the credentials
    * @param password The password portion of the credentials
    */
    function getBasicAuthHeader(user: string, password: string): string;
    /**
    * Create base-64 encoded user:password value used for basic auth.
    *
    * @param user The username portion of the credentials
    * @param password The password portion of the credentials
    */
    function getBasicAuthValue(user: string, password: string): string;
}
/**
* Helper methods for dealing with bearer auth
*/
export module BearerAuthHelpers {
    /**
    * Create the Authorization header value given the bearer token
    *
    * @param token bearer token
    */
    function getBearerAuthHeader(token: string): string;
}
/**
* IAuthTokenManager for a named web session token.
*/
export class NamedWebSessionTokenManager implements IAuthTokenManager<Authentication_Contracts_Async.WebSessionToken> {
    private _namedTokenId;
    private _tokenPromise;
    private _tokenExpirationTime;
    constructor(namedTokenId: string);
    /**
    * Get the auth token to use for this request.
    */
    getAuthToken(refresh?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<Authentication_Contracts_Async.WebSessionToken>;
    /**
     * Gets the authorization header to use in a request from the given token
     *
     * @param sessionToken Used for token key.
     * @return the value to use for the Authorization header in a request.
     */
    getAuthorizationHeader(sessionToken: Authentication_Contracts_Async.WebSessionToken): string;
}
/**
* IAuthTokenManager for an explicit basic auth token.
*/
export class BasicAuthTokenManager implements IAuthTokenManager<string> {
    private _user;
    private _password;
    constructor(user: string, password: string);
    /**
    * Get the auth token to use for this request.
    */
    getAuthToken(refresh?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<string>;
    /**
     * Gets the authorization header to use in a request from the given token
     *
     * @param sessionToken Used for token key.
     * @return the value to use for the Authorization header in a request.
     */
    getAuthorizationHeader(sessionToken: string): string;
}
export class BearerAuthTokenManager implements IAuthTokenManager<string> {
    protected _token: string;
    constructor(token: string);
    /**
    * Get the auth token to use for this request.
    */
    getAuthToken(refresh?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<string>;
    /**
     * Gets the authorization header to use in a request from the given token
     *
     * @param sessionToken Used for token key.
     * @return the value to use for the Authorization header in a request.
     */
    getAuthorizationHeader(sessionToken: string): string;
    protected _getTokenHeader(): string;
}
export class WebSessionTokenManager extends BearerAuthTokenManager {
    private _sessionToken;
    private _hostUrl;
    constructor(sessionToken: Authentication_Contracts_Async.WebSessionToken, hostUrl?: string);
    /**
    * Get the auth token to use for this request.
    */
    getAuthToken(refresh?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<string>;
}
/**
* Exposes the default auth token manager for collection-level tokens
*/
export var authTokenManager: IAuthTokenManager<any>;
/**
* Fetch a session token to use for the current user for the given application (or null/empty for an unscoped token).
*
* @param appId Id of the application.
* @param name Metadata info to identify the token.
* @param force Enables skipping cache and issue a brand new token.
* @param scoped
* @param webContext WebContext to use when getting auth token. If not specified, default page context is used.
* @return Session token.
*/
export function getToken(appId?: string, name?: string, force?: boolean, scoped?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<Authentication_Contracts_Async.WebSessionToken>;
/**
* Fetch an app token to use for the current user for the given application.  This can be used to authenticate
* with an external application.
*
* @param appId Id of the application.
* @param name Metadata info to identify the token.
* @param force Enables skipping cache and issue a brand new token.
* @param webContext WebContext to use when getting auth token. If not specified, default page context is used.
* @return Session token.
*/
export function getAppToken(appId: string, name?: string, force?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<Authentication_Contracts_Async.WebSessionToken>;
/**
 * Fetch a session token to use for the current user for the given extension
 *
 * @param publisherName Id of the publisher.
 * @param extensionName Id of the extension.
 * @param force Enables skipping cache and issue a brand new token.
 * @return Session token.
 */
export function getExtensionToken(publisherName: string, extensionName: string, force?: boolean, webContext?: Contracts_Platform.WebContext): IPromise<Authentication_Contracts_Async.WebSessionToken>;
/**
* Get an auth token manager - either the default manager or the manager for a registered/named token
*
* @param namedToken Id Optional value to use when getting a named web session token.
*/
export function getAuthTokenManager(namedTokenId?: string): IAuthTokenManager<any>;
}
declare module "VSS/Bundling" {
import Context = require("VSS/Context");
import Q = require("q");
import VSS = require("VSS/VSS");
export module DiagnoseUtils {
    function isDiagnosing(): boolean;
    function markUrlForDiagnose(url: string): string;
}
/**
 * Gets the content length (in bytes) of all Javascript bundles included on the page
 */
export function getBundledScriptContentSize(): number;
/**
 * Gets the content length (in bytes) of all CSS bundles included on the page
 */
export function getBundledCssContentSize(): number;
/**
 * Get the size (in bytes) of a bundle given its url
 *
 * @param bundleUrl Url of the script or CSS bundle
 */
export function getBundleSize(bundleUrl: string): number;
/**
 * Compresses the specified paths by replacing recurring directory names with '*' character.
 *
 * @param paths List of files to compress.
 * @returns {string[]}
 */
export function compressPaths(paths: string[]): string[];
export interface IDynamicBundleRequestLocation {
    url?: string;
    contributedServicePath?: Context.ContributedServicePathBuilder;
}
export function getDynamicBundleRequestLocation(scripts: string[], serviceInstanceId: string, excludeOptions: VSS.DynamicModuleExcludeOptions): IDynamicBundleRequestLocation;
/**
 * Inject all the CSS and Scripts specified in the bundle collection into the page
 *
 * @param bundles Collection of CSS and script bundles
 * @param rootBundleUrl Optional root url to prefix to all bundle paths.
 */
export function injectBundles(bundles: DynamicBundlesCollection, contributedServiceUri?: Context.ContributedServicePathBuilder): IPromise<any>;
/**
* Issue a require statement for the specified modules and invoke the given callback method once available.
* This is a wrapper around the requireJS 'require' statement which ensures that the missing modules are
* pulled in via the minimum number of resource requests.
*
* @param moduleNames An array of AMD modules to asynchronously require
* @param callback Method to invoke once the modules have been resolved.
*/
export function requireModules(moduleNames: string[], options?: VSS.IModuleLoadOptions): Q.Promise<any>;
/**
* Issue a require statement for the specified modules and invoke the given callback method once available.
* This is a wrapper around the requireJS 'require' statement which ensures that the missing modules are
* pulled in via the minimum number of resource requests.
*
* @param moduleNames An array of AMD modules to asynchronously require
* @param callback Method to invoke once the modules have been resolved.
*/
export function loadModules(moduleNames: string[], options?: VSS.IModuleLoadOptions): Q.Promise<void>;
}
declare module "VSS/ClientTrace/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export interface ClientTraceEvent {
    area: string;
    component: string;
    exceptionType: string;
    feature: string;
    level: Level;
    message: string;
    method: string;
    properties: {
        [key: string]: any;
    };
}
export enum Level {
    Off = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
    Verbose = 4
}
export var TypeInfo: {
    ClientTraceEvent: any;
    Level: {
        enumValues: {
            "off": number;
            "error": number;
            "warning": number;
            "info": number;
            "verbose": number;
        };
    };
};
}
declare module "VSS/ClientTrace/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/ClientTrace/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4_1To5 extends VSS_WebApi.VssHttpClient {
    protected eventsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ClientTraceEvent[]} events
     * @return IPromise<void>
     */
    publishEvents(events: Contracts.ClientTraceEvent[]): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class ClientTraceHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ClientTraceHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class ClientTraceHttpClient extends ClientTraceHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return ClientTraceHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): ClientTraceHttpClient4_1;
}
declare module "VSS/ClientTrace/Services" {
import { ClientTraceEvent } from "VSS/ClientTrace/Contracts";
/**
 * Trace the given event to the CI client trace channel
 * (events are queued and sent in delayed batches)
 *
 * @param eventData {ClientTraceEvent} event to publish
 */
export function trace(event: ClientTraceEvent): void;
/**
 * Flush queued event data to be sent to client trace
 */
export function flush(): IPromise<void>;
}
declare module "VSS/Commerce/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   sps\clients\genclient.json
 */
/**
 * The subscription account namespace. Denotes the 'category' of the account.
 */
export enum AccountProviderNamespace {
    VisualStudioOnline = 0,
    AppInsights = 1,
    Marketplace = 2,
    OnPremise = 3
}
/**
 * Encapsulates azure specific plan structure, using a publisher defined publisher name, offer name, and plan name These are all specified by the publisher and can vary from other meta data we store about the extension internally therefore need to be tracked seperately for purposes of interacting with Azure
 */
export interface AzureOfferPlanDefinition {
    /**
     * Determines whether or not this plan is visible to all users
     */
    isPublic: boolean;
    /**
     * The meter id which identifies the offer meter this plan is associated with
     */
    meterId: number;
    /**
     * The offer / product name as defined by the publisher in Azure
     */
    offerId: string;
    /**
     * The offer / product name as defined by the publisher in Azure
     */
    offerName: string;
    /**
     * The id of the plan, which is usually in the format "{publisher}:{offer}:{plan}"
     */
    planId: string;
    /**
     * The plan name as defined by the publisher in Azure
     */
    planName: string;
    /**
     * The version string which optionally identifies the version of the plan
     */
    planVersion: string;
    /**
     * The publisher of the plan as defined by the publisher in Azure
     */
    publisher: string;
    /**
     * get/set publisher name
     */
    publisherName: string;
    /**
     * The number of users associated with the plan as defined in Azure
     */
    quantity: number;
}
/**
 * These are known offer types to VSTS.
 */
export enum AzureOfferType {
    None = 0,
    Standard = 1,
    Ea = 2,
    Msdn = 3,
    Csp = 4,
    Unsupported = 99
}
/**
 * Represents an azure region, used by ibiza for linking accounts
 */
export interface AzureRegion {
    /**
     * Display Name of the azure region. Ex: North Central US.
     */
    displayName: string;
    /**
     * Unique Identifier
     */
    id: string;
    /**
     * Region code of the azure region. Ex: NCUS.
     */
    regionCode: string;
}
/**
 * The responsible entity/method for billing.
 */
export enum BillingProvider {
    SelfManaged = 0,
    AzureStoreManaged = 1
}
export interface ConnectedServer {
    /**
     * Hosted AccountId associated with the connected server NOTE: As of S112, this is now the CollectionId. Not changed as this is exposed to client code.
     */
    accountId: string;
    /**
     * Hosted AccountName associated with the connected server NOTE: As of S112, this is now the collection name. Not changed as this is exposed to client code.
     */
    accountName: string;
    /**
     * Object used to create credentials to call from OnPrem to hosted service.
     */
    authorization: ConnectedServerAuthorization;
    /**
     * OnPrem server id associated with the connected server
     */
    serverId: string;
    /**
     * OnPrem server associated with the connected server
     */
    serverName: string;
    /**
     * SpsUrl of the hosted account that the onrepm server has been connected to.
     */
    spsUrl: string;
    /**
     * The id of the subscription used for purchase
     */
    subscriptionId: string;
    /**
     * OnPrem target host associated with the connected server.  Typically the collection host id
     */
    targetId: string;
    /**
     * OnPrem target associated with the connected server.
     */
    targetName: string;
}
/**
 * Provides data necessary for authorizing the connecter server using OAuth 2.0 authentication flows.
 */
export interface ConnectedServerAuthorization {
    /**
     * Gets or sets the endpoint used to obtain access tokens from the configured token service.
     */
    authorizationUrl: string;
    /**
     * Gets or sets the client identifier for this agent.
     */
    clientId: string;
    /**
     * Gets or sets the public key used to verify the identity of this connected server.
     */
    publicKey: string;
}
export interface IAzureSubscription {
    anniversaryDay: number;
    created: Date;
    id: string;
    lastUpdated: Date;
    namespace: AccountProviderNamespace;
    offerType: AzureOfferType;
    source: SubscriptionSource;
    status: SubscriptionStatus;
}
export interface ICommerceEvent {
    /**
     * Billed quantity (prorated) passed to Azure commerce
     */
    billedQuantity: number;
    collectionId: string;
    collectionName: string;
    /**
     * Quantity for current billing cycle
     */
    committedQuantity: number;
    /**
     * Quantity for next billing cycle
     */
    currentQuantity: number;
    effectiveDate: Date;
    /**
     * Onpremise or hosted
     */
    environment: string;
    eventId: string;
    eventName: string;
    eventSource: string;
    eventTime: Date;
    galleryId: string;
    includedQuantity: number;
    maxQuantity: number;
    meterName: string;
    organizationId: string;
    organizationName: string;
    previousIncludedQuantity: number;
    previousMaxQuantity: number;
    /**
     * Previous quantity in case of upgrade/downgrade
     */
    previousQuantity: number;
    renewalGroup: string;
    serviceIdentity: string;
    subscriptionId: string;
    trialEndDate: Date;
    trialStartDate: Date;
    userIdentity: string;
    version: string;
}
/**
 * Encapsulates the state of offer meter definitions and purchases
 */
export interface ICommercePackage {
    configuration: {
        [key: string]: string;
    };
    offerMeters: OfferMeter[];
    offerSubscriptions: OfferSubscription[];
}
/**
 * Information about a resource associated with a subscription.
 */
export interface IOfferSubscription {
    /**
     * Indicates whether users get auto assigned this license type duing first access.
     */
    autoAssignOnAccess: boolean;
    /**
     * The azure subscription id
     */
    azureSubscriptionId: string;
    /**
     * The azure subscription name
     */
    azureSubscriptionName: string;
    /**
     * The azure subscription state
     */
    azureSubscriptionState: SubscriptionStatus;
    /**
     * Quantity commited by the user, when resources is commitment based.
     */
    committedQuantity: number;
    /**
     * A enumeration value indicating why the resource was disabled.
     */
    disabledReason: ResourceStatusReason;
    /**
     * Uri pointing to user action on a disabled resource. It is based on DisabledReason value.
     */
    disabledResourceActionLink: string;
    /**
     * Quantity included for free.
     */
    includedQuantity: number;
    /**
     * Returns true if paid billing is enabled on the resource. Returns false for non-azure subscriptions, disabled azure subscriptions or explicitly disabled by user
     */
    isPaidBillingEnabled: boolean;
    /**
     * Gets or sets a value indicating whether this instance is in preview.
     */
    isPreview: boolean;
    /**
     * Gets the value indicating whether the puchase is canceled.
     */
    isPurchaseCanceled: boolean;
    /**
     * Gets the value indicating whether current meter was purchased while the meter is still in trial
     */
    isPurchasedDuringTrial: boolean;
    /**
     * Gets or sets a value indicating whether this instance is trial or preview.
     */
    isTrialOrPreview: boolean;
    /**
     * Returns true if resource is can be used otherwise returns false. DisabledReason can be used to identify why resource is disabled.
     */
    isUseable: boolean;
    /**
     * Returns an integer representing the maximum quantity that can be billed for this resource. Any usage submitted over this number is automatically excluded from being sent to azure.
     */
    maximumQuantity: number;
    /**
     * Gets the name of this resource.
     */
    offerMeter: OfferMeter;
    /**
     * Gets the renewal group.
     */
    renewalGroup: ResourceRenewalGroup;
    /**
     * Returns a Date of UTC kind indicating when the next reset of quantities is going to happen. On this day at UTC 2:00 AM is when the reset will occur.
     */
    resetDate: Date;
    /**
     * Gets or sets the start date for this resource. First install date in any state.
     */
    startDate: Date;
    /**
     * Gets or sets the trial expiry date.
     */
    trialExpiryDate: Date;
}
/**
 * The subscription account. Add Sub Type and Owner email later.
 */
export interface ISubscriptionAccount {
    /**
     * Gets or sets the account host type.
     */
    accountHostType: number;
    /**
     * Gets or sets the account identifier. Usually a guid.
     */
    accountId: string;
    /**
     * Gets or sets the name of the account.
     */
    accountName: string;
    /**
     * Gets or sets the account tenantId.
     */
    accountTenantId: string;
    /**
     * get or set purchase Error Reason
     */
    failedPurchaseReason: PurchaseErrorReason;
    /**
     * Gets or sets the geo location.
     */
    geoLocation: string;
    /**
     * Gets or sets a value indicating whether the calling user identity owns or is a PCA of the account.
     */
    isAccountOwner: boolean;
    /**
     * Gets or set the flag to enable purchase via subscription.
     */
    isEligibleForPurchase: boolean;
    /**
     * get or set IsPrepaidFundSubscription
     */
    isPrepaidFundSubscription: boolean;
    /**
     * get or set IsPricingPricingAvailable
     */
    isPricingAvailable: boolean;
    /**
     * Gets or sets the subscription locale
     */
    locale: string;
    /**
     * Gets or sets the Offer Type of this subscription. A value of null means, this value has not been evaluated.
     */
    offerType: AzureOfferType;
    /**
     * Gets or sets the subscription address country display name
     */
    regionDisplayName: string;
    /**
     * Gets or sets the resource group.
     */
    resourceGroupName: string;
    /**
     * Gets or sets the azure resource name.
     */
    resourceName: string;
    /**
     * A dictionary of service urls, mapping the service owner to the service owner url
     */
    serviceUrls: {
        [key: string]: string;
    };
    /**
     * Gets or sets the subscription identifier.
     */
    subscriptionId: string;
    /**
     * Gets or sets the azure subscription name
     */
    subscriptionName: string;
    /**
     * get or set object id of subscruption admin
     */
    subscriptionObjectId: string;
    /**
     * get or set subscription offer code
     */
    subscriptionOfferCode: string;
    /**
     * Gets or sets the subscription status.
     */
    subscriptionStatus: SubscriptionStatus;
    /**
     * get or set tenant id of subscription
     */
    subscriptionTenantId: string;
}
/**
 * Information about a resource associated with a subscription.
 */
export interface ISubscriptionResource {
    /**
     * Quantity commited by the user, when resources is commitment based.
     */
    committedQuantity: number;
    /**
     * A enumeration value indicating why the resource was disabled.
     */
    disabledReason: ResourceStatusReason;
    /**
     * Uri pointing to user action on a disabled resource. It is based on DisabledReason value.
     */
    disabledResourceActionLink: string;
    /**
     * Quantity included for free.
     */
    includedQuantity: number;
    /**
     * Returns true if paid billing is enabled on the resource. Returns false for non-azure subscriptions, disabled azure subscriptions or explicitly disabled by user
     */
    isPaidBillingEnabled: boolean;
    /**
     * Returns true if resource is can be used otherwise returns false. DisabledReason can be used to identify why resource is disabled.
     */
    isUseable: boolean;
    /**
     * Returns an integer representing the maximum quantity that can be billed for this resource. Any usage submitted over this number is automatically excluded from being sent to azure.
     */
    maximumQuantity: number;
    /**
     * Gets the name of this resource.
     */
    name: ResourceName;
    /**
     * Returns a Date of UTC kind indicating when the next reset of quantities is going to happen. On this day at UTC 2:00 AM is when the reset will occur.
     */
    resetDate: Date;
}
/**
 * Represents the aggregated usage of a resource over a time span
 */
export interface IUsageEventAggregate {
    /**
     * Gets or sets end time of the aggregated value, exclusive
     */
    endTime: Date;
    /**
     * Gets or sets resource that the aggregated value represents
     */
    resource: ResourceName;
    /**
     * Gets or sets start time of the aggregated value, inclusive
     */
    startTime: Date;
    /**
     * Gets or sets quantity of the resource used from start time to end time
     */
    value: number;
}
/**
 * The meter billing state.
 */
export enum MeterBillingState {
    Free = 0,
    Paid = 1
}
/**
 * Defines meter categories.
 */
export enum MeterCategory {
    Legacy = 0,
    Bundle = 1,
    Extension = 2
}
/**
 * Describes the Renewal frequncy of a Meter.
 */
export enum MeterRenewalFrequecy {
    None = 0,
    Monthly = 1,
    Annually = 2
}
/**
 * The meter state.
 */
export enum MeterState {
    Registered = 0,
    Active = 1,
    Retired = 2,
    Deleted = 3
}
export enum MinimumRequiredServiceLevel {
    /**
     * No service rights. The user cannot access the account
     */
    None = 0,
    /**
     * Default or minimum service level
     */
    Express = 1,
    /**
     * Premium service level - either by purchasing on the Azure portal or by purchasing the appropriate MSDN subscription
     */
    Advanced = 2,
    /**
     * Only available to a specific set of MSDN Subscribers
     */
    AdvancedPlus = 3,
    /**
     * Stakeholder service level
     */
    Stakeholder = 4
}
export interface OfferMeter {
    /**
     * Gets or sets the value of absolute maximum quantity for the resource
     */
    absoluteMaximumQuantity: number;
    /**
     * Gets or sets the user assignment model.
     */
    assignmentModel: OfferMeterAssignmentModel;
    /**
     * Indicates whether users get auto assigned this license type duing first access.
     */
    autoAssignOnAccess: boolean;
    /**
     * Gets or sets the responsible entity/method for billing. Determines how this meter is handled in the backend.
     */
    billingEntity: BillingProvider;
    /**
     * Gets or sets the billing mode of the resource
     */
    billingMode: ResourceBillingMode;
    /**
     * Gets or sets the billing start date. If TrialDays + PreviewGraceDays > then, on 'BillingStartDate' it starts the preview Grace and/or trial period.
     */
    billingStartDate: Date;
    /**
     * Gets or sets the state of the billing.
     */
    billingState: MeterBillingState;
    /**
     * Category.
     */
    category: MeterCategory;
    /**
     * Quantity commited by the user, when resources is commitment based.
     */
    committedQuantity: number;
    /**
     * Quantity used by the user, when resources is pay as you go or commitment based.
     */
    currentQuantity: number;
    /**
     * Gets or sets the map of named quantity varied plans, plans can be purchased that vary only in the number of users included. Null if this offer meter does not support named fixed quantity plans.
     */
    fixedQuantityPlans: AzureOfferPlanDefinition[];
    /**
     * Gets or sets Gallery Id.
     */
    galleryId: string;
    /**
     * Gets or sets the Min license level the offer is free for.
     */
    includedInLicenseLevel: MinimumRequiredServiceLevel;
    /**
     * Quantity included for free.
     */
    includedQuantity: number;
    /**
     * Flag to identify whether the meter is First Party or Third Party based on BillingEntity If the BillingEntity is SelfManaged, the Meter is First Party otherwise its a Third Party Meter
     */
    isFirstParty: boolean;
    /**
     * Gets or sets the value of maximum quantity for the resource
     */
    maximumQuantity: number;
    /**
     * Meter Id.
     */
    meterId: number;
    /**
     * Gets or sets the minimum required access level for the meter.
     */
    minimumRequiredAccessLevel: MinimumRequiredServiceLevel;
    /**
     * Name of the resource
     */
    name: string;
    /**
     * Gets or sets the offer scope.
     */
    offerScope: OfferScope;
    /**
     * Gets or sets the identifier representing this meter in commerce platform
     */
    platformMeterId: string;
    /**
     * Gets or sets the preview grace days.
     */
    previewGraceDays: number;
    /**
     * Gets or sets the Renewak Frequency.
     */
    renewalFrequency: MeterRenewalFrequecy;
    /**
     * Gets or sets the status.
     */
    status: MeterState;
    /**
     * Gets or sets the trial cycles.
     */
    trialCycles: number;
    /**
     * Gets or sets the trial days.
     */
    trialDays: number;
    /**
     * Measuring unit for this meter.
     */
    unit: string;
}
/**
 * The offer meter assignment model.
 */
export enum OfferMeterAssignmentModel {
    /**
     * Users need to be explicitly assigned.
     */
    Explicit = 0,
    /**
     * Users will be added automatically. All-or-nothing model.
     */
    Implicit = 1
}
export interface OfferMeterPrice {
    /**
     * Currency code
     */
    currencyCode: string;
    /**
     * The meter Name which identifies the offer meter this plan is associated with
     */
    meterName: string;
    /**
     * The Name of the plan, which is usually in the format "{publisher}:{offer}:{plan}"
     */
    planName: string;
    /**
     * Plan Price
     */
    price: number;
    /**
     * Plan Quantity
     */
    quantity: number;
    /**
     * Region price is for
     */
    region: string;
}
/**
 * The offer scope.
 */
export enum OfferScope {
    Account = 0,
    User = 1,
    UserAccount = 2
}
/**
 * Information about a resource associated with a subscription.
 */
export interface OfferSubscription {
    /**
     * Indicates whether users get auto assigned this license type duing first access.
     */
    autoAssignOnAccess: boolean;
    /**
     * The azure subscription id
     */
    azureSubscriptionId: string;
    /**
     * The azure subscription name
     */
    azureSubscriptionName: string;
    /**
     * The azure subscription state
     */
    azureSubscriptionState: SubscriptionStatus;
    /**
     * Quantity commited by the user, when resources is commitment based.
     */
    committedQuantity: number;
    /**
     * A enumeration value indicating why the resource was disabled.
     */
    disabledReason: ResourceStatusReason;
    /**
     * Uri pointing to user action on a disabled resource. It is based on DisabledReason value.
     */
    disabledResourceActionLink: string;
    /**
     * Quantity included for free.
     */
    includedQuantity: number;
    /**
     * Returns true if paid billing is enabled on the resource. Returns false for non-azure subscriptions, disabled azure subscriptions or explicitly disabled by user
     */
    isPaidBillingEnabled: boolean;
    /**
     * Gets or sets a value indicating whether this instance is in preview.
     */
    isPreview: boolean;
    /**
     * Gets the value indicating whether the puchase is canceled.
     */
    isPurchaseCanceled: boolean;
    /**
     * Gets the value indicating whether current meter was purchased while the meter is still in trial
     */
    isPurchasedDuringTrial: boolean;
    /**
     * Gets or sets a value indicating whether this instance is trial or preview.
     */
    isTrialOrPreview: boolean;
    /**
     * Returns true if resource is can be used otherwise returns false. DisabledReason can be used to identify why resource is disabled.
     */
    isUseable: boolean;
    /**
     * Returns an integer representing the maximum quantity that can be billed for this resource. Any usage submitted over this number is automatically excluded from being sent to azure.
     */
    maximumQuantity: number;
    /**
     * Gets or sets the name of this resource.
     */
    offerMeter: OfferMeter;
    /**
     * The unique identifier of this offer subscription
     */
    offerSubscriptionId: string;
    /**
     * Gets the renewal group.
     */
    renewalGroup: ResourceRenewalGroup;
    /**
     * Returns a Date of UTC kind indicating when the next reset of quantities is going to happen. On this day at UTC 2:00 AM is when the reset will occur.
     */
    resetDate: Date;
    /**
     * Gets or sets the start date for this resource. First install date in any state.
     */
    startDate: Date;
    /**
     * Gets or sets the trial expiry date.
     */
    trialExpiryDate: Date;
}
/**
 * The Purchasable offer meter.
 */
export interface PurchasableOfferMeter {
    /**
     * Currecny code for meter pricing
     */
    currencyCode: string;
    /**
     * Gets or sets the estimated renewal date.
     */
    estimatedRenewalDate: Date;
    /**
     * Locale for azure subscription
     */
    localeCode: string;
    /**
     * Gets or sets the meter pricing (GraduatedPrice)
     */
    meterPricing: {
        key: number;
        value: number;
    }[];
    /**
     * Gets or sets the offer meter definition.
     */
    offerMeterDefinition: OfferMeter;
}
export enum PurchaseErrorReason {
    None = 0,
    MonetaryLimitSet = 1,
    InvalidOfferCode = 2,
    NotAdminOrCoAdmin = 3,
    InvalidRegionPurchase = 4,
    PaymentInstrumentNotCreditCard = 5,
    InvalidOfferRegion = 6,
    UnsupportedSubscription = 7,
    DisabledSubscription = 8,
    InvalidUser = 9,
    NotSubscriptionUser = 10,
    UnsupportedSubscriptionCsp = 11,
    TemporarySpendingLimit = 12,
    AzureServiceError = 13
}
/**
 * Represents a purchase request for requesting purchase by a user who does not have authorization to purchase.
 */
export interface PurchaseRequest {
    /**
     * Name of the offer meter
     */
    offerMeterName: string;
    /**
     * Quantity for purchase
     */
    quantity: number;
    /**
     * Reason for the purchase request
     */
    reason: string;
    /**
     * Response for this purchase request by the approver
     */
    response: PurchaseRequestResponse;
}
/**
 * Type of purchase request response
 */
export enum PurchaseRequestResponse {
    None = 0,
    Approved = 1,
    Denied = 2
}
/**
 * The resource billing mode.
 */
export enum ResourceBillingMode {
    Committment = 0,
    PayAsYouGo = 1
}
/**
 * Various metered resources in VSTS
 */
export enum ResourceName {
    StandardLicense = 0,
    AdvancedLicense = 1,
    ProfessionalLicense = 2,
    Build = 3,
    LoadTest = 4,
    PremiumBuildAgent = 5,
    PrivateOtherBuildAgent = 6,
    PrivateAzureBuildAgent = 7
}
/**
 * The resource renewal group.
 */
export enum ResourceRenewalGroup {
    Monthly = 0,
    Jan = 1,
    Feb = 2,
    Mar = 3,
    Apr = 4,
    May = 5,
    Jun = 6,
    Jul = 7,
    Aug = 8,
    Sep = 9,
    Oct = 10,
    Nov = 11,
    Dec = 12
}
/**
 * Reason for disabled resource.
 */
export enum ResourceStatusReason {
    None = 0,
    NoAzureSubscription = 1,
    NoIncludedQuantityLeft = 2,
    SubscriptionDisabled = 4,
    PaidBillingDisabled = 8,
    MaximumQuantityReached = 16
}
/**
 * The subscription account. Add Sub Type and Owner email later.
 */
export interface SubscriptionAccount {
    /**
     * Gets or sets the account host type.
     */
    accountHostType: number;
    /**
     * Gets or sets the account identifier. Usually a guid.
     */
    accountId: string;
    /**
     * Gets or sets the name of the account.
     */
    accountName: string;
    /**
     * Gets or sets the account tenantId.
     */
    accountTenantId: string;
    /**
     * Purchase Error Reason
     */
    failedPurchaseReason: PurchaseErrorReason;
    /**
     * Gets or sets the geo location.
     */
    geoLocation: string;
    /**
     * Gets or sets a value indicating whether the calling user identity owns or is a PCA of the account.
     */
    isAccountOwner: boolean;
    /**
     * Gets or set the flag to enable purchase via subscription.
     */
    isEligibleForPurchase: boolean;
    /**
     * get or set IsPrepaidFundSubscription
     */
    isPrepaidFundSubscription: boolean;
    /**
     * get or set IsPricingPricingAvailable
     */
    isPricingAvailable: boolean;
    /**
     * Gets or sets the subscription address country code
     */
    locale: string;
    /**
     * Gets or sets the Offer Type of this subscription.
     */
    offerType: AzureOfferType;
    /**
     * Gets or sets the subscription address country display name
     */
    regionDisplayName: string;
    /**
     * Gets or sets the resource group.
     */
    resourceGroupName: string;
    /**
     * Gets or sets the azure resource name.
     */
    resourceName: string;
    /**
     * A dictionary of service urls, mapping the service owner to the service owner url
     */
    serviceUrls: {
        [key: string]: string;
    };
    /**
     * Gets or sets the subscription identifier.
     */
    subscriptionId: string;
    /**
     * Gets or sets the azure subscription name
     */
    subscriptionName: string;
    /**
     * object id of subscription admin
     */
    subscriptionObjectId: string;
    /**
     * get or set subscription offer code
     */
    subscriptionOfferCode: string;
    /**
     * Gets or sets the subscription status.
     */
    subscriptionStatus: SubscriptionStatus;
    /**
     * tenant id of subscription
     */
    subscriptionTenantId: string;
}
/**
 * Information about a resource associated with a subscription.
 */
export interface SubscriptionResource {
    /**
     * Quantity commited by the user, when resources is commitment based.
     */
    committedQuantity: number;
    /**
     * A enumeration value indicating why the resource was disabled.
     */
    disabledReason: ResourceStatusReason;
    /**
     * Uri pointing to user action on a disabled resource. It is based on DisabledReason value.
     */
    disabledResourceActionLink: string;
    /**
     * Quantity included for free.
     */
    includedQuantity: number;
    /**
     * Returns true if paid billing is enabled on the resource. Returns false for non-azure subscriptions, disabled azure subscriptions or explicitly disabled by user
     */
    isPaidBillingEnabled: boolean;
    /**
     * Returns true if resource is can be used otherwise returns false. DisabledReason can be used to identify why resource is disabled.
     */
    isUseable: boolean;
    /**
     * Returns an integer representing the maximum quantity that can be billed for this resource. Any usage submitted over this number is automatically excluded from being sent to azure.
     */
    maximumQuantity: number;
    /**
     * Gets or sets the name of this resource.
     */
    name: ResourceName;
    /**
     * Returns a Date of UTC kind indicating when the next reset of quantities is going to happen. On this day at UTC 2:00 AM is when the reset will occur.
     */
    resetDate: Date;
}
export enum SubscriptionSource {
    Normal = 0,
    EnterpriseAgreement = 1,
    Internal = 2,
    Unknown = 3,
    FreeTier = 4
}
/**
 * Azure subscription status
 */
export enum SubscriptionStatus {
    Unknown = 0,
    Active = 1,
    Disabled = 2,
    Deleted = 3,
    Unregistered = 4
}
/**
 * Class that represents common set of properties for a raw usage event reported by TFS services.
 */
export interface UsageEvent {
    /**
     * Gets or sets account id of the event. Note: This is for backward compat with BI.
     */
    accountId: string;
    /**
     * Account name associated with the usage event
     */
    accountName: string;
    /**
     * User GUID associated with the usage event
     */
    associatedUser: string;
    /**
     * Timestamp when this billing event is billable
     */
    billableDate: Date;
    /**
     * Unique event identifier
     */
    eventId: string;
    /**
     * Recieving Timestamp of the billing event by metering service
     */
    eventTimestamp: Date;
    /**
     * Gets or sets the event unique identifier.
     */
    eventUniqueId: string;
    /**
     * Meter Id.
     */
    meterName: string;
    /**
     * Partition id of the account
     */
    partitionId: number;
    /**
     * Quantity of the usage event
     */
    quantity: number;
    /**
     * Gets or sets the billing mode for the resource involved in the usage
     */
    resourceBillingMode: ResourceBillingMode;
    /**
     * Service context GUID associated with the usage event
     */
    serviceIdentity: string;
    /**
     * Gets or sets subscription anniversary day of the subscription
     */
    subscriptionAnniversaryDay: number;
    /**
     * Gets or sets subscription guid of the associated account of the event
     */
    subscriptionId: string;
}
export var TypeInfo: {
    AccountProviderNamespace: {
        enumValues: {
            "visualStudioOnline": number;
            "appInsights": number;
            "marketplace": number;
            "onPremise": number;
        };
    };
    AzureOfferType: {
        enumValues: {
            "none": number;
            "standard": number;
            "ea": number;
            "msdn": number;
            "csp": number;
            "unsupported": number;
        };
    };
    BillingProvider: {
        enumValues: {
            "selfManaged": number;
            "azureStoreManaged": number;
        };
    };
    IAzureSubscription: any;
    ICommerceEvent: any;
    ICommercePackage: any;
    IOfferSubscription: any;
    ISubscriptionAccount: any;
    ISubscriptionResource: any;
    IUsageEventAggregate: any;
    MeterBillingState: {
        enumValues: {
            "free": number;
            "paid": number;
        };
    };
    MeterCategory: {
        enumValues: {
            "legacy": number;
            "bundle": number;
            "extension": number;
        };
    };
    MeterRenewalFrequecy: {
        enumValues: {
            "none": number;
            "monthly": number;
            "annually": number;
        };
    };
    MeterState: {
        enumValues: {
            "registered": number;
            "active": number;
            "retired": number;
            "deleted": number;
        };
    };
    MinimumRequiredServiceLevel: {
        enumValues: {
            "none": number;
            "express": number;
            "advanced": number;
            "advancedPlus": number;
            "stakeholder": number;
        };
    };
    OfferMeter: any;
    OfferMeterAssignmentModel: {
        enumValues: {
            "explicit": number;
            "implicit": number;
        };
    };
    OfferScope: {
        enumValues: {
            "account": number;
            "user": number;
            "userAccount": number;
        };
    };
    OfferSubscription: any;
    PurchasableOfferMeter: any;
    PurchaseErrorReason: {
        enumValues: {
            "none": number;
            "monetaryLimitSet": number;
            "invalidOfferCode": number;
            "notAdminOrCoAdmin": number;
            "invalidRegionPurchase": number;
            "paymentInstrumentNotCreditCard": number;
            "invalidOfferRegion": number;
            "unsupportedSubscription": number;
            "disabledSubscription": number;
            "invalidUser": number;
            "notSubscriptionUser": number;
            "unsupportedSubscriptionCsp": number;
            "temporarySpendingLimit": number;
            "azureServiceError": number;
        };
    };
    PurchaseRequest: any;
    PurchaseRequestResponse: {
        enumValues: {
            "none": number;
            "approved": number;
            "denied": number;
        };
    };
    ResourceBillingMode: {
        enumValues: {
            "committment": number;
            "payAsYouGo": number;
        };
    };
    ResourceName: {
        enumValues: {
            "standardLicense": number;
            "advancedLicense": number;
            "professionalLicense": number;
            "build": number;
            "loadTest": number;
            "premiumBuildAgent": number;
            "privateOtherBuildAgent": number;
            "privateAzureBuildAgent": number;
        };
    };
    ResourceRenewalGroup: {
        enumValues: {
            "monthly": number;
            "jan": number;
            "feb": number;
            "mar": number;
            "apr": number;
            "may": number;
            "jun": number;
            "jul": number;
            "aug": number;
            "sep": number;
            "oct": number;
            "nov": number;
            "dec": number;
        };
    };
    ResourceStatusReason: {
        enumValues: {
            "none": number;
            "noAzureSubscription": number;
            "noIncludedQuantityLeft": number;
            "subscriptionDisabled": number;
            "paidBillingDisabled": number;
            "maximumQuantityReached": number;
        };
    };
    SubscriptionAccount: any;
    SubscriptionResource: any;
    SubscriptionSource: {
        enumValues: {
            "normal": number;
            "enterpriseAgreement": number;
            "internal": number;
            "unknown": number;
            "freeTier": number;
        };
    };
    SubscriptionStatus: {
        enumValues: {
            "unknown": number;
            "active": number;
            "disabled": number;
            "deleted": number;
            "unregistered": number;
        };
    };
    UsageEvent: any;
};
}
declare module "VSS/Commerce/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   sps\clients\genclient.json
 */
import Contracts = require("VSS/Commerce/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected metersApiVersion: string;
    protected offerMeterApiVersion: string;
    protected offerMeterPriceApiVersion: string;
    protected offerSubscriptionApiVersion: string;
    protected regionsApiVersion: string;
    protected subscriptionApiVersion: string;
    protected usageEventsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.UsageEvent} usageEvent
     * @return IPromise<void>
     */
    reportUsage(usageEvent: Contracts.UsageEvent): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Date} startTime
     * @param {Date} endTime
     * @param {any} timeSpan
     * @return IPromise<Contracts.IUsageEventAggregate[]>
     */
    getUsage(startTime: Date, endTime: Date, timeSpan: any): IPromise<Contracts.IUsageEventAggregate[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @param {string} ownerId
     * @return IPromise<void>
     */
    unlinkAccount(subscriptionId: string, providerNamespaceId: Contracts.AccountProviderNamespace, accountId: string, ownerId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @param {string} ownerId
     * @param {boolean} hydrate
     * @return IPromise<void>
     */
    linkAccount(subscriptionId: string, providerNamespaceId: Contracts.AccountProviderNamespace, accountId: string, ownerId: string, hydrate?: boolean): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @return IPromise<Contracts.ISubscriptionAccount>
     */
    getSubscriptionAccount(providerNamespaceId: Contracts.AccountProviderNamespace, accountId: string): IPromise<Contracts.ISubscriptionAccount>;
    /**
     * [Preview API]
     *
     * @param {string[]} ids
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @return IPromise<Contracts.IAzureSubscription[]>
     */
    getAzureSubscriptions(ids: string[], providerNamespaceId: Contracts.AccountProviderNamespace): IPromise<Contracts.IAzureSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {boolean} queryAcrossTenants
     * @return IPromise<Contracts.ISubscriptionAccount[]>
     */
    getAzureSubscriptionForUser(subscriptionId?: string, queryAcrossTenants?: boolean): IPromise<Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {string} galleryItemId
     * @param {string} accountId
     * @return IPromise<Contracts.ISubscriptionAccount>
     */
    getAzureSubscriptionForPurchase(subscriptionId: string, galleryItemId: string, accountId?: string): IPromise<Contracts.ISubscriptionAccount>;
    /**
     * [Preview API]
     *
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} memberId
     * @param {boolean} queryOnlyOwnerAccounts
     * @param {boolean} inlcudeDisabledAccounts
     * @param {boolean} includeMSAAccounts
     * @param {string[]} serviceOwners
     * @param {string} galleryId
     * @param {boolean} addUnlinkedSubscription
     * @param {boolean} queryAccountsByUpn
     * @return IPromise<Contracts.ISubscriptionAccount[]>
     */
    getAccountsByIdentityForOfferId(providerNamespaceId: Contracts.AccountProviderNamespace, memberId: string, queryOnlyOwnerAccounts: boolean, inlcudeDisabledAccounts: boolean, includeMSAAccounts: boolean, serviceOwners: string[], galleryId: string, addUnlinkedSubscription?: boolean, queryAccountsByUpn?: boolean): IPromise<Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} memberId
     * @param {boolean} queryOnlyOwnerAccounts
     * @param {boolean} inlcudeDisabledAccounts
     * @param {boolean} includeMSAAccounts
     * @param {string[]} serviceOwners
     * @return IPromise<Contracts.ISubscriptionAccount[]>
     */
    getAccountsByIdentity(providerNamespaceId: Contracts.AccountProviderNamespace, memberId: string, queryOnlyOwnerAccounts: boolean, inlcudeDisabledAccounts: boolean, includeMSAAccounts: boolean, serviceOwners: string[]): IPromise<Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @return IPromise<Contracts.SubscriptionAccount[]>
     */
    getAccounts(subscriptionId: string, providerNamespaceId: Contracts.AccountProviderNamespace): IPromise<Contracts.SubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @param {boolean} hydrate
     * @return IPromise<void>
     */
    changeSubscriptionAccount(subscriptionId: string, providerNamespaceId: Contracts.AccountProviderNamespace, accountId: string, hydrate?: boolean): IPromise<void>;
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.AzureRegion[]>
     */
    getAccountRegions(): IPromise<Contracts.AzureRegion[]>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OfferSubscription} offerSubscription
     * @return IPromise<void>
     */
    updateOfferSubscription(offerSubscription: Contracts.OfferSubscription): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {Contracts.ResourceRenewalGroup} meterRenewalGroup
     * @param {number} newIncludedQuantity
     * @param {number} newMaximumQuantity
     * @return IPromise<void>
     */
    setAccountQuantity(offerMeterName: string, meterRenewalGroup: Contracts.ResourceRenewalGroup, newIncludedQuantity: number, newMaximumQuantity: number): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} galleryItemId
     * @param {string} azureSubscriptionId
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.IOfferSubscription[]>
     */
    getOfferSubscriptionsForGalleryItem(galleryItemId: string, azureSubscriptionId: string, nextBillingPeriod?: boolean): IPromise<Contracts.IOfferSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.IOfferSubscription[]>
     */
    getOfferSubscriptions(nextBillingPeriod?: boolean): IPromise<Contracts.IOfferSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {string} galleryId
     * @param {Contracts.ResourceRenewalGroup} renewalGroup
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.IOfferSubscription>
     */
    getOfferSubscriptionForRenewalGroup(galleryId: string, renewalGroup: Contracts.ResourceRenewalGroup, nextBillingPeriod?: boolean): IPromise<Contracts.IOfferSubscription>;
    /**
     * [Preview API]
     *
     * @param {string} galleryId
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.IOfferSubscription>
     */
    getOfferSubscription(galleryId: string, nextBillingPeriod?: boolean): IPromise<Contracts.IOfferSubscription>;
    /**
     * [Preview API]
     *
     * @param {boolean} validateAzuresubscription
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.IOfferSubscription[]>
     */
    getAllOfferSubscriptionsForUser(validateAzuresubscription: boolean, nextBillingPeriod: boolean): IPromise<Contracts.IOfferSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {Contracts.ResourceRenewalGroup} renewalGroup
     * @return IPromise<void>
     */
    enableTrialOrPreviewOfferSubscription(offerMeterName: string, renewalGroup: Contracts.ResourceRenewalGroup): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {Contracts.ResourceRenewalGroup} renewalGroup
     * @param {Date} endDate
     * @return IPromise<void>
     */
    enableTrialOfferSubscriptionExtension(offerMeterName: string, renewalGroup: Contracts.ResourceRenewalGroup, endDate: Date): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {Contracts.ResourceRenewalGroup} renewalGroup
     * @param {number} quantity
     * @param {boolean} shouldBeImmediate
     * @param {string} azureSubscriptionId
     * @return IPromise<void>
     */
    decreaseResourceQuantity(offerMeterName: string, renewalGroup: Contracts.ResourceRenewalGroup, quantity: number, shouldBeImmediate: boolean, azureSubscriptionId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OfferSubscription} offerSubscription
     * @param {string} offerCode
     * @param {string} tenantId
     * @param {string} objectId
     * @param {string} billingTarget
     * @return IPromise<void>
     */
    createOfferSubscription(offerSubscription: Contracts.OfferSubscription, offerCode?: string, tenantId?: string, objectId?: string, billingTarget?: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OfferSubscription} offerSubscription
     * @param {string} cancelReason
     * @param {string} billingTarget
     * @param {boolean} immediate
     * @return IPromise<void>
     */
    cancelOfferSubscription(offerSubscription: Contracts.OfferSubscription, cancelReason: string, billingTarget?: string, immediate?: boolean): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OfferMeterPrice[]} offerMeterPricing
     * @param {string} galleryId
     * @return IPromise<void>
     */
    updateOfferMeterPrice(offerMeterPricing: Contracts.OfferMeterPrice[], galleryId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} galleryId
     * @return IPromise<Contracts.OfferMeterPrice[]>
     */
    getOfferMeterPrice(galleryId: string): IPromise<Contracts.OfferMeterPrice[]>;
    /**
     * [Preview API]
     *
     * @param {string} resourceName
     * @param {string} resourceNameResolveMethod
     * @param {string} subscriptionId
     * @param {boolean} includeMeterPricing
     * @param {string} offerCode
     * @param {string} tenantId
     * @param {string} objectId
     * @return IPromise<Contracts.PurchasableOfferMeter>
     */
    getPurchasableOfferMeter(resourceName: string, resourceNameResolveMethod: string, subscriptionId: string, includeMeterPricing: boolean, offerCode?: string, tenantId?: string, objectId?: string): IPromise<Contracts.PurchasableOfferMeter>;
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.OfferMeter[]>
     */
    getOfferMeters(): IPromise<Contracts.OfferMeter[]>;
    /**
     * [Preview API]
     *
     * @param {string} resourceName
     * @param {string} resourceNameResolveMethod
     * @return IPromise<Contracts.OfferMeter>
     */
    getOfferMeter(resourceName: string, resourceNameResolveMethod: string): IPromise<Contracts.OfferMeter>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OfferMeter} offerConfig
     * @return IPromise<void>
     */
    createOfferMeterDefinition(offerConfig: Contracts.OfferMeter): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.SubscriptionResource} meter
     * @return IPromise<void>
     */
    updateMeter(meter: Contracts.SubscriptionResource): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ResourceName} resourceName
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.ISubscriptionResource>
     */
    getResourceStatusByResourceName(resourceName: Contracts.ResourceName, nextBillingPeriod?: boolean): IPromise<Contracts.ISubscriptionResource>;
    /**
     * [Preview API]
     *
     * @param {boolean} nextBillingPeriod
     * @return IPromise<Contracts.ISubscriptionResource[]>
     */
    getResourceStatus(nextBillingPeriod?: boolean): IPromise<Contracts.ISubscriptionResource[]>;
}
export class CommonMethods3To5 extends CommonMethods2To5 {
    protected commercePackageApiVersion: string;
    protected connectedServerApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ConnectedServer} connectedServer
     * @return IPromise<Contracts.ConnectedServer>
     */
    createConnectedServer(connectedServer: Contracts.ConnectedServer): IPromise<Contracts.ConnectedServer>;
    /**
     * [Preview API]
     *
     * @param {string} version
     * @return IPromise<Contracts.ICommercePackage>
     */
    getCommercePackage(version?: string): IPromise<Contracts.ICommercePackage>;
}
export class CommonMethods3_2To5 extends CommonMethods3To5 {
    protected reportingEventsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} viewName
     * @param {string} resourceName
     * @param {Date} startTime
     * @param {Date} endTime
     * @param {string} filter
     * @return IPromise<Contracts.ICommerceEvent[]>
     */
    getReportingEvents(viewName: string, resourceName: string, startTime: Date, endTime: Date, filter?: string): IPromise<Contracts.ICommerceEvent[]>;
}
export class CommonMethods4To5 extends CommonMethods3_2To5 {
    protected purchaseRequestApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.PurchaseRequest} request
     * @return IPromise<void>
     */
    updatePurchaseRequest(request: Contracts.PurchaseRequest): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.PurchaseRequest} request
     * @return IPromise<void>
     */
    createPurchaseRequest(request: Contracts.PurchaseRequest): IPromise<void>;
}
export class CommonMethods4_1To5 extends CommonMethods4To5 {
    protected commerceHostHelperResourceApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Updates collection owner, bypassing bind pending identity owner check
     *
     * @param {string} newOwnerId
     * @param {string} ownerDomain
     * @return IPromise<boolean>
     */
    updateCollectionOwner(newOwnerId: string, ownerDomain: string): IPromise<boolean>;
    /**
     * [Preview API]
     *
     * @param {string} propertyKind
     * @param {string[]} properties
     * @return IPromise<string[]>
     */
    getInfrastructureOrganizationProperties(propertyKind: string, properties: string[]): IPromise<string[]>;
    /**
     * [Preview API]
     *
     * @param {string} resourceName
     * @param {string} collectionHostName
     * @param {string} hostRegion
     * @param {string} tags
     * @return IPromise<string>
     */
    createInfrastructureOrganization(resourceName: string, collectionHostName: string, hostRegion: string, tags: string): IPromise<string>;
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient4 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient3_2 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient3_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CommerceHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class CommerceHttpClient extends CommerceHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return CommerceHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): CommerceHttpClient4_1;
}
declare module "VSS/Commerce/VSS.OfferMeter.WebApi" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   commerce\client\webapi\clientgeneratorconfigs\genclient.json
 */
import VSS_Commerce_Contracts = require("VSS/Commerce/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4_1To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected offerMeterApiVersion: string;
    protected offerMeterPriceApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.OfferMeterPrice[]} offerMeterPricing
     * @param {string} galleryId
     * @return IPromise<void>
     */
    updateOfferMeterPrice(offerMeterPricing: VSS_Commerce_Contracts.OfferMeterPrice[], galleryId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} galleryId
     * @return IPromise<VSS_Commerce_Contracts.OfferMeterPrice[]>
     */
    getOfferMeterPrice(galleryId: string): IPromise<VSS_Commerce_Contracts.OfferMeterPrice[]>;
    /**
     * [Preview API]
     *
     * @param {string} resourceName
     * @param {string} resourceNameResolveMethod
     * @param {string} subscriptionId
     * @param {boolean} includeMeterPricing
     * @param {string} offerCode
     * @param {string} tenantId
     * @param {string} objectId
     * @return IPromise<VSS_Commerce_Contracts.PurchasableOfferMeter>
     */
    getPurchasableOfferMeter(resourceName: string, resourceNameResolveMethod: string, subscriptionId: string, includeMeterPricing: boolean, offerCode?: string, tenantId?: string, objectId?: string): IPromise<VSS_Commerce_Contracts.PurchasableOfferMeter>;
    /**
     * [Preview API]
     *
     * @return IPromise<VSS_Commerce_Contracts.OfferMeter[]>
     */
    getOfferMeters(): IPromise<VSS_Commerce_Contracts.OfferMeter[]>;
    /**
     * [Preview API]
     *
     * @param {string} resourceName
     * @param {string} resourceNameResolveMethod
     * @return IPromise<VSS_Commerce_Contracts.OfferMeter>
     */
    getOfferMeter(resourceName: string, resourceNameResolveMethod: string): IPromise<VSS_Commerce_Contracts.OfferMeter>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.OfferMeter} offerConfig
     * @return IPromise<void>
     */
    createOfferMeterDefinition(offerConfig: VSS_Commerce_Contracts.OfferMeter): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class OfferMeterHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OfferMeterHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class OfferMeterHttpClient extends OfferMeterHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return OfferMeterHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): OfferMeterHttpClient4_1;
}
declare module "VSS/Commerce/VSS.OfferSubscription.WebApi" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   commerce\client\webapi\clientgeneratorconfigs\genclient.json
 */
import VSS_Commerce_Contracts = require("VSS/Commerce/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4_1To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected offerSubscriptionApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.OfferSubscription} offerSubscription
     * @return IPromise<void>
     */
    updateOfferSubscription(offerSubscription: VSS_Commerce_Contracts.OfferSubscription): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {VSS_Commerce_Contracts.ResourceRenewalGroup} meterRenewalGroup
     * @param {number} newIncludedQuantity
     * @param {number} newMaximumQuantity
     * @return IPromise<void>
     */
    setAccountQuantity(offerMeterName: string, meterRenewalGroup: VSS_Commerce_Contracts.ResourceRenewalGroup, newIncludedQuantity: number, newMaximumQuantity: number): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} galleryItemId
     * @param {string} azureSubscriptionId
     * @param {boolean} nextBillingPeriod
     * @return IPromise<VSS_Commerce_Contracts.IOfferSubscription[]>
     */
    getOfferSubscriptionsForGalleryItem(galleryItemId: string, azureSubscriptionId: string, nextBillingPeriod?: boolean): IPromise<VSS_Commerce_Contracts.IOfferSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {boolean} nextBillingPeriod
     * @return IPromise<VSS_Commerce_Contracts.IOfferSubscription[]>
     */
    getOfferSubscriptions(nextBillingPeriod?: boolean): IPromise<VSS_Commerce_Contracts.IOfferSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {string} galleryId
     * @param {VSS_Commerce_Contracts.ResourceRenewalGroup} renewalGroup
     * @param {boolean} nextBillingPeriod
     * @return IPromise<VSS_Commerce_Contracts.IOfferSubscription>
     */
    getOfferSubscriptionForRenewalGroup(galleryId: string, renewalGroup: VSS_Commerce_Contracts.ResourceRenewalGroup, nextBillingPeriod?: boolean): IPromise<VSS_Commerce_Contracts.IOfferSubscription>;
    /**
     * [Preview API]
     *
     * @param {string} galleryId
     * @param {boolean} nextBillingPeriod
     * @return IPromise<VSS_Commerce_Contracts.IOfferSubscription>
     */
    getOfferSubscription(galleryId: string, nextBillingPeriod?: boolean): IPromise<VSS_Commerce_Contracts.IOfferSubscription>;
    /**
     * [Preview API]
     *
     * @param {boolean} validateAzuresubscription
     * @param {boolean} nextBillingPeriod
     * @return IPromise<VSS_Commerce_Contracts.IOfferSubscription[]>
     */
    getAllOfferSubscriptionsForUser(validateAzuresubscription: boolean, nextBillingPeriod: boolean): IPromise<VSS_Commerce_Contracts.IOfferSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {VSS_Commerce_Contracts.ResourceRenewalGroup} renewalGroup
     * @return IPromise<void>
     */
    enableTrialOrPreviewOfferSubscription(offerMeterName: string, renewalGroup: VSS_Commerce_Contracts.ResourceRenewalGroup): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {VSS_Commerce_Contracts.ResourceRenewalGroup} renewalGroup
     * @param {Date} endDate
     * @return IPromise<void>
     */
    enableTrialOfferSubscriptionExtension(offerMeterName: string, renewalGroup: VSS_Commerce_Contracts.ResourceRenewalGroup, endDate: Date): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} offerMeterName
     * @param {VSS_Commerce_Contracts.ResourceRenewalGroup} renewalGroup
     * @param {number} quantity
     * @param {boolean} shouldBeImmediate
     * @param {string} azureSubscriptionId
     * @return IPromise<void>
     */
    decreaseResourceQuantity(offerMeterName: string, renewalGroup: VSS_Commerce_Contracts.ResourceRenewalGroup, quantity: number, shouldBeImmediate: boolean, azureSubscriptionId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.OfferSubscription} offerSubscription
     * @param {string} offerCode
     * @param {string} tenantId
     * @param {string} objectId
     * @param {string} billingTarget
     * @return IPromise<void>
     */
    createOfferSubscription(offerSubscription: VSS_Commerce_Contracts.OfferSubscription, offerCode?: string, tenantId?: string, objectId?: string, billingTarget?: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.OfferSubscription} offerSubscription
     * @param {string} cancelReason
     * @param {string} billingTarget
     * @param {boolean} immediate
     * @return IPromise<void>
     */
    cancelOfferSubscription(offerSubscription: VSS_Commerce_Contracts.OfferSubscription, cancelReason: string, billingTarget?: string, immediate?: boolean): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class OfferSubscriptionHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OfferSubscriptionHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class OfferSubscriptionHttpClient extends OfferSubscriptionHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return OfferSubscriptionHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): OfferSubscriptionHttpClient4_1;
}
declare module "VSS/Commerce/VSS.PurchaseRequest.WebApi" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   commerce\client\webapi\clientgeneratorconfigs\genclient.json
 */
import VSS_Commerce_Contracts = require("VSS/Commerce/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4_1To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected purchaseRequestApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.PurchaseRequest} request
     * @return IPromise<void>
     */
    updatePurchaseRequest(request: VSS_Commerce_Contracts.PurchaseRequest): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.PurchaseRequest} request
     * @return IPromise<void>
     */
    createPurchaseRequest(request: VSS_Commerce_Contracts.PurchaseRequest): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class PurchaseRequestHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class PurchaseRequestHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class PurchaseRequestHttpClient extends PurchaseRequestHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return PurchaseRequestHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): PurchaseRequestHttpClient4_1;
}
declare module "VSS/Commerce/VSS.Subscription.WebApi" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   commerce\client\webapi\clientgeneratorconfigs\genclient.json
 */
import VSS_Commerce_Contracts = require("VSS/Commerce/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4_1To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected subscriptionApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @param {string} ownerId
     * @return IPromise<void>
     */
    unlinkAccount(subscriptionId: string, providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace, accountId: string, ownerId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @param {string} ownerId
     * @param {boolean} hydrate
     * @return IPromise<void>
     */
    linkAccount(subscriptionId: string, providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace, accountId: string, ownerId: string, hydrate?: boolean): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @return IPromise<VSS_Commerce_Contracts.SubscriptionAccount>
     */
    getSubscriptionAccount(providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace, accountId: string): IPromise<VSS_Commerce_Contracts.SubscriptionAccount>;
    /**
     * [Preview API]
     *
     * @param {string[]} ids
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @return IPromise<VSS_Commerce_Contracts.IAzureSubscription[]>
     */
    getAzureSubscriptions(ids: string[], providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace): IPromise<VSS_Commerce_Contracts.IAzureSubscription[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {boolean} queryAcrossTenants
     * @return IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>
     */
    getAzureSubscriptionForUser(subscriptionId?: string, queryAcrossTenants?: boolean): IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {string} galleryItemId
     * @param {string} accountId
     * @return IPromise<VSS_Commerce_Contracts.ISubscriptionAccount>
     */
    getAzureSubscriptionForPurchase(subscriptionId: string, galleryItemId: string, accountId?: string): IPromise<VSS_Commerce_Contracts.ISubscriptionAccount>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} memberId
     * @param {boolean} queryOnlyOwnerAccounts
     * @param {boolean} inlcudeDisabledAccounts
     * @param {boolean} includeMSAAccounts
     * @param {string[]} serviceOwners
     * @param {string} galleryId
     * @param {boolean} addUnlinkedSubscription
     * @param {boolean} queryAccountsByUpn
     * @return IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>
     */
    getAccountsByIdentityForOfferId(providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace, memberId: string, queryOnlyOwnerAccounts: boolean, inlcudeDisabledAccounts: boolean, includeMSAAccounts: boolean, serviceOwners: string[], galleryId: string, addUnlinkedSubscription?: boolean, queryAccountsByUpn?: boolean): IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} memberId
     * @param {boolean} queryOnlyOwnerAccounts
     * @param {boolean} inlcudeDisabledAccounts
     * @param {boolean} includeMSAAccounts
     * @param {string[]} serviceOwners
     * @return IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>
     */
    getAccountsByIdentity(providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace, memberId: string, queryOnlyOwnerAccounts: boolean, inlcudeDisabledAccounts: boolean, includeMSAAccounts: boolean, serviceOwners: string[]): IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @return IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>
     */
    getAccounts(subscriptionId: string, providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace): IPromise<VSS_Commerce_Contracts.ISubscriptionAccount[]>;
    /**
     * [Preview API]
     *
     * @param {string} subscriptionId
     * @param {VSS_Commerce_Contracts.AccountProviderNamespace} providerNamespaceId
     * @param {string} accountId
     * @param {boolean} hydrate
     * @return IPromise<void>
     */
    changeSubscriptionAccount(subscriptionId: string, providerNamespaceId: VSS_Commerce_Contracts.AccountProviderNamespace, accountId: string, hydrate?: boolean): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class SubscriptionHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SubscriptionHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class SubscriptionHttpClient extends SubscriptionHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return SubscriptionHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): SubscriptionHttpClient4_1;
}
declare module "VSS/Common/Constants/Platform" {
export module ContributedServiceContextData {
    /**
    * The data provider key for contributed service contexts
    */
    var ContributedServiceContextDataKey: string;
    /**
    * The dataType property value used for ContributedServiceContext data providers
    */
    var ContributedServiceDataProviderType: string;
}
export module DataProviderConstants {
    /**
    * The full contribution type id for data providers
    */
    var DataProviderContributionTypeId: string;
    /**
    * The contribution property name for the registered name of the data provider
    */
    var ContributionNameProperty: string;
    /**
    * The contribution property name for the service instance type id
    */
    var ContributionInstanceTypeProperty: string;
    /**
    * The resolution property is optional and defines how the resolution of this data provider should be treated.  Values: Server (default) - The Server will try and resolve the data provider during the initial data provider execution process. If it fails, it will include error details about the failure, and will also include details about how the data provider can be resolved from the client.  ServerOnly - Same as Server except upon failure, only failure details are returned and no information about how to resolve the dataprovider from the client. This may be used for a number of reasons, like security, or accessibility of the target.  Client - The Server will just serialize the data needed to resolve the data provider and leave it up to the client to resolve it when the client requires the data. This is common when the data is either optional or we dont want the request to wait for this data provider to be resolved.
    */
    var ContributionResolutionProperty: string;
    var ContributionResolutionServer: string;
    var ContributionResolutionServerOnly: string;
    var ContributionResolutionClient: string;
    /**
    * If the contribution wants specific properties available in the providerContext it can provide the name of a propertyProvider that will get be run. This is particularly useful when the data provider is a remote data provider and wants to gather data from the incoming request to forward to the remote service.
    */
    var ContributionPropertyProviderProperty: string;
    /**
    * The contribution property name for the "data type" property which consumers can use to classify the type of data being returned by this provider.
    */
    var ContributionDataTypeProperty: string;
}
export module HtmlProviderConstants {
    /**
    * The full contribution type id for html providers
    */
    var ContributionType: string;
    /**
    * The contribution property name for the registered name of the html provider
    */
    var ContributionNameProperty: string;
}
export module PropertyProviderConstants {
    /**
    * The full contribution type id for property providers
    */
    var ContributionType: string;
    /**
    * The contribution property name for the registered name of the property provider
    */
    var ContributionNameProperty: string;
}
/**
* Constants used to report customer intelligence area data
*/
export module WebAccessCustomerIntelligenceConstants {
    var Area: string;
    var WebSettingsStoreSettingFeature: string;
    var FullScreenModeFeature: string;
    var InvalidLicenseExceptionFeature: string;
}
/**
* Constants used for mobile
*/
export module WebAccessMobileConstants {
    var BypassMobileCookieName: string;
}
/**
* Constants used for VSSF\WebPlatform Feature Availability flags Note: This should only be flags consumed in platform-level typescript code or controllers.
*/
export module WebPlatformFeatureFlags {
    var VisualStudioServicesContributionUnSecureBrowsers: string;
    var ClientSideErrorLogging: string;
    var UseGalleryCdn: string;
    var MarkdownRendering: string;
    var SubresourceIntegrity: string;
    var ReactProfileCard: string;
    var UseNewBranding: string;
}
}
declare module "VSS/Common/Contracts/FormInput" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
/**
 * Enumerates data types that are supported as subscription input values.
 */
export enum InputDataType {
    /**
     * No data type is specified.
     */
    None = 0,
    /**
     * Represents a textual value.
     */
    String = 10,
    /**
     * Represents a numberic value.
     */
    Number = 20,
    /**
     * Represents a value of true or false.
     */
    Boolean = 30,
    /**
     * Represents a Guid.
     */
    Guid = 40,
    /**
     * Represents a URI.
     */
    Uri = 50
}
/**
 * Describes an input for subscriptions.
 */
export interface InputDescriptor {
    /**
     * The ids of all inputs that the value of this input is dependent on.
     */
    dependencyInputIds: string[];
    /**
     * Description of what this input is used for
     */
    description: string;
    /**
     * The group localized name to which this input belongs and can be shown as a header for the container that will include all the inputs in the group.
     */
    groupName: string;
    /**
     * If true, the value information for this input is dynamic and should be fetched when the value of dependency inputs change.
     */
    hasDynamicValueInformation: boolean;
    /**
     * Identifier for the subscription input
     */
    id: string;
    /**
     * Mode in which the value of this input should be entered
     */
    inputMode: InputMode;
    /**
     * Gets whether this input is confidential, such as for a password or application key
     */
    isConfidential: boolean;
    /**
     * Localized name which can be shown as a label for the subscription input
     */
    name: string;
    /**
     * Custom properties for the input which can be used by the service provider
     */
    properties: {
        [key: string]: any;
    };
    /**
     * Underlying data type for the input value. When this value is specified, InputMode, Validation and Values are optional.
     */
    type: string;
    /**
     * Gets whether this input is included in the default generated action description.
     */
    useInDefaultDescription: boolean;
    /**
     * Information to use to validate this input's value
     */
    validation: InputValidation;
    /**
     * A hint for input value. It can be used in the UI as the input placeholder.
     */
    valueHint: string;
    /**
     * Information about possible values for this input
     */
    values: InputValues;
}
/**
 * Defines a filter for subscription inputs. The filter matches a set of inputs if any (one or more) of the groups evaluates to true.
 */
export interface InputFilter {
    /**
     * Groups of input filter expressions. This filter matches a set of inputs if any (one or more) of the groups evaluates to true.
     */
    conditions: InputFilterCondition[];
}
/**
 * An expression which can be applied to filter a list of subscription inputs
 */
export interface InputFilterCondition {
    /**
     * Whether or not to do a case sensitive match
     */
    caseSensitive: boolean;
    /**
     * The Id of the input to filter on
     */
    inputId: string;
    /**
     * The "expected" input value to compare with the actual input value
     */
    inputValue: string;
    /**
     * The operator applied between the expected and actual input value
     */
    operator: InputFilterOperator;
}
export enum InputFilterOperator {
    Equals = 0,
    NotEquals = 1
}
/**
 * Mode in which a subscription input should be entered (in a UI)
 */
export enum InputMode {
    /**
     * This input should not be shown in the UI
     */
    None = 0,
    /**
     * An input text box should be shown
     */
    TextBox = 10,
    /**
     * An password input box should be shown
     */
    PasswordBox = 20,
    /**
     * A select/combo control should be shown
     */
    Combo = 30,
    /**
     * Radio buttons should be shown
     */
    RadioButtons = 40,
    /**
     * Checkbox should be shown(for true/false values)
     */
    CheckBox = 50,
    /**
     * A multi-line text area should be shown
     */
    TextArea = 60
}
/**
 * Describes what values are valid for a subscription input
 */
export interface InputValidation {
    dataType: InputDataType;
    isRequired: boolean;
    maxLength: number;
    maxValue: number;
    minLength: number;
    minValue: number;
    pattern: string;
    patternMismatchErrorMessage: string;
}
/**
 * Information about a single value for an input
 */
export interface InputValue {
    /**
     * Any other data about this input
     */
    data: {
        [key: string]: any;
    };
    /**
     * The text to show for the display of this value
     */
    displayValue: string;
    /**
     * The value to store for this input
     */
    value: string;
}
/**
 * Information about the possible/allowed values for a given subscription input
 */
export interface InputValues {
    /**
     * The default value to use for this input
     */
    defaultValue: string;
    /**
     * Errors encountered while computing dynamic values.
     */
    error: InputValuesError;
    /**
     * The id of the input
     */
    inputId: string;
    /**
     * Should this input be disabled
     */
    isDisabled: boolean;
    /**
     * Should the value be restricted to one of the values in the PossibleValues (True) or are the values in PossibleValues just a suggestion (False)
     */
    isLimitedToPossibleValues: boolean;
    /**
     * Should this input be made read-only
     */
    isReadOnly: boolean;
    /**
     * Possible values that this input can take
     */
    possibleValues: InputValue[];
}
/**
 * Error information related to a subscription input value.
 */
export interface InputValuesError {
    /**
     * The error message.
     */
    message: string;
}
export interface InputValuesQuery {
    currentValues: {
        [key: string]: string;
    };
    /**
     * The input values to return on input, and the result from the consumer on output.
     */
    inputValues: InputValues[];
    /**
     * Subscription containing information about the publisher/consumer and the current input values
     */
    resource: any;
}
export var TypeInfo: {
    InputDataType: {
        enumValues: {
            "none": number;
            "string": number;
            "number": number;
            "boolean": number;
            "guid": number;
            "uri": number;
        };
    };
    InputDescriptor: any;
    InputFilter: any;
    InputFilterCondition: any;
    InputFilterOperator: {
        enumValues: {
            "equals": number;
            "notEquals": number;
        };
    };
    InputMode: {
        enumValues: {
            "none": number;
            "textBox": number;
            "passwordBox": number;
            "combo": number;
            "radioButtons": number;
            "checkBox": number;
            "textArea": number;
        };
    };
    InputValidation: any;
};
}
declare module "VSS/Common/Contracts/Platform" {
import VSS_Contributions_Contracts = require("VSS/Contributions/Contracts");
/**
* Model to represent a public access uri
*/
export interface AccessPointModel {
    /**
    * Host name and port number of the url
    */
    authority: string;
    /**
    * Url scheme (http, https, ...)
    */
    scheme: string;
    /**
    * Full url
    */
    uri: string;
}
/**
* Data related to Active Extensions
*/
export interface ActiveExtensionsData {
    /**
    * Dictionary mapping extension ids to their active status
    */
    extensions: {
        [key: string]: boolean;
    };
}
/**
* Model used to configure how TFS reports usage data to Application Insights
*/
export interface AppInsightsConfiguration {
    /**
    * If true, automatically call "trackPage" when the page is loaded
    */
    autoTrackPage: boolean;
    /**
    * Optional data used to override the default values sent to trackPage
    */
    customTrackPageData: AppInsightsCustomTrackPageData;
    /**
    * Set to false if app insights reporting is not enabled/configured
    */
    enabled: boolean;
    /**
    * The url from which to retrieve app insights scripts
    */
    insightsScriptUrl: string;
    /**
    * The instrumentation key used to track this deployment's usage
    */
    instrumentationKey: string;
    /**
    * If true, include collection, project, and team info in the track-page urls
    */
    trackProjectInfo: boolean;
}
/**
* Model that can be used to customize the values sent to AppInsights via "trackPage"
*/
export interface AppInsightsCustomTrackPageData {
    alias: string;
    metrics: {
        [key: string]: any;
    };
    pageName: string;
    properties: {
        [key: string]: string;
    };
}
/**
* Web Access configuration data. This information is used to process requests on the server.  This data is also placed in a json island on each page in order for JavaScript to know key configuration data required to things like construct proper urls
*/
export interface ConfigurationContext {
    /**
    * MVC api configuration
    */
    api: ConfigurationContextApis;
    /**
    * Optional name of the client (e.g. TEE) hosting the page
    */
    clientHost: string;
    isHosted: boolean;
    /**
    * Current mail settings for TFS
    */
    mailSettings: TfsMailSettings;
    /**
    * Server resource paths
    */
    paths: ConfigurationContextPaths;
    /**
    * Indicates what URL format to use.
    */
    useCodexDomainUrls: boolean;
}
/**
* MVC api configuration
*/
export interface ConfigurationContextApis {
    /**
    * Specifies the path prefix for the area
    */
    areaPrefix: string;
    /**
    * Specifies the path prefix for the controller
    */
    controllerPrefix: string;
    /**
    * Api-version for legacy rpc-style web access api controllers See WebApiVersionClient for the version coming from the client/browser.  The return value is a positive whole number >= 1.
    */
    webApiVersion: string;
}
/**
* Paths to server resources
*/
export interface ConfigurationContextPaths {
    /**
    * Path (no CDN) to versioned static content
    */
    cdnFallbackStaticRootTfs: string;
    /**
    * Relative path to the _content path of the web application
    */
    resourcesPath: string;
    /**
    * Relative path to the root of the web application
    */
    rootPath: string;
    /**
    * Absolute path to build static content URLs from. May be relative or fully-qualified.
    */
    staticContentRootPath: string;
    /**
    * Static content version stamp
    */
    staticContentVersion: string;
    /**
    * Relative path to unversioned 3rd party static content
    */
    staticRoot3rdParty: string;
    /**
    * Relative path to versioned static content
    */
    staticRootTfs: string;
}
export enum ContextHostType {
    Unknown = 0,
    /**
    * The Deployment Host
    */
    Deployment = 1,
    /**
    * A legacy name for the Organization host. Use ContextHostType.Organization instead.
    */
    Application = 2,
    /**
    * The Organization host
    */
    Organization = 2,
    /**
    * The Project Collection
    */
    ProjectCollection = 4
}
export interface ContextIdentifier {
    id: string;
    name: string;
}
/**
* Page context configuration that can be contributed by remote services (different VSTS services delivering content to the page)
*/
export interface ContributedServiceContext {
    /**
    * Dynamic bundles to include from this service
    */
    bundles: DynamicBundlesCollection;
    /**
    * Specifies the prefixes for CSS modules that should map to the current service. e.g. "VSS/LoaderPlugins/Css!EMS:ExtensionManagement" would map to ExtensionManagement.css under the themed content path of this service if "EMS" is in the CSSModulePrefixes list.
    */
    cssModulePrefixes: string[];
    /**
    * Feature flag states to include by default in page data (avoids AJAX lookup)
    */
    featureAvailability: FeatureAvailabilityContext;
    /**
    * Module loader configuration which may be merged-in with the parent host (if injected into the DOM) Because the config may be merged with the host config, each root area path must be explicitly defined here rather than relying on basePath as a catch-all.
    */
    moduleLoaderConfig: ModuleLoaderConfiguration;
    /**
    * Paths to resources on this service
    */
    paths: ConfigurationContextPaths;
    /**
    * Lookup of urls for different services (at different host levels)
    */
    serviceLocations: ServiceLocations;
    /**
    * The root url of the service that can be used to resolve relative links when this content is hosted in another site.
    */
    serviceRootUrl: string;
    /**
    * Instance id of the service
    */
    serviceTypeId: string;
}
/**
* Item representing a contribution path. Can be of type default, resource or bundle
*/
export interface ContributionPath {
    /**
    * Type if this contribution path
    */
    pathType: ContributionPathType;
    /**
    * Replace value for this contribution path
    */
    value: string;
}
/**
* Type of the contribution path
*/
export enum ContributionPathType {
    Default = 0,
    Resource = 1,
    ThirdParty = 2
}
export interface ContributionsPageData {
    contributions: PageContribution[];
    providerDetails: {
        [key: string]: PageContributionProviderDetails;
    };
    queriedContributionIds: string[];
}
/**
* Contains lists of script and css references that need to be included on the page in order for the controls used by the page to work.
*/
export interface CoreReferencesContext {
    /**
    * Core 3rd party javascript bundle reference
    */
    coreScriptsBundle: JavascriptFileReference;
    /**
    * Core VSS javascript bundle reference for extension frames
    */
    extensionCoreReferences: JavascriptFileReference;
    /**
    * Core javascript files referenced on a page
    */
    scripts: JavascriptFileReference[];
    /**
    * Core CSS files referenced on a page
    */
    stylesheets: StylesheetReference[];
}
export interface DaylightSavingsAdjustmentEntry {
    /**
    * Millisecond adjustment from UTC
    */
    offset: number;
    /**
    * Date that the offset adjustment starts
    */
    start: Date;
}
export interface DiagnosticsContext {
    /**
    * Id of the current activity
    */
    activityId: string;
    allowStatsCollection: boolean;
    /**
    * Whether or not to enable static content bundling. This is on by default but the value can be overridden with a TFS-BUNDLING cookie or registry entry.
    */
    bundlingEnabled: boolean;
    /**
    * True if the CDN feature flag is enabled.
    */
    cdnAvailable: boolean;
    /**
    * True if the CDN feature flag is enabled and the user has not disabled CDN with a cookie.
    */
    cdnEnabled: boolean;
    clientLogLevel: number;
    debugMode: boolean;
    /**
    * Whether or not to diagnose the bundles.
    */
    diagnoseBundles: boolean;
    inExtensionFallbackMode: boolean;
    isDevFabric: boolean;
    serviceVersion: string;
    sessionId: string;
    tracePointCollectionEnabled: boolean;
    tracePointProfileEnd: string;
    tracePointProfileStart: string;
    /**
    * Denotes the version of the web platform consumed by this service. Of the form M###.
    */
    webPlatformVersion: string;
}
export interface DynamicBundlesCollection {
    scripts: DynamicScriptBundle[];
    scriptsExcludedByPath: string[];
    styles: DynamicCSSBundle[];
}
export interface DynamicCSSBundle {
    clientId: string;
    contentLength: number;
    cssFiles: string[];
    fallbackThemeUri: string;
    uri: string;
}
export interface DynamicScriptBundle {
    clientId: string;
    contentLength: number;
    integrity: string;
    uri: string;
}
export interface ExtendedHostContext {
    authority: string;
    hostType: ContextHostType;
    id: string;
    isAADAccount: boolean;
    name: string;
    relativeUri: string;
    scheme: string;
    uri: string;
}
export interface FeatureAvailabilityContext {
    featureStates: {
        [key: string]: boolean;
    };
}
export interface GlobalizationContext {
    culture: string;
    /**
    * Gets the explicitly-set theme, or the empty string if a theme was not explicitly set. An explicitly-set theme is set either in the query string (?theme=[themename]) or in the user's profile. However, the default theme set in the profile is not considered to be an explicitly-set theme.
    */
    explicitTheme: string;
    theme: string;
    timeZoneId: string;
    timezoneOffset: number;
    typeAheadDisabled: boolean;
}
export interface HostContext {
    id: string;
    name: string;
    relativeUri: string;
    uri: string;
}
/**
* Model representing a hub in VSTS pages' navigation menu
*/
export interface Hub {
    ariaLabel: string;
    builtIn: boolean;
    groupId: string;
    hidden: boolean;
    icon: string;
    id: string;
    isSelected: boolean;
    name: string;
    order: any;
    supportsXHRNavigate: boolean;
    uri: string;
}
/**
* Model representing a hub group in VSTS pages' navigation menu
*/
export interface HubGroup {
    builtIn: boolean;
    hasHubs: boolean;
    hidden: boolean;
    icon: string;
    id: string;
    name: string;
    nonCollapsible: boolean;
    order: any;
    uri: string;
}
/**
* Context information containing the relevant hubs and hub groups for a given context
*/
export interface HubsContext {
    allHubs: Hub[];
    hubGroups: HubGroup[];
    hubGroupsCollectionContributionId: string;
    hubs: Hub[];
    pinningPreferences: PinningPreferences;
    selectedHubGroupId: string;
    selectedHubId: string;
    selectedNavigationIds: string[];
}
/**
* Model to represent a TeamFoundationIdentity
*/
export interface IdentityModel {
    /**
    * Custom display name
    */
    customDisplayName: string;
    /**
    * Display name
    */
    displayName: string;
    /**
    * Email address
    */
    email: string;
    /**
    * Unique team foundation id
    */
    id: string;
    /**
    * Is the identity active
    */
    isActive: boolean;
    /**
    * Is the identity a group/team
    */
    isContainer: boolean;
    /**
    * The provider's display name for this identity
    */
    providerDisplayName: string;
    /**
    * Unique name for this identity
    */
    uniqueName: string;
}
/**
* Reference to a javascript file to include on a page
*/
export interface JavascriptFileReference {
    /**
    * Condition to check in the case that Url lives on a CDN. The fallback script will be included if this check fails.
    */
    fallbackCondition: string;
    /**
    * Fallback url to use in case Url lives on a CDN
    */
    fallbackUrl: string;
    /**
    * Id of the reference (JQuery, JQueryUI, MicrosoftAjax, etc.)
    */
    identifier: string;
    /**
    * Is this a core javascript file that needs to be included in all child extension frames
    */
    isCoreModule: boolean;
    /**
    * Url of the javascript reference
    */
    url: string;
}
/**
* Class used to wrap arrays in an object.
*/
export interface JsonArrayWrapper {
    __wrappedArray: string;
}
export interface MicrosoftAjaxConfig {
    cultureInfo: any;
}
/**
* AMD javascript module loader configuration
*/
export interface ModuleLoaderConfiguration {
    baseUrl: string;
    contributionPaths: {
        [key: string]: ContributionPath;
    };
    paths: {
        [key: string]: string;
    };
    shim: {
        [key: string]: ModuleLoaderShimConfiguration;
    };
    /**
    * The maximum amount of time (in seconds) the AMD loader will wait for scripts to load.
    */
    waitSeconds: number;
}
/**
* AMD javascript module loader shim configuration
*/
export interface ModuleLoaderShimConfiguration {
    deps: string[];
    exports: string;
}
/**
* Structure to specify current navigation context of the executing request. The navigation context content's are generally obtained from the request URL. Some context specifiers such as "Account" can be implicit and might come from current IVssServiceHost.
*/
export interface NavigationContext {
    /**
    * A token to show which area the request has been targeted to. By default there are two areas "Admin" and "Api". They can be specified in the URL as _admin and _api respectively.
    */
    area: string;
    /**
    * Command name for the current request's route. Used in telemetry and reporting.
    */
    commandName: string;
    /**
    * Current action route value
    */
    currentAction: string;
    /**
    * Current controller route value
    */
    currentController: string;
    /**
    * Current parameters route value (the path after the controller and action in the url)
    */
    currentParameters: string;
    /**
    * The id of the matched route
    */
    routeId: string;
    /**
    * The templates for the matched route
    */
    routeTemplates: string[];
    /**
    * The set of route values for this request
    */
    routeValues: {
        [key: string]: string;
    };
    /**
    * Flag to show top most navigation context. For example the URL http://server:port/collection/project/_controller/action sets the Project bit while the URL http://server:port/collection/project/_admin/_controller/action sets also sets the area property to Admin.
    */
    topMostLevel: NavigationContextLevels;
}
/**
* Flags to show which tokens of the navigation context are present in the current request URL. The request url's context part are formed like http://server:port[/{collection}[/{project}[/{team}]]][/_admin]/_{controller}/{action} The tokens {collection}, {project} and {team} are navigation level tokens whereas _admin segment is a switch to show admin areas of the site.
*/
export enum NavigationContextLevels {
    None = 0,
    /**
    * Root level in Azure.
    */
    Deployment = 1,
    /**
    * Root level in on premises. Neither of {collection}, {project} and {team} tokens have information
    */
    Application = 2,
    /**
    * Flag to show {collection} token has information.
    */
    Collection = 4,
    /**
    * Flag to show {project} token has information.
    */
    Project = 8,
    /**
    * Flag to show {team} token has information.
    */
    Team = 16,
    /**
    * Sugar for all application levels.
    */
    ApplicationAll = 30,
    /**
    * Sugar for all levels
    */
    All = 31
}
/**
* Global context placed on each VSSF web page (through json island data) which gives enough information for core TypeScript modules/controls on the page to operate
*/
export interface PageContext {
    /**
    * Configuration for reporting telemetry/usage data to App Insights
    */
    appInsightsConfiguration: AppInsightsConfiguration;
    /**
    * Core javascript and css references
    */
    coreReferences: CoreReferencesContext;
    /**
    * Specifies the prefixes for CSS modules that should map to the current service. e.g. "VSS/LoaderPlugins/Css!EMS:ExtensionManagement" would map to ExtensionManagement.css under the themed content path of this service if "EMS" is in the CSSModulePrefixes list.
    */
    cssModulePrefixes: string[];
    /**
    * Diagnostic related information for the current page
    */
    diagnostics: DiagnosticsContext;
    /**
    * Feature flag states to include by default in page data (avoids AJAX lookup)
    */
    featureAvailability: FeatureAvailabilityContext;
    /**
    * Globalization data for the current page based on the current user's settings
    */
    globalization: GlobalizationContext;
    /**
    * Cached set of hubs and hub groups for the given request/navigation-context
    */
    hubsContext: HubsContext;
    /**
    * Configuration needed for Microsoft.Ajax library
    */
    microsoftAjaxConfig: MicrosoftAjaxConfig;
    /**
    * The (AMD) module configuration
    */
    moduleLoaderConfig: ModuleLoaderConfiguration;
    /**
    * Current navigation context.
    */
    navigation: NavigationContext;
    /**
    * The service instance type id for the VSTS service serving this page
    */
    serviceInstanceId: string;
    serviceLocations: ServiceLocations;
    /**
    * Contains global time zone configuration information (e.g. which dates DST changes)
    */
    timeZonesConfiguration: TimeZonesConfiguration;
    /**
    * Web Access configuration
    */
    webAccessConfiguration: ConfigurationContext;
    /**
    * The web context information for the given page request
    */
    webContext: WebContext;
}
export interface PageContribution {
    id: string;
    includes: string[];
    properties: any;
    targets: string[];
    type: string;
}
export interface PageContributionProviderDetails {
    displayName: string;
    name: string;
    properties: {
        [key: string]: string;
    };
}
export interface PageXHRData {
    activityId: string;
    bundles: DynamicBundlesCollection;
    contributionsData: ContributionsPageData;
    dataProviderData: VSS_Contributions_Contracts.DataProviderResult;
    featureAvailability: FeatureAvailabilityContext;
    navigation: NavigationContext;
    performanceTimings: {
        [key: string]: any;
    };
    serviceLocations: ServiceLocations;
    staticContentVersion: string;
}
export interface PinningPreferences {
    pinnedHubGroupIds: string[];
    pinnedHubs: {
        [key: string]: string[];
    };
    unpinnedHubGroupIds: string[];
    unpinnedHubs: {
        [key: string]: string[];
    };
}
/**
* Holds a lookup of urls for different services (at different host levels)
*/
export interface ServiceLocations {
    locations: {
        [key: string]: {
            [key: number]: string;
        };
    };
}
/**
* Reference to a CSS file to include on a page
*/
export interface StylesheetReference {
    /**
    * Url of the high-contrast version of the CSS file
    */
    highContrastUrl: string;
    /**
    * Is this a core stylesheet that needs to be included in child frames
    */
    isCoreStylesheet: boolean;
    /**
    * Url of the CSS file
    */
    url: string;
}
export interface TeamContext {
    id: string;
    name: string;
}
/**
* Data contract to represent a given team foundation service host (account, collection, deployment)
*/
export interface TeamFoundationServiceHostModel {
    /**
    * Type of host (deployment, account, collection)
    */
    hostType: any;
    /**
    * Unique id of the host (collection id, account id, etc.)
    */
    instanceId: string;
    /**
    * Name of the host (collection name, account name, etc.)
    */
    name: string;
    /**
    * Path of the service host, relative to the root virtual directory (e.g. DefaultCollection)
    */
    relVDir: string;
    /**
    * Path of the service host relative to the web application root (e.g. /tfs/DefaultCollection)
    */
    vDir: string;
}
export interface TfsMailSettings {
    enabled: boolean;
}
/**
* Internal structure to describe IVssServiceHost
*/
export interface TfsServiceHostDescriptor {
    hostType: any;
    id: string;
    name: string;
    relVdir: string;
    vdir: string;
}
export interface TimeZonesConfiguration {
    daylightSavingsAdjustments: DaylightSavingsAdjustmentEntry[];
}
export interface UserContext {
    email: string;
    id: string;
    limitedAccess: boolean;
    name: string;
    subjectId: string;
    subjectType: string;
    uniqueName: string;
}
/**
* Context information for all web access requests
*/
export interface WebContext {
    account: HostContext;
    /**
    * Information about the Collection used in the current request (may be null)
    */
    collection: HostContext;
    /**
    * Information about the current request context's host
    */
    host: ExtendedHostContext;
    /**
    * Information about the project used in the current request (may be null)
    */
    project: ContextIdentifier;
    /**
    * Information about the team used in the current request (may be null)
    */
    team: TeamContext;
    /**
    * Information about the current user
    */
    user: UserContext;
}
/**
* Contextual data for web-page-related data providers about the originating (host/source) page
*/
export interface WebPageDataProviderPageSource {
    /**
    * List of paths contributed by the host which are available to 3rd party extension developers through VSS.SDK
    */
    contributionPaths: string[];
    /**
    * Diagnostics context (debug mode, activity id, etc.) of the source page
    */
    diagnostics: DiagnosticsContext;
    /**
    * Globalization context (theme, time zone, etc.) of the source page
    */
    globalization: WebPageGlobalizationContext;
    /**
    * The navigation context for the host page that is loading the data provider
    */
    navigation: NavigationContext;
    /**
    * The project context for the host page that is loading the data provider
    */
    project: ContextIdentifier;
    /**
    * Currently selected hubgroup id
    */
    selectedHubGroupId: string;
    /**
    * Currently selected hub id
    */
    selectedHubId: string;
    /**
    * The team context for the host page that is loading the data provider
    */
    team: ContextIdentifier;
    /**
    * The url of the host page that is loading the data provider
    */
    url: string;
}
/**
* Lightweight globalization context for web-page-related data providers
*/
export interface WebPageGlobalizationContext {
    /**
    * UI Culture of the host page
    */
    culture: string;
    /**
    * Theme of the host page
    */
    theme: string;
}
export var TypeInfo: {
    ContextHostType: {
        enumValues: {
            "unknown": number;
            "deployment": number;
            "application": number;
            "organization": number;
            "projectCollection": number;
        };
    };
    ContributedServiceContext: {
        fields: any;
    };
    ContributionPath: {
        fields: any;
    };
    ContributionPathType: {
        enumValues: {
            "default": number;
            "resource": number;
            "thirdParty": number;
        };
    };
    DaylightSavingsAdjustmentEntry: {
        fields: any;
    };
    ExtendedHostContext: {
        fields: any;
    };
    ModuleLoaderConfiguration: {
        fields: any;
    };
    NavigationContext: {
        fields: any;
    };
    NavigationContextLevels: {
        enumValues: {
            "none": number;
            "deployment": number;
            "application": number;
            "collection": number;
            "project": number;
            "team": number;
            "applicationAll": number;
            "all": number;
        };
    };
    PageContext: {
        fields: any;
    };
    PageXHRData: {
        fields: any;
    };
    ServiceLocations: {
        fields: any;
    };
    TimeZonesConfiguration: {
        fields: any;
    };
    WebContext: {
        fields: any;
    };
    WebPageDataProviderPageSource: {
        fields: any;
    };
};
}
declare module "VSS/Common/Contracts/System" {
export enum DayOfWeek {
    /**
     * Indicates Sunday.
     */
    Sunday = 0,
    /**
     * Indicates Monday.
     */
    Monday = 1,
    /**
     * Indicates Tuesday.
     */
    Tuesday = 2,
    /**
     * Indicates Wednesday.
     */
    Wednesday = 3,
    /**
     * Indicates Thursday.
     */
    Thursday = 4,
    /**
     * Indicates Friday.
     */
    Friday = 5,
    /**
     * Indicates Saturday.
     */
    Saturday = 6
}
export var TypeInfo: {
    DayOfWeek: {
        enumValues: {
            "sunday": number;
            "monday": number;
            "tuesday": number;
            "wednesday": number;
            "thursday": number;
            "friday": number;
            "saturday": number;
        };
    };
};
}
declare module "VSS/Common/Contracts/System.Data" {
/**
 * Specifies SQL Server-specific data type of a field, property, for use in a System.Data.SqlClient.SqlParameter.
 */
export enum SqlDbType {
    /**
     * A 64-bit signed integer.
     */
    BigInt = 0,
    /**
     * Array of type Byte. A fixed-length stream of binary data ranging between 1 and 8,000 bytes.
     */
    Binary = 1,
    /**
     * Boolean. An unsigned numeric value that can be 0, 1, or null.
     */
    Bit = 2,
    /**
     * String. A fixed-length stream of non-Unicode characters ranging between 1 and 8,000 characters.
     */
    Char = 3,
    /**
     * DateTime. Date and time data ranging in value from January 1, 1753 to December 31, 9999 to an accuracy of 3.33 milliseconds.
     */
    DateTime = 4,
    /**
     * Decimal. A fixed precision and scale numeric value between -10 38 -1 and 10 38 -1.
     */
    Decimal = 5,
    /**
     * Double. A floating point number within the range of -1.79E +308 through 1.79E +308.
     */
    Float = 6,
    /**
     * Array of type Byte. A variable-length stream of binary data ranging from 0 to 2 31 -1 (or 2,147,483,647) bytes.
     */
    Image = 7,
    /**
     * Int32. A 32-bit signed integer.
     */
    Int = 8,
    /**
     * Decimal. A currency value ranging from -2 63 (or -9,223,372,036,854,775,808) to 2 63 -1 (or +9,223,372,036,854,775,807) with an accuracy to a ten-thousandth of a currency unit.
     */
    Money = 9,
    /**
     * String. A fixed-length stream of Unicode characters ranging between 1 and 4,000 characters.
     */
    NChar = 10,
    /**
     * String. A variable-length stream of Unicode data with a maximum length of 2 30 - 1 (or 1,073,741,823) characters.
     */
    NText = 11,
    /**
     * String. A variable-length stream of Unicode characters ranging between 1 and 4,000 characters. Implicit conversion fails if the string is greater than 4,000 characters. Explicitly set the object when working with strings longer than 4,000 characters. Use System.Data.SqlDbType.NVarChar when the database column is nvarchar(max).
     */
    NVarChar = 12,
    /**
     * Single. A floating point number within the range of -3.40E +38 through 3.40E +38.
     */
    Real = 13,
    /**
     * Guid. A globally unique identifier (or GUID).
     */
    UniqueIdentifier = 14,
    /**
     * DateTime. Date and time data ranging in value from January 1, 1900 to June 6, 2079 to an accuracy of one minute.
     */
    SmallDateTime = 15,
    /**
     * Int16. A 16-bit signed integer.
     */
    SmallInt = 16,
    /**
     * Decimal. A currency value ranging from -214,748.3648 to +214,748.3647 with an accuracy to a ten-thousandth of a currency unit.
     */
    SmallMoney = 17,
    /**
     * String. A variable-length stream of non-Unicode data with a maximum length of 2 31 -1 (or 2,147,483,647) characters.
     */
    Text = 18,
    /**
     * Array of type System.Byte. Automatically generated binary numbers, which are guaranteed to be unique within a database. timestamp is used typically as a mechanism for version-stamping table rows. The storage size is 8 bytes.
     */
    Timestamp = 19,
    /**
     * Byte. An 8-bit unsigned integer.
     */
    TinyInt = 20,
    /**
     * Array of type Byte. A variable-length stream of binary data ranging between 1 and 8,000 bytes. Implicit conversion fails if the byte array is greater than 8,000 bytes. Explicitly set the object when working with byte arrays larger than 8,000 bytes.
     */
    VarBinary = 21,
    /**
     * String. A variable-length stream of non-Unicode characters ranging between 1 and 8,000 characters. Use System.Data.SqlDbType.VarChar when the database column is varchar(max).
     */
    VarChar = 22,
    /**
     * Object. A special data type that can contain numeric, string, binary, or date data as well as the SQL Server values Empty and Null, which is assumed if no other type is declared.
     */
    Variant = 23,
    /**
     * An XML value. Obtain the XML as a string using the System.Data.SqlClient.SqlDataReader.GetValue(System.Int32) method or System.Data.SqlTypes.SqlXml.Value property, or as an System.Xml.XmlReader by calling the System.Data.SqlTypes.SqlXml.CreateReader method.
     */
    Xml = 25,
    /**
     * A SQL Server user-defined type (UDT).
     */
    Udt = 29,
    /**
     * A special data type for specifying structured data contained in table-valued parameters.
     */
    Structured = 30,
    /**
     * Date data ranging in value from January 1,1 AD through December 31, 9999 AD.
     */
    Date = 31,
    /**
     * Time data based on a 24-hour clock. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds. Corresponds to a SQL Server time value.
     */
    Time = 32,
    /**
     * Date and time data. Date value range is from January 1,1 AD through December 31, 9999 AD. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds.
     */
    DateTime2 = 33,
    /**
     * Date and time data with time zone awareness. Date value range is from January 1,1 AD through December 31, 9999 AD. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds. Time zone value range is -14:00 through +14:00.
     */
    DateTimeOffset = 34
}
export var TypeInfo: {
    SqlDbType: {
        enumValues: {
            "BigInt": number;
            "Binary": number;
            "Bit": number;
            "Char": number;
            "DateTime": number;
            "Decimal": number;
            "Float": number;
            "Image": number;
            "Int": number;
            "Money": number;
            "NChar": number;
            "NText": number;
            "NVarChar": number;
            "Real": number;
            "UniqueIdentifier": number;
            "SmallDateTime": number;
            "SmallInt": number;
            "SmallMoney": number;
            "Text": number;
            "Timestamp": number;
            "TinyInt": number;
            "VarBinary": number;
            "VarChar": number;
            "Variant": number;
            "Xml": number;
            "Udt": number;
            "Structured": number;
            "Date": number;
            "Time": number;
            "DateTime2": number;
            "DateTimeOffset": number;
        };
    };
};
}
declare module "VSS/Compatibility" {
export function moved(name: string, fromPath: string, toPath: string, description?: any): void;
export function removed(name: string, internalUsage?: boolean): void;
export function deprecated(name: string, version: string): void;
}
declare module "VSS/Context" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
/**
 * Parse out the web context information found in JSON island data in the given element.
 */
export function parseWebContext($element: JQuery): Contracts_Platform.WebContext;
/**
 * Get the raw JSON of the global context of the current page.
 */
export function _getDefaultRawPageContext(): Contracts_Platform.PageContext;
/**
 * Get the default web context for the current page.
 */
export function getDefaultWebContext(): Contracts_Platform.WebContext;
/**
 * Get the global page context for the current page.
 */
export function getPageContext(): Contracts_Platform.PageContext;
/**
* Get the hub context information from the current page
*/
export function getHubsContext(): Contracts_Platform.HubsContext;
/**
* Get web access paths for the given service
*
* @param serviceInstanceTypeId The id of the service instance type
*/
export function getPathsForService(serviceInstanceTypeId: string): Contracts_Platform.ConfigurationContextPaths;
/**
 * Get the static content versions for each service currently known by the client.
 */
export function getStaticContentVersionsByService(): IDictionaryStringTo<string>;
/**
 * Get a lookup of service id to contribution paths that come from that service
 */
export function getContributionPathsForService(serviceInstanceTypeId: string): string[];
/**
* Add CSS module mappings to be used by the CSS loader.
*
* @param modulePrefix CSS module prefix to map
* @param url The base static root url used for CSS files for the service that owns that prefix
*/
export function addCssModulePrefixMapping(modulePrefix: string, url: string): void;
/**
* Get the url for the given CSS module (e.g. VSS/LoaderPlugins/Css!Prefix:ModulePath)
*
* @param modulePrefix CSS module prefix
* @param cssModulePath CSS module name
* @param theme The CSS theme (e.g. Default or HighContrast to use, defaults to the current theme if omitted)
* @returns The url to the themed css file
*/
export function getCssModuleUrl(modulePrefix: string, cssModulePath: string, theme?: string): string;
/**
 * Because we (try to) automatically detect high contrast mode, the actual theme we're using
 * doesn't always match the theme in pageContext.globalization.theme.
 */
export function getActiveTheme(): string;
/**
 * Get the root url for the specified service if the service has contributed to
 * the page's configuration context
 *
 * @param serviceInstanceTypeId The id of the service instance type
 */
export function getContributedServiceRootUrl(serviceInstanceTypeId: string): string;
/**
 * Is the current window/frame an extension iframe (not the parent frame and has the VSS.SDK loaded)
 */
export function isExtensionFrame(): boolean;
/**
 * Get the service instace type id of the service that owns the
 * given script module.
 *
 * Returns undefined if the owner is not known.
 * Returns empty string for TFS-owned scripts on-prem.
 *
 * @param module The script module to check (e.g. "VSS/Context")
 */
export function getScriptModuleOwner(module: string): string;
/**
 * For IE and Edge we can automatically detect HC mode.
 */
export function isAutoHighContrastMode(): boolean;
export function isHighContrastMode(): boolean;
export class ContributedServicePathBuilder {
    private appPath;
    private serviceRootUrl;
    private pathCombiner;
    /**
     * Context path builder for contributed services.
     *
     * @param serviceRootUrl Root URL of the contributed service.
     * @param pathCombiner Utility to combine two paths.
     */
    constructor(serviceRootUrl: string, pathCombiner?: (path1: string, path2: string) => string);
    /**
     * Get the root URL of the contributed service.
     */
    getServiceRootUrl(): string;
    /**
     * Combines the given relative path to the service root URL. If relative path already starts with app path,
     * app path is omitted to prevent it to recur.
     *
     * @param relativePath path to combine contributed service root URL.
     */
    combinePath(relativePath: string): string;
}
/**
* Process the contributed configuration from a particular service
*
* @param context The contributed service context to evaluate
*/
export function processContributedServiceContext(context: Contracts_Platform.ContributedServiceContext): IPromise<any>;
/**
 * Add feature availability data to the current page context
 *
 * @param featureAvailability Feature availability data to merge-in to the current page context's feature data
 */
export function addFeatureAvailability(featureAvailability: Contracts_Platform.FeatureAvailabilityContext): void;
/**
 * Add to the current page context's list of cached service locations
 *
 * @param serviceLocations Service location data to merge into to the current page context's data
 */
export function addServiceLocations(serviceLocations: Contracts_Platform.ServiceLocations): void;
}
declare module "VSS/Contributions/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   extensionmanagement\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_Gallery_Contracts = require("VSS/Gallery/Contracts");
/**
 * How the acquisition is assigned
 */
export enum AcquisitionAssignmentType {
    None = 0,
    /**
     * Just assign for me
     */
    Me = 1,
    /**
     * Assign for all users in the account
     */
    All = 2
}
export interface AcquisitionOperation {
    /**
     * State of the the AcquisitionOperation for the current user
     */
    operationState: AcquisitionOperationState;
    /**
     * AcquisitionOperationType: install, request, buy, etc...
     */
    operationType: AcquisitionOperationType;
    /**
     * Optional reason to justify current state. Typically used with Disallow state.
     */
    reason: string;
    /**
     * List of reasons indicating why the operation is not allowed.
     */
    reasons: AcquisitionOperationDisallowReason[];
}
export interface AcquisitionOperationDisallowReason {
    /**
     * User-friendly message clarifying the reason for disallowance
     */
    message: string;
    /**
     * Type of reason for disallowance - AlreadyInstalled, UnresolvedDemand, etc.
     */
    type: string;
}
export enum AcquisitionOperationState {
    /**
     * Not allowed to use this AcquisitionOperation
     */
    Disallow = 0,
    /**
     * Allowed to use this AcquisitionOperation
     */
    Allow = 1,
    /**
     * Operation has already been completed and is no longer available
     */
    Completed = 3
}
/**
 * Set of different types of operations that can be requested.
 */
export enum AcquisitionOperationType {
    /**
     * Not yet used
     */
    Get = 0,
    /**
     * Install this extension into the host provided
     */
    Install = 1,
    /**
     * Buy licenses for this extension and install into the host provided
     */
    Buy = 2,
    /**
     * Try this extension
     */
    Try = 3,
    /**
     * Request this extension for installation
     */
    Request = 4,
    /**
     * No action found
     */
    None = 5,
    /**
     * Request admins for purchasing extension
     */
    PurchaseRequest = 6
}
/**
 * Market item acquisition options (install, buy, etc) for an installation target.
 */
export interface AcquisitionOptions {
    /**
     * Default Operation for the ItemId in this target
     */
    defaultOperation: AcquisitionOperation;
    /**
     * The item id that this options refer to
     */
    itemId: string;
    /**
     * Operations allowed for the ItemId in this target
     */
    operations: AcquisitionOperation[];
    /**
     * Additional properties which can be added to the request.
     */
    properties: any;
    /**
     * The target that this options refer to
     */
    target: string;
}
/**
 * Representaion of a ContributionNode that can be used for serialized to clients.
 */
export interface ClientContribution {
    /**
     * Description of the contribution/type
     */
    description: string;
    /**
     * Fully qualified identifier of the contribution/type
     */
    id: string;
    /**
     * Includes is a set of contributions that should have this contribution included in their targets list.
     */
    includes: string[];
    /**
     * Properties/attributes of this contribution
     */
    properties: any;
    /**
     * The ids of the contribution(s) that this contribution targets. (parent contributions)
     */
    targets: string[];
    /**
     * Id of the Contribution Type
     */
    type: string;
}
/**
 * Representaion of a ContributionNode that can be used for serialized to clients.
 */
export interface ClientContributionNode {
    /**
     * List of ids for contributions which are children to the current contribution.
     */
    children: string[];
    /**
     * Contribution associated with this node.
     */
    contribution: ClientContribution;
    /**
     * List of ids for contributions which are parents to the current contribution.
     */
    parents: string[];
}
export interface ClientContributionProviderDetails {
    /**
     * Friendly name for the provider.
     */
    displayName: string;
    /**
     * Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
     */
    name: string;
    /**
     * Properties associated with the provider
     */
    properties: {
        [key: string]: string;
    };
    /**
     * Version of contributions assoicated with this contribution provider.
     */
    version: string;
}
/**
 * A client data provider are the details needed to make the data provider request from the client.
 */
export interface ClientDataProviderQuery extends DataProviderQuery {
    /**
     * The Id of the service instance type that should be communicated with in order to resolve the data providers from the client given the query values.
     */
    queryServiceInstanceType: string;
}
/**
 * An individual contribution made by an extension
 */
export interface Contribution extends ContributionBase {
    /**
     * List of constraints (filters) that should be applied to the availability of this contribution
     */
    constraints: ContributionConstraint[];
    /**
     * Includes is a set of contributions that should have this contribution included in their targets list.
     */
    includes: string[];
    /**
     * Properties/attributes of this contribution
     */
    properties: any;
    /**
     * List of demanded claims in order for the user to see this contribution (like anonymous, public, member...).
     */
    restrictedTo: string[];
    /**
     * The ids of the contribution(s) that this contribution targets. (parent contributions)
     */
    targets: string[];
    /**
     * Id of the Contribution Type
     */
    type: string;
}
/**
 * Base class shared by contributions and contribution types
 */
export interface ContributionBase {
    /**
     * Description of the contribution/type
     */
    description: string;
    /**
     * Fully qualified identifier of the contribution/type
     */
    id: string;
    /**
     * VisibleTo can be used to restrict whom can reference a given contribution/type. This value should be a list of publishers or extensions access is restricted too.  Examples: "ms" - Means only the "ms" publisher can reference this. "ms.vss-web" - Means only the "vss-web" extension from the "ms" publisher can reference this.
     */
    visibleTo: string[];
}
/**
 * Specifies a constraint that can be used to dynamically include/exclude a given contribution
 */
export interface ContributionConstraint {
    /**
     * An optional property that can be specified to group constraints together. All constraints within a group are AND'd together (all must be evaluate to True in order for the contribution to be included). Different groups of constraints are OR'd (only one group needs to evaluate to True for the contribution to be included).
     */
    group: number;
    /**
     * Fully qualified identifier of a shared constraint
     */
    id: string;
    /**
     * If true, negate the result of the filter (include the contribution if the applied filter returns false instead of true)
     */
    inverse: boolean;
    /**
     * Name of the IContributionFilter plugin
     */
    name: string;
    /**
     * Properties that are fed to the contribution filter class
     */
    properties: any;
    /**
     * Constraints can be optionally be applied to one or more of the relationships defined in the contribution. If no relationships are defined then all relationships are associated with the constraint. This means the default behaviour will elimiate the contribution from the tree completely if the constraint is applied.
     */
    relationships: string[];
}
/**
 * Represents different ways of including contributions based on licensing
 */
export enum ContributionLicensingBehaviorType {
    /**
     * Default value - only include the contribution if the user is licensed for the extension
     */
    OnlyIfLicensed = 0,
    /**
     * Only include the contribution if the user is NOT licensed for the extension
     */
    OnlyIfUnlicensed = 1,
    /**
     * Always include the contribution regardless of whether or not the user is licensed for the extension
     */
    AlwaysInclude = 2
}
/**
 * A query that can be issued for contribution nodes
 */
export interface ContributionNodeQuery {
    /**
     * The contribution ids of the nodes to find.
     */
    contributionIds: string[];
    /**
     * Contextual information that can be leveraged by contribution constraints
     */
    dataProviderContext: DataProviderContext;
    /**
     * Indicator if contribution provider details should be included in the result.
     */
    includeProviderDetails: boolean;
    /**
     * Query options tpo be used when fetching ContributionNodes
     */
    queryOptions: ContributionQueryOptions;
}
/**
 * Result of a contribution node query.  Wraps the resulting contribution nodes and provider details.
 */
export interface ContributionNodeQueryResult {
    /**
     * Map of contribution ids to corresponding node.
     */
    nodes: {
        [key: string]: ClientContributionNode;
    };
    /**
     * Map of provder ids to the corresponding provider details object.
     */
    providerDetails: {
        [key: string]: ClientContributionProviderDetails;
    };
}
/**
 * Description about a property of a contribution type
 */
export interface ContributionPropertyDescription {
    /**
     * Description of the property
     */
    description: string;
    /**
     * Name of the property
     */
    name: string;
    /**
     * True if this property is required
     */
    required: boolean;
    /**
     * The type of value used for this property
     */
    type: ContributionPropertyType;
}
/**
 * The type of value used for a property
 */
export enum ContributionPropertyType {
    /**
     * Contribution type is unknown (value may be anything)
     */
    Unknown = 0,
    /**
     * Value is a string
     */
    String = 1,
    /**
     * Value is a Uri
     */
    Uri = 2,
    /**
     * Value is a GUID
     */
    Guid = 4,
    /**
     * Value is True or False
     */
    Boolean = 8,
    /**
     * Value is an integer
     */
    Integer = 16,
    /**
     * Value is a double
     */
    Double = 32,
    /**
     * Value is a DateTime object
     */
    DateTime = 64,
    /**
     * Value is a generic Dictionary/JObject/property bag
     */
    Dictionary = 128,
    /**
     * Value is an array
     */
    Array = 256,
    /**
     * Value is an arbitrary/custom object
     */
    Object = 512
}
export interface ContributionProviderDetails {
    /**
     * Friendly name for the provider.
     */
    displayName: string;
    /**
     * Unique identifier for this provider. The provider name can be used to cache the contribution data and refer back to it when looking for changes
     */
    name: string;
    /**
     * Properties associated with the provider
     */
    properties: {
        [key: string]: string;
    };
    /**
     * Version of contributions assoicated with this contribution provider.
     */
    version: string;
}
/**
 * Options that control the contributions to include in a query
 */
export enum ContributionQueryOptions {
    None = 0,
    /**
     * Include the direct contributions that have the ids queried.
     */
    IncludeSelf = 16,
    /**
     * Include the contributions that directly target the contributions queried.
     */
    IncludeChildren = 32,
    /**
     * Include the contributions from the entire sub-tree targetting the contributions queried.
     */
    IncludeSubTree = 96,
    /**
     * Include the contribution being queried as well as all contributions that target them recursively.
     */
    IncludeAll = 112,
    /**
     * Some callers may want the entire tree back without constraint evaluation being performed.
     */
    IgnoreConstraints = 256
}
/**
 * A contribution type, given by a json schema
 */
export interface ContributionType extends ContributionBase {
    /**
     * Controls whether or not contributions of this type have the type indexed for queries. This allows clients to find all extensions that have a contribution of this type.  NOTE: Only TrustedPartners are allowed to specify indexed contribution types.
     */
    indexed: boolean;
    /**
     * Friendly name of the contribution/type
     */
    name: string;
    /**
     * Describes the allowed properties for this contribution type
     */
    properties: {
        [key: string]: ContributionPropertyDescription;
    };
}
/**
 * Contextual information that data providers can examine when populating their data
 */
export interface DataProviderContext {
    /**
     * Generic property bag that contains context-specific properties that data providers can use when populating their data dictionary
     */
    properties: {
        [key: string]: any;
    };
}
export interface DataProviderExceptionDetails {
    /**
     * The type of the exception that was thrown.
     */
    exceptionType: string;
    /**
     * Message that is associated with the exception.
     */
    message: string;
    /**
     * The StackTrace from the exception turned into a string.
     */
    stackTrace: string;
}
/**
 * A query that can be issued for data provider data
 */
export interface DataProviderQuery {
    /**
     * Contextual information to pass to the data providers
     */
    context: DataProviderContext;
    /**
     * The contribution ids of the data providers to resolve
     */
    contributionIds: string[];
}
/**
 * Result structure from calls to GetDataProviderData
 */
export interface DataProviderResult {
    /**
     * This is the set of data providers that were requested, but either they were defined as client providers, or as remote providers that failed and may be retried by the client.
     */
    clientProviders: {
        [key: string]: ClientDataProviderQuery;
    };
    /**
     * Property bag of data keyed off of the data provider contribution id
     */
    data: {
        [key: string]: any;
    };
    /**
     * Set of exceptions that occurred resolving the data providers.
     */
    exceptions: {
        [key: string]: DataProviderExceptionDetails;
    };
    /**
     * List of data providers resolved in the data-provider query
     */
    resolvedProviders: ResolvedDataProvider[];
    /**
     * Scope name applied to this data provider result.
     */
    scopeName: string;
    /**
     * Scope value applied to this data provider result.
     */
    scopeValue: string;
    /**
     * Property bag of shared data that was contributed to by any of the individual data providers
     */
    sharedData: {
        [key: string]: any;
    };
}
/**
 * Data bag that any data provider can contribute to. This shared dictionary is returned in the data provider result.
 */
export interface DataProviderSharedData {
}
/**
 * Contract for handling the extension acquisition process
 */
export interface ExtensionAcquisitionRequest {
    /**
     * How the item is being assigned
     */
    assignmentType: AcquisitionAssignmentType;
    /**
     * The id of the subscription used for purchase
     */
    billingId: string;
    /**
     * The marketplace id (publisherName.extensionName) for the item
     */
    itemId: string;
    /**
     * The type of operation, such as install, request, purchase
     */
    operationType: AcquisitionOperationType;
    /**
     * Additional properties which can be added to the request.
     */
    properties: any;
    /**
     * How many licenses should be purchased
     */
    quantity: number;
}
/**
 * Audit log for an extension
 */
export interface ExtensionAuditLog {
    /**
     * Collection of audit log entries
     */
    entries: ExtensionAuditLogEntry[];
    /**
     * Extension that the change was made for
     */
    extensionName: string;
    /**
     * Publisher that the extension is part of
     */
    publisherName: string;
}
/**
 * An audit log entry for an extension
 */
export interface ExtensionAuditLogEntry {
    /**
     * Change that was made to extension
     */
    auditAction: string;
    /**
     * Date at which the change was made
     */
    auditDate: Date;
    /**
     * Extra information about the change
     */
    comment: string;
    /**
     * Represents the user who made the change
     */
    updatedBy: VSS_Common_Contracts.IdentityRef;
}
export interface ExtensionAuthorization {
    id: string;
    scopes: string[];
}
/**
 * Represents a single collection for extension data documents
 */
export interface ExtensionDataCollection {
    /**
     * The name of the collection
     */
    collectionName: string;
    /**
     * A list of documents belonging to the collection
     */
    documents: any[];
    /**
     * The type of the collection's scope, such as Default or User
     */
    scopeType: string;
    /**
     * The value of the collection's scope, such as Current or Me
     */
    scopeValue: string;
}
/**
 * Represents a query to receive a set of extension data collections
 */
export interface ExtensionDataCollectionQuery {
    /**
     * A list of collections to query
     */
    collections: ExtensionDataCollection[];
}
export interface ExtensionEvent {
    /**
     * The extension which has been updated
     */
    extension: VSS_Gallery_Contracts.PublishedExtension;
    /**
     * The current version of the extension that was updated
     */
    extensionVersion: string;
    /**
     * Name of the collection for which the extension was requested
     */
    host: ExtensionHost;
    /**
     * Gallery host url
     */
    links: ExtensionEventUrls;
    /**
     * Represents the user who initiated the update
     */
    modifiedBy: VSS_Common_Contracts.IdentityRef;
    /**
     * The type of update that was made
     */
    updateType: ExtensionUpdateType;
}
/**
 * Base class for an event callback for an extension
 */
export interface ExtensionEventCallback {
    /**
     * The uri of the endpoint that is hit when an event occurs
     */
    uri: string;
}
/**
 * Collection of event callbacks - endpoints called when particular extension events occur.
 */
export interface ExtensionEventCallbackCollection {
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension disable has occurred.
     */
    postDisable: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension enable has occurred.
     */
    postEnable: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install has completed.
     */
    postInstall: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension uninstall has occurred.
     */
    postUninstall: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension update has occurred.
     */
    postUpdate: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install is about to occur.  Response indicates whether to proceed or abort.
     */
    preInstall: ExtensionEventCallback;
    /**
     * For multi-version extensions, defines an endpoint that gets called via an OPTIONS request to determine the particular version of the extension to be used
     */
    versionCheck: ExtensionEventCallback;
}
export interface ExtensionEventUrls extends ExtensionUrls {
    /**
     * Url of the extension management page
     */
    manageExtensionsPage: string;
}
/**
 * Set of flags applied to extensions that are relevant to contribution consumers
 */
export enum ExtensionFlags {
    /**
     * A built-in extension is installed for all VSTS accounts by default
     */
    BuiltIn = 1,
    /**
     * The extension comes from a fully-trusted publisher
     */
    Trusted = 2
}
export interface ExtensionHost {
    id: string;
    name: string;
}
/**
 * How an extension should handle including contributions based on licensing
 */
export interface ExtensionLicensing {
    /**
     * A list of contributions which deviate from the default licensing behavior
     */
    overrides: LicensingOverride[];
}
/**
 * Base class for extension properties which are shared by the extension manifest and the extension model
 */
export interface ExtensionManifest {
    /**
     * Uri used as base for other relative uri's defined in extension
     */
    baseUri: string;
    /**
     * List of shared constraints defined by this extension
     */
    constraints: ContributionConstraint[];
    /**
     * List of contributions made by this extension
     */
    contributions: Contribution[];
    /**
     * List of contribution types defined by this extension
     */
    contributionTypes: ContributionType[];
    /**
     * List of explicit demands required by this extension
     */
    demands: string[];
    /**
     * Collection of endpoints that get called when particular extension events occur
     */
    eventCallbacks: ExtensionEventCallbackCollection;
    /**
     * Secondary location that can be used as base for other relative uri's defined in extension
     */
    fallbackBaseUri: string;
    /**
     * Language Culture Name set by the Gallery
     */
    language: string;
    /**
     * How this extension behaves with respect to licensing
     */
    licensing: ExtensionLicensing;
    /**
     * Version of the extension manifest format/content
     */
    manifestVersion: number;
    /**
     * Default user claims applied to all contributions (except the ones which have been speficied restrictedTo explicitly) to control the visibility of a contribution.
     */
    restrictedTo: string[];
    /**
     * List of all oauth scopes required by this extension
     */
    scopes: string[];
    /**
     * The ServiceInstanceType(Guid) of the VSTS service that must be available to an account in order for the extension to be installed
     */
    serviceInstanceType: string;
}
/**
 * A request for an extension (to be installed or have a license assigned)
 */
export interface ExtensionRequest {
    /**
     * Required message supplied if the request is rejected
     */
    rejectMessage: string;
    /**
     * Date at which the request was made
     */
    requestDate: Date;
    /**
     * Represents the user who made the request
     */
    requestedBy: VSS_Common_Contracts.IdentityRef;
    /**
     * Optional message supplied by the requester justifying the request
     */
    requestMessage: string;
    /**
     * Represents the state of the request
     */
    requestState: ExtensionRequestState;
    /**
     * Date at which the request was resolved
     */
    resolveDate: Date;
    /**
     * Represents the user who resolved the request
     */
    resolvedBy: VSS_Common_Contracts.IdentityRef;
}
export interface ExtensionRequestEvent {
    /**
     * The extension which has been requested
     */
    extension: VSS_Gallery_Contracts.PublishedExtension;
    /**
     * Information about the host for which this extension is requested
     */
    host: ExtensionHost;
    /**
     * Name of the collection for which the extension was requested
     */
    hostName: string;
    /**
     * Gallery host url
     */
    links: ExtensionRequestUrls;
    /**
     * The extension request object
     */
    request: ExtensionRequest;
    /**
     * The type of update that was made
     */
    updateType: ExtensionRequestUpdateType;
}
export interface ExtensionRequestsEvent {
    /**
     * The extension which has been requested
     */
    extension: VSS_Gallery_Contracts.PublishedExtension;
    /**
     * Information about the host for which this extension is requested
     */
    host: ExtensionHost;
    /**
     * Gallery host url
     */
    links: ExtensionRequestUrls;
    /**
     * The extension request object
     */
    requests: ExtensionRequest[];
    /**
     * The type of update that was made
     */
    updateType: ExtensionRequestUpdateType;
}
/**
 * Represents the state of an extension request
 */
export enum ExtensionRequestState {
    /**
     * The request has been opened, but not yet responded to
     */
    Open = 0,
    /**
     * The request was accepted (extension installed or license assigned)
     */
    Accepted = 1,
    /**
     * The request was rejected (extension not installed or license not assigned)
     */
    Rejected = 2
}
export enum ExtensionRequestUpdateType {
    Created = 1,
    Approved = 2,
    Rejected = 3,
    Deleted = 4
}
export interface ExtensionRequestUrls extends ExtensionUrls {
    /**
     * Link to view the extension request
     */
    requestPage: string;
}
/**
 * The state of an extension
 */
export interface ExtensionState extends InstalledExtensionState {
    extensionName: string;
    /**
     * The time at which the version was last checked
     */
    lastVersionCheck: Date;
    publisherName: string;
    version: string;
}
/**
 * States of an extension Note:  If you add value to this enum, you need to do 2 other things.  First add the back compat enum in value src\Vssf\Sdk\Server\Contributions\InstalledExtensionMessage.cs.  Second, you can not send the new value on the message bus.  You need to remove it from the message bus event prior to being sent.
 */
export enum ExtensionStateFlags {
    /**
     * No flags set
     */
    None = 0,
    /**
     * Extension is disabled
     */
    Disabled = 1,
    /**
     * Extension is a built in
     */
    BuiltIn = 2,
    /**
     * Extension has multiple versions
     */
    MultiVersion = 4,
    /**
     * Extension is not installed.  This is for builtin extensions only and can not otherwise be set.
     */
    UnInstalled = 8,
    /**
     * Error performing version check
     */
    VersionCheckError = 16,
    /**
     * Trusted extensions are ones that are given special capabilities. These tend to come from Microsoft and can't be published by the general public.  Note: BuiltIn extensions are always trusted.
     */
    Trusted = 32,
    /**
     * Extension is currently in an error state
     */
    Error = 64,
    /**
     * Extension scopes have changed and the extension requires re-authorization
     */
    NeedsReauthorization = 128,
    /**
     * Error performing auto-upgrade. For example, if the new version has demands not supported the extension cannot be auto-upgraded.
     */
    AutoUpgradeError = 256,
    /**
     * Extension is currently in a warning state, that can cause a degraded experience. The degraded experience can be caused for example by some installation issues detected such as implicit demands not supported.
     */
    Warning = 512
}
export enum ExtensionUpdateType {
    Installed = 1,
    Uninstalled = 2,
    Enabled = 3,
    Disabled = 4,
    VersionUpdated = 5,
    ActionRequired = 6,
    ActionResolved = 7
}
export interface ExtensionUrls {
    /**
     * Url of the extension icon
     */
    extensionIcon: string;
    /**
     * Link to view the extension details page
     */
    extensionPage: string;
}
/**
 * Represents a VSTS extension along with its installation state
 */
export interface InstalledExtension extends ExtensionManifest {
    /**
     * The friendly extension id for this extension - unique for a given publisher.
     */
    extensionId: string;
    /**
     * The display name of the extension.
     */
    extensionName: string;
    /**
     * This is the set of files available from the extension.
     */
    files: VSS_Gallery_Contracts.ExtensionFile[];
    /**
     * Extension flags relevant to contribution consumers
     */
    flags: ExtensionFlags;
    /**
     * Information about this particular installation of the extension
     */
    installState: InstalledExtensionState;
    /**
     * This represents the date/time the extensions was last updated in the gallery. This doesnt mean this version was updated the value represents changes to any and all versions of the extension.
     */
    lastPublished: Date;
    /**
     * Unique id of the publisher of this extension
     */
    publisherId: string;
    /**
     * The display name of the publisher
     */
    publisherName: string;
    /**
     * Unique id for this extension (the same id is used for all versions of a single extension)
     */
    registrationId: string;
    /**
     * Version of this extension
     */
    version: string;
}
export interface InstalledExtensionQuery {
    assetTypes: string[];
    monikers: VSS_Gallery_Contracts.ExtensionIdentifier[];
}
/**
 * The state of an installed extension
 */
export interface InstalledExtensionState {
    /**
     * States of an installed extension
     */
    flags: ExtensionStateFlags;
    /**
     * List of installation issues
     */
    installationIssues: InstalledExtensionStateIssue[];
    /**
     * The time at which this installation was last updated
     */
    lastUpdated: Date;
}
/**
 * Represents an installation issue
 */
export interface InstalledExtensionStateIssue {
    /**
     * The error message
     */
    message: string;
    /**
     * Source of the installation issue, for example  "Demands"
     */
    source: string;
    /**
     * Installation issue type (Warning, Error)
     */
    type: InstalledExtensionStateIssueType;
}
/**
 * Installation issue type (Warning, Error)
 */
export enum InstalledExtensionStateIssueType {
    /**
     * Represents an installation warning, for example an implicit demand not supported
     */
    Warning = 0,
    /**
     * Represents an installation error, for example an explicit demand not supported
     */
    Error = 1
}
/**
 * Maps a contribution to a licensing behavior
 */
export interface LicensingOverride {
    /**
     * How the inclusion of this contribution should change based on licensing
     */
    behavior: ContributionLicensingBehaviorType;
    /**
     * Fully qualified contribution id which we want to define licensing behavior for
     */
    id: string;
}
/**
 * A request for an extension (to be installed or have a license assigned)
 */
export interface RequestedExtension {
    /**
     * The unique name of the extension
     */
    extensionName: string;
    /**
     * A list of each request for the extension
     */
    extensionRequests: ExtensionRequest[];
    /**
     * DisplayName of the publisher that owns the extension being published.
     */
    publisherDisplayName: string;
    /**
     * Represents the Publisher of the requested extension
     */
    publisherName: string;
    /**
     * The total number of requests for an extension
     */
    requestCount: number;
}
/**
 * Entry for a specific data provider's resulting data
 */
export interface ResolvedDataProvider {
    /**
     * The total time the data provider took to resolve its data (in milliseconds)
     */
    duration: number;
    error: string;
    id: string;
}
export interface Scope {
    description: string;
    title: string;
    value: string;
}
/**
 * Information about the extension
 */
export interface SupportedExtension {
    /**
     * Unique Identifier for this extension
     */
    extension: string;
    /**
     * Unique Identifier for this publisher
     */
    publisher: string;
    /**
     * Supported version for this extension
     */
    version: string;
}
export var TypeInfo: {
    AcquisitionAssignmentType: {
        enumValues: {
            "none": number;
            "me": number;
            "all": number;
        };
    };
    AcquisitionOperation: any;
    AcquisitionOperationState: {
        enumValues: {
            "disallow": number;
            "allow": number;
            "completed": number;
        };
    };
    AcquisitionOperationType: {
        enumValues: {
            "get": number;
            "install": number;
            "buy": number;
            "try": number;
            "request": number;
            "none": number;
            "purchaseRequest": number;
        };
    };
    AcquisitionOptions: any;
    ContributionLicensingBehaviorType: {
        enumValues: {
            "onlyIfLicensed": number;
            "onlyIfUnlicensed": number;
            "alwaysInclude": number;
        };
    };
    ContributionNodeQuery: any;
    ContributionPropertyDescription: any;
    ContributionPropertyType: {
        enumValues: {
            "unknown": number;
            "string": number;
            "uri": number;
            "guid": number;
            "boolean": number;
            "integer": number;
            "double": number;
            "dateTime": number;
            "dictionary": number;
            "array": number;
            "object": number;
        };
    };
    ContributionQueryOptions: {
        enumValues: {
            "none": number;
            "includeSelf": number;
            "includeChildren": number;
            "includeSubTree": number;
            "includeAll": number;
            "ignoreConstraints": number;
        };
    };
    ContributionType: any;
    ExtensionAcquisitionRequest: any;
    ExtensionAuditLog: any;
    ExtensionAuditLogEntry: any;
    ExtensionEvent: any;
    ExtensionFlags: {
        enumValues: {
            "builtIn": number;
            "trusted": number;
        };
    };
    ExtensionLicensing: any;
    ExtensionManifest: any;
    ExtensionRequest: any;
    ExtensionRequestEvent: any;
    ExtensionRequestsEvent: any;
    ExtensionRequestState: {
        enumValues: {
            "open": number;
            "accepted": number;
            "rejected": number;
        };
    };
    ExtensionRequestUpdateType: {
        enumValues: {
            "created": number;
            "approved": number;
            "rejected": number;
            "deleted": number;
        };
    };
    ExtensionState: any;
    ExtensionStateFlags: {
        enumValues: {
            "none": number;
            "disabled": number;
            "builtIn": number;
            "multiVersion": number;
            "unInstalled": number;
            "versionCheckError": number;
            "trusted": number;
            "error": number;
            "needsReauthorization": number;
            "autoUpgradeError": number;
            "warning": number;
        };
    };
    ExtensionUpdateType: {
        enumValues: {
            "installed": number;
            "uninstalled": number;
            "enabled": number;
            "disabled": number;
            "versionUpdated": number;
            "actionRequired": number;
            "actionResolved": number;
        };
    };
    InstalledExtension: any;
    InstalledExtensionState: any;
    InstalledExtensionStateIssue: any;
    InstalledExtensionStateIssueType: {
        enumValues: {
            "warning": number;
            "error": number;
        };
    };
    LicensingOverride: any;
    RequestedExtension: any;
};
}
declare module "VSS/Contributions/Controls" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Contributions_Contracts = require("VSS/Contributions/Contracts");
/**
* Common interface between internal and external contribution hosts
*/
export interface IExtensionHost {
    /**
    * Get an instance of a registered object in an extension
    *
    * @param instanceId Id of the instance to get
    * @param contextData Optional data to pass to the extension for it to use when creating the instance
    * @return Promise that is resolved to the instance (or a proxy object that talks to the instance in the iframe case)
    */
    getRegisteredInstance<T>(instanceId: string, contextData?: any): IPromise<T>;
    /**
    * Gets the promise that is resolved when the host is loaded, and rejected when the load fails or times out.
    */
    getLoadPromise(): IPromise<any>;
    /**
    * Dispose the host control
    */
    dispose(): void;
}
/** The resize options for a contribution host */
export enum ResizeOptions {
    /**
     * Default resize option which means both height and width resizing are allowed
     */
    Default = 0,
    /**
     * The height of the host cannot be changed
     */
    FixedHeight = 2,
    /**
     * The width of the host cannot be changed
     */
    FixedWidth = 4
}
/**
* Options for the host control to toggle progress indication or error/warning handling.
*/
export interface IContributionHostBehavior {
    /**
    * Show the loading indicator for the extension. Defaults to true if unspecified.
    */
    showLoadingIndicator?: boolean;
    /**
    * Show the error indicator for the extension. Defaults to true if unspecified.
    */
    showErrorIndicator?: boolean;
    /**
    * Time to wait in milliseconds (ms) before the slow warning indicator for the extension is displayed.
    * If unspecified, The default timeout period is used.
    */
    slowWarningDurationMs?: number;
    /**
    * Time to wait in milliseconds (ms) before erroring when waiting for loaded event handshake
    * If unspecified, the default timeout period is used.
    */
    maxHandshakeDurationMs?: number;
    /**
     * The resize options for the host. By default both height and width and be resized but this can be changed to only allow one direction of resizing
     */
    resizeOptions?: ResizeOptions;
    callbacks?: IContributionHostBehaviorCallbacks;
}
export interface IContributionHostBehaviorCallbacks {
    success(): void;
    failure(message?: string): void;
    slow(): void;
}
/**
 * Contains the new width and height of the contribution host after it is resized
 */
export interface IExternalContentHostResizedEventArgs {
    width: number;
    height: number;
    host: IExtensionHost;
}
export module ExternalContentHostEvents {
    var SLOW_LOAD_WARNING: string;
    var EXTENSION_MESSAGE_RESIZED: string;
    var EXTENSION_HOST_RESIZED: string;
}
/**
* Instantiate a contributed control through an internal or external contribution host.
*
* @param $container The jQuery element to place the control in
* @param contribution The contribution (or its id) which contains the details of the contributed control
* @param initialConfig Initial configuration/options to pass to the control
* @param webContext The web context to use when fetching contributions and resolving uris
* @param instanceId Id of the registered object in the contribution's host
* @param contributionHostBehavior options for the host control to toggle behavior on progress indication and error/warning handling.
* @return Proxied instance of the control
*/
export function createContributedControl<T>($container: JQuery, contribution: Contributions_Contracts.Contribution | string, initialConfig?: any, webContext?: Contracts_Platform.WebContext, instanceId?: string, contributionHostBehavior?: IContributionHostBehavior): IPromise<T>;
/**
* Instantiate a contributed control through an internal or external contribution host.
*
* @param $container The jQuery element to place the control in
* @param contributionId The contribution (or its id) which contains the details of the contributed control
* @param initialConfig Initial configuration/options to pass to the control
* @param webContext The web context to use when fetching contributions and resolving uris
* @param postContent Optional data to post to the contribution url (if not specified, a GET is performed)
* @param uriReplacementProperties Replacement object to use when resolving the content uri
* @param uriPropertyName Name of the uri property to lookup in the contribution's properties
* @param iframeFirstPartyContent: Set to true if the content should be iframed, even if it is first-party content.
* @param contributionHostBehavior options for the host control to toggle behavior on progress indication and error/warning handling.
* @return IExtensionHost
*/
export function createExtensionHost($container: JQuery, contribution: Contributions_Contracts.Contribution | string, initialConfig?: any, webContext?: Contracts_Platform.WebContext, postContent?: any, uriReplacementProperties?: any, uriPropertyName?: string, iframeFirstPartyContent?: boolean, contributionHostBehavior?: IContributionHostBehavior): IPromise<IExtensionHost>;
/**
* Instantiate a contributed control through an internal or external contribution host.
*
* @param $container The jQuery element to place the control in
* @param uri The uri of the contribution content
* @param contribution The contribution which contains the details of the contributed control
* @param initialConfig Initial configuration/options to pass to the control
* @param postContent: Optional data to post to the contribution url (if not specified, a GET is performed)
* @param iframeFirstPartyContent: Set to true if the content should be iframed, even if it is first-party content.
* @param contributionHostBehavior options for the host control to toggle behavior on progress indication and error/warning handling.
* @return IExtensionHost
*/
export function createExtensionHostForContribution($container: JQuery, uri: string, contribution: Contributions_Contracts.Contribution, initialConfig?: any, postContent?: any, iframeFirstPartyContent?: boolean, contributionHostBehavior?: IContributionHostBehavior, fallbackUri?: string): IExtensionHost;
/**
* Instantiate a contributed background host (no UI) through an internal or external contribution host.
*
* @param contribution The contribution (or full id of the contribution) which contains the details of the contributed control
* @param webContext The web context to use when fetching contributions and resolving uris
* @param uriReplacementProperties Replacement object to use when resolving the content uri
* @param uriPropertyName Name of the uri property to lookup in the contribution's properties
* @return IExtensionHost
*/
export function getBackgroundHost(contribution: Contributions_Contracts.Contribution | string, webContext?: Contracts_Platform.WebContext, uriReplacementProperties?: any, uriPropertyName?: string): IPromise<IExtensionHost>;
/**
* Instantiate a registered background/service instance (no UI) through an internal or external contribution host.
*
* @param contribution The contribution (or full id of the contribution) which contains the details of the contributed control
* @param instanceId Id of the registered object in the contribution's host
* @param contextData Context data/options to pass to the registered object factory method
* @param webContext The web context to use when fetching contributions and resolving uris
* @param timeout Timeout in milliseconds for the instance creation
* @param timeoutMessage Message to reject the promise with if the fetch times out
* @param uriReplacementProperties Replacement object to use when resolving the content uri
* @param uriPropertyName Name of the uri property to lookup in the contribution's properties
* @return IExtensionHost
*/
export function getBackgroundInstance<T>(contribution: Contributions_Contracts.Contribution | string, instanceId: string, contextData?: any, webContext?: Contracts_Platform.WebContext, timeout?: number, timeoutMessage?: string, uriReplacementProperties?: any, uriPropertyName?: string): IPromise<T>;
}
declare module "VSS/Contributions/LocalPageData" {
import Contributions_Contracts = require("VSS/Contributions/Contracts");
import Serialization = require("VSS/Serialization");
/**
 * Gets the scope name and value of the data providers loaded by the page initially.
 */
export function getDataProviderScope(): {
    name?: string;
    value?: string;
};
/**
 * Gets the current data provider results
 */
export function getDataProviderResults(): Contributions_Contracts.DataProviderResult;
/**
 * Clears the data provider results
 */
export function clearDataProviderResults(): void;
/**
 * Resets the data provider results to their initial state from JSON island data
 */
export function resetDataProviderResults(): Contributions_Contracts.DataProviderResult;
/**
 * Resets the data provider result object to the specified result
 *
 * @param result Data provider result
 */
export function addDataProviderResults(result: Contributions_Contracts.DataProviderResult): void;
/**
 * Gets the contributed data for the specified contribution
 *
 * @param contributionId Full id of the data provider contribution
 * @param contractMetadata Optional contract metdata to use when deserializing the result
 */
export function getData<T>(contributionId: string, contractMetadata?: Serialization.ContractMetadata): T;
/**
 * Sets the data provider data for the given data provider contribution
 *
 * @param contributionId Id of the data provider contribution
 * @param data Data provider result
 */
export function overrideData(contributionId: string, data: any): void;
/**
 * Clears results for a given data provider contribution.
 *
 * @param contributionId Id of the data provider contribution
 */
export function removeData(contributionId: string): void;
/**
 * Gets the shared contributed data for the given key
 *
 * @param sharedDataKey Shared data key
 * @param contractMetadata Optional contract metdata to use when deserializing the result
 */
export function getSharedData<T>(sharedDataKey: string, contractMetadata?: Serialization.ContractMetadata): T;
}
declare module "VSS/Contributions/PageEvents" {
export {};
}
declare module "VSS/Contributions/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   extensionmanagement\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Contributions_Contracts = require("VSS/Contributions/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected installedAppsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string[]} contributionIds
     * @param {boolean} includeDisabledApps
     * @param {string[]} assetTypes
     * @return IPromise<VSS_Contributions_Contracts.InstalledExtension[]>
     */
    getInstalledExtensions(contributionIds?: string[], includeDisabledApps?: boolean, assetTypes?: string[]): IPromise<VSS_Contributions_Contracts.InstalledExtension[]>;
}
export class CommonMethods2_1To5 extends CommonMethods2To5 {
    protected installedAppsApiVersion_3e2f6668: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string[]} assetTypes
     * @return IPromise<VSS_Contributions_Contracts.InstalledExtension>
     */
    getInstalledExtensionByName(publisherName: string, extensionName: string, assetTypes?: string[]): IPromise<VSS_Contributions_Contracts.InstalledExtension>;
}
export class CommonMethods2_2To5 extends CommonMethods2_1To5 {
    protected dataProvidersQueryApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {VSS_Contributions_Contracts.DataProviderQuery} query
     * @param {string} scopeName
     * @param {string} scopeValue
     * @return IPromise<VSS_Contributions_Contracts.DataProviderResult>
     */
    queryDataProviders(query: VSS_Contributions_Contracts.DataProviderQuery, scopeName?: string, scopeValue?: string): IPromise<VSS_Contributions_Contracts.DataProviderResult>;
}
export class CommonMethods3_1To5 extends CommonMethods2_2To5 {
    protected contributionNodeQueryApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Query for contribution nodes and provider details according the parameters in the passed in query object.
     *
     * @param {VSS_Contributions_Contracts.ContributionNodeQuery} query
     * @return IPromise<VSS_Contributions_Contracts.ContributionNodeQueryResult>
     */
    queryContributionNodes(query: VSS_Contributions_Contracts.ContributionNodeQuery): IPromise<VSS_Contributions_Contracts.ContributionNodeQueryResult>;
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient5 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient4_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient4 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient3_2 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient3_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient2_3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient2_2 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient2_1 extends CommonMethods2_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ContributionsHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class ContributionsHttpClient extends ContributionsHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return ContributionsHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): ContributionsHttpClient4_1;
}
declare module "VSS/Contributions/Services" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Contributions_Contracts = require("VSS/Contributions/Contracts");
import Serialization = require("VSS/Serialization");
import Service = require("VSS/Service");
export module CustomerIntelligenceConstants {
    var CONTRIBUTIONS_AREA: string;
    var CONTRIBUTIONS_USAGE_FEATURE: string;
    var CONTRIBUTIONS_ACTION: string;
    var CONTRIBUTIONS_ACTION_EXECUTE: string;
}
export module ContributionReservedProperties {
    var ServiceInstanceTypeProperty: string;
    var AttributesProperty: string;
    var BaseUriProperty: string;
    var FallbackBaseUriProperty: string;
    var VersionProperty: string;
    var RegistrationIdProperty: string;
}
export enum ContributionReservedAttributeValue {
    BuiltIn = 1,
    MultiVersion = 2,
    Paid = 4,
    Preview = 8,
    Public = 16,
    System = 32,
    Trusted = 64
}
/**
* Information about an individual contribution that contributes one or more services registered by id.
*/
export interface IServiceContribution extends Contributions_Contracts.Contribution {
    /**
    * Get the instance of an object registered by this contribution
    *
    * @param objectId Id of the registered object (defaults to the id property of the contribution)
    * @param context Optional context to use when getting the object.
    */
    getInstance<T>(objectId?: string, context?: any): IPromise<T>;
}
/**
* Optional flags for querying contributions
*/
export enum ContributionQueryOptions {
    IncludeRoot = 1,
    IncludeDirectTargets = 2,
    IncludeRecursiveTargets = 4,
    IncludeAll = 7,
    /**
    * This flag indicates to only query contributions that are already cached by the local service - through
    * the contributions sent down in the page via JSON island data, or already fetched by a REST request. No
    * REST call will be made when this flag is specified.
    */
    LocalOnly = 8
}
/**
* Method used to filter contributions as part of a contribution query call
*/
export interface ContributionQueryCallback {
    (contribution: Contributions_Contracts.Contribution): ContributionQueryCallbackResult;
}
export enum ContributionQueryCallbackResult {
    None = 0,
    Include = 1,
    Recurse = 2,
    IncludeAndRecurse = 3
}
/**
 * Manages all RegisteredExtension instances and their contributions.
 */
export class ExtensionService extends Service.VssService {
    private static _testExecutionFeatureFlag;
    private _webPageDataService;
    private _contributionsById;
    private _contributionsByTargetId;
    private _targetsByUnresolvedContributionId;
    private _loadedContributionTargets;
    private _contributionQueryPromises;
    private _contributionProviderDetailsMap;
    /**
     * Private constructor - do not call.
     */
    constructor();
    /**
     * Clear out the cached contribution hierarchy
     */
    private _clearCachedContributionData;
    /**
     * Ensures the page's Json Island has been processed if web context is the default
     * Should be called by the Service factory.
     * @param connection Service.VssConnection
     */
    initializeConnection(connection: Service.VssConnection): void;
    /**
     * Register contributions
     * @param extension Contributions_Contracts.InstalledExtension The extension to register.
     */
    registerContributions(contributions: Contributions_Contracts.Contribution[]): void;
    /**
     * Get the contribution with the given id.
     *
     * @param id Full id of the contribution to fetch
     * @return IPromise<Contributions_Contracts.Contribution>
     */
    getContribution(id: string): IPromise<Contributions_Contracts.Contribution>;
    /**
     * Gets the contributions that target the given contribution ids
     *
     * @param targetIds Ids of the targeted contribution(s)
     * @param contributionType Optional type of contribution to filter by
     * @return IPromise<Contributions_Contracts.Contribution[]> Promise that is resolved when contributions are available.
     */
    getContributionsForTarget(targetId: string, contributionType?: string): IPromise<Contributions_Contracts.Contribution[]>;
    /**
     * Gets the **loaded** contributions that target the given contribution ids
     *
     * @param targetId Ids of the targeted contribution(s)
     * @param contributionType Optional type of contribution to filter by
     */
    getLoadedContributionsForTarget(targetId: string, contributionType?: string): Contributions_Contracts.Contribution[];
    /**
     * Gets the contributions that target the given contribution ids
     *
     * @param targetIds Ids of the targeted contribution(s)
     * @param contributionType Optional type of contribution to filter by
     * @return IPromise<Contributions_Contracts.Contribution[]> Promise that is resolved when contributions are available.
     */
    getContributionsForTargets(targetIds: string[], contributionType?: string): IPromise<Contributions_Contracts.Contribution[]>;
    /**
     * Gets contributions for the given contribution ids.
     *
     * @param ids Ids of the targeted contribution(s)
     * @param includeRootItems True to include the contributions with the specified ids
     * @param includeChildren True to include contributions that target the specified ids
     * @param recursive If true include targeting children recursively
     * @param contributionType Optional type of contribution to filter by
     * @return IPromise<Contributions_Contracts.Contribution[]> Promise that is resolved when contributions are available.
     */
    getContributions(ids: string[], includeRootItems: boolean, includeChildren: boolean, recursive?: boolean, contributionType?: string): IPromise<Contributions_Contracts.Contribution[]>;
    /**
     * Gets contributions for the given contribution ids.
     *
     * @param ids Ids of the targeted contribution(s)
     * @param queryOptions Contribution query options
     * @param contributionType Optional type of contribution to filter by
     * @param queryCallback Optional method to filter contributions by
     * @return IPromise<Contributions_Contracts.Contribution[]> Promise that is resolved when contributions are available.
     */
    queryContributions(ids: string[], queryOptions: ContributionQueryOptions, contributionType?: string, queryCallback?: ContributionQueryCallback): IPromise<Contributions_Contracts.Contribution[]>;
    /**
    * Determines whether or not the provided extension id is currently active - installed, licensed, and enabled.
    * @param extensionId The extension id (e.g. 'ms.vss-testmanager-web') to check
    */
    isExtensionActive(extensionId: string): IPromise<boolean>;
    private _getProviderIdentifier;
    private _getProviderDetails;
    /**
     * Get the specified provider property for this contribution.
     *
     * @param contribution The contribution whose provider property is being requested
     * @param propertyName The property being requested
     */
    getProviderProperty(contribution: Contributions_Contracts.Contribution, propertyName: string): string;
    /**
     * Get the version this contribution.
     *
     * @param contribution The contribution whose version is being requested
     */
    getProviderDisplayName(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the version this contribution.
     *
     * @param contribution The contribution whose version is being requested
     */
    getVersion(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the registrationId this contribution.
     *
     * @param contribution The contribution whose registration is being requested
     */
    getRegistrationId(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the baseUri this contribution.
     *
     * @param contribution The contribution whose baseUri is being requested
     */
    getBaseUri(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the fallbackUri this contribution.
     *
     * @param contribution The contribution whose fallbackUri is being requested
     */
    getFallbackUri(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the ServiceInstanceTypeProperty for this contribution.
     *
     * @param contribution The contribution whose fallbackUri is being requested
     */
    getServiceInstanceType(contribution: Contributions_Contracts.Contribution): string;
    private _resolveContributions;
    private _getUnqueriedContributions;
    private _getPendingLoadPromises;
    private _getLoadedContributions;
    private _fetchTargetingContributions;
    /**
     * Parse the extensions in the JSON island given by the selector
     * @param selector Selector to match a script tag containing JSON
     */
    private _processJsonIsland;
    /**
     * Register the given contributions with this service instance, avoiding an AJAX call for the specified contributions
     *
     * @param contributionData The contribution data to register
     * @param clearExisting If true, clear any existing contribution hierarchy. If false, add to it.
     */
    registerContributionData(contributionData: Contracts_Platform.ContributionsPageData, clearExisting?: boolean): void;
    /**
     * Register a target for the contribution
     * @param contribution
     * @param targetId
     */
    private _registerContributionTarget;
    private _registerContributionProviderDetails;
    /**
     * Get contributions of the specified type that have already been loaded and cached by this service.
     * This avoids a REST call to query contributions - only looking at contributions seeded on the page
     * via JSON island data or those already fetched by a prior REST call.
     *
     * @param contributionType The full id of the contribution type
     */
    getLoadedContributionsOfType(contributionType: string): IPromise<Contributions_Contracts.Contribution[]>;
}
/**
* Delegate for web page data resolution plugins. Allows plugins to be notified when
* web page data with a certain key is received
*/
export interface WebPageDataResolutionPlugin {
    /**
    * @param contributionId The contribution id of the data provider
    * @param value The new value of the data
    * @returns The value to store for this entry. undefined return value indicates to store the new value. Promises will be resolved before storing.
    */
    (contributionId: string, newValue: any): any;
}
/**
* An enum representing the way that a data provider's data was populated
*/
export enum WebPageDataSource {
    /**
    * The data provider entry came from JSON island data in the page source
    */
    JsonIsland = 0,
    /**
    * The data provider entry came from a REST call to resolve the provider
    */
    RestCall = 1,
    /**
    * The data provider entry was cached from localStorage
    */
    LocalStorage = 2
}
/**
 * Represents an error returned from a data provider resolved asynchronously
 */
export class WebPageDataProviderError extends Error {
    exceptionDetails: DataProviderExceptionDetails;
    constructor(message: string, exceptionDetails: DataProviderExceptionDetails);
}
/**
* Service for obtaining web page data from contributed data providers
*/
export class WebPageDataService extends Service.VssService {
    private static MAX_CACHE_SCOPES;
    private static _resolveDataPlugins;
    private _initializationPromise;
    private _localDataSource;
    private _resolvedProviders;
    private _contributionPromises;
    private _contributionIdsByDataType;
    private _dataProviderInitialized;
    private _ensureInitialized;
    /**
     * Register the given data provider data with this instance of the contribution service
     *
     * @param result Data provider result to merge-in
     * @param contributions Contributions to leverage when resolving provider data
     * @param clearExisting If true, clear any existing data providers. If false, add to it.
     */
    registerProviderData(result: Contributions_Contracts.DataProviderResult, contributions: Contributions_Contracts.Contribution[], clearExisting?: boolean): IPromise<any>;
    private _clearCachedDataProviders;
    private _handleDataProviderResult;
    private _storeDataProviderData;
    private _getLocalStorageCacheScope;
    private _getLocalStorageCacheEntry;
    private _isDataExpired;
    private _getCachedDataProviderValue;
    private _setCachedDataProviderValue;
    /**
    * Add a plugin handler that gets called when data with the given key has been sent from the server
    *
    * @param dataType The data type property as set in the data provider's contribution
    * @param handler Function called whenever data with the given key has been provided
    */
    static addResolutionPlugin(dataType: string, handler: WebPageDataResolutionPlugin): void;
    /**
    * Remove the plugin handler that gets called when data with the given key
    *
    * @param dataType The data type property as set in the data provider's contribution
    */
    static removeResolutionPlugin(dataType: string): void;
    /**
    * Get web page data that was contributed from the given contribution
    *
    * @param contributionId The data provider key
    * @param contractMetadata Optional contract metadata to use to deserialize the object
    */
    getPageData<T>(contributionId: string, contractMetadata?: Serialization.ContractMetadata): T;
    /**
    * Removes web page data that was contributed from the given contribution
    *
    * @param contributionId The data provider key
    */
    removePageData(contributionId: string): void;
    /**
     * Gets the source from which a data provider's data was populated (JSON island data, REST call, localStorage, etc.)
     *
     * @param key The data provider key (contribution id)
     */
    getPageDataSource(contributionId: string): WebPageDataSource;
    /**
     * Get the page data entries from all data provider contributions with the given dataType property.
     *
     * @param dataType Value of the dataType property in the data provider contribution's properties
     * @param contractMetadata Optional contract metadata to use to deserialize the returned values.
     */
    getPageDataByDataType<T>(dataType: string, contractMetadata?: Serialization.ContractMetadata): IDictionaryStringTo<T>;
    /**
     * getRemoteDataAsync is used to retrieve remote organization data via a data-provider through a promise.
     * This is to be used only to call a remote/cross org dataprovider.
     * @param contributionId The contributionId of the data provider.
     * @param dataProviderScope Remote data provider scope
     * @param authTokenManager Auth token manager for WebSessionTokens
     * @param serviceInstanceId Id of the service instance, the current one will be used if not given
     * @param requestParameters Parameters to use when fetching data.
     */
    getRemoteDataAsync<T>(contributionId: string, dataProviderScope: {
        name: string;
        value: string;
    }, authTokenManager: IAuthTokenManager<any>, serviceInstanceId?: string, requestParameters?: any): Promise<T | undefined>;
    /**
     * getDataAsync is used to retrieve data via a data-provider through a promise. In contrast to `ensureDataProvidersResolved`
     * nothing is cached every time `getDataAsync` is called a request is made. If you make multiple calls at the same time, multiple
     * requests will be sent.
     *
     * @param contributionId The contributionId of the data provider.
     * @param serviceInstanceId Id of the service instance, the current one will be used if not given
     * @param requestParameters Parameters to use when fetching data.
     */
    getDataAsync<T>(contributionId: string, serviceInstanceId?: string, requestParameters?: any): Promise<T | undefined>;
    /**
     * Ensure that all data providers have been resolved for all of the given data-provider contributions
     *
     * @param contributions The data provider contributions to resolve
     * @param refreshIfExpired If true, force a server request to re-populate the data provider data if the data has expired.  Default is it is always expired.
     */
    ensureDataProvidersResolved(contributions: Contributions_Contracts.Contribution[], refreshIfExpired?: boolean, properties?: any): IPromise<any>;
    private fetchPageDataForService;
    private getPageSource;
    /**
     * Get page data from a data provider contribution that is cached, optionally queueing an update of the data
     * after reading from the cache
     *
     * @param cachedDataProviderContributionId Id of the data provider which caches data in localStorage
     * @param primaryDataProviderContributionId Optional contribution id of a data provider to use if it exists. The cached data will not be used or updated if this exists.
     * @param refreshCache If true and data was read from the cache, queue up a request to update it.
     * @param contractMetadata Optional contract metadata to use when deserializing the JSON island data
     */
    getCachedPageData<T>(cachedDataProviderContributionId: string, primaryDataProviderContributionId?: string, refreshCache?: boolean, contractMetadata?: Serialization.ContractMetadata, reloadCallback?: IResultCallback): T;
    /**
     * Always reloads provider data by queuing up a new request
     *
     * @param cachedDataProviderContributionId Id of the data provider
     * @param properties Additional properties to pass to the provider on reload as part of the context
     */
    reloadCachedProviderData(cachedDataProviderContributionId: string, reloadCallback?: IResultCallback, properties?: any): void;
    /**
     * Invalidate any previously-cached data for the given data provider.
     *
     * @param cachedDataProviderContributionId Contribution id of the data provider
     * @param reloadDataNow If true, immediately make a request to repopulate the data provider's data
     */
    invalidateCachedProviderData(cachedDataProviderContributionId: string, reloadDataNow?: boolean): IPromise<any>;
}
/**
 * Provides helper functions for extensions-related types.
 */
export class ExtensionHelper {
    private static _httpUrlRegex;
    /**
    * full contribution id for the given contribution.
    *
    * @param contribution The contribution to get the id of
    */
    static getFullContributionId(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the identfier for the extension that published this contribution.
     *
     * @param contribution The contribution whose extension is being requested
     */
    static getExtensionId(contribution: Contributions_Contracts.Contribution): string;
    /**
     * Get the identfier for the publisher that published this contribution.
     *
     * @param contribution The contribution whose publisher is being requested
     */
    static getPublisherId(contribution: Contributions_Contracts.Contribution): string;
    /**
    * Is the contribution of the given contribution type
    *
    * @param contribution The contribution whose type to check
    * @param contributionType The full id of the contribution type to check for
    */
    static isContributionOfType(contribution: Contributions_Contracts.Contribution, contributionType: string): boolean;
    /**
     * Determines whether or not a contribution is from a trusted source.
     *
     * @param contribution The contribution whose trust to check
     */
    static isContributionTrusted(contribution: Contributions_Contracts.Contribution): boolean;
    /**
    * Determine whether or not the given contribution is from a trusted extension and has internal content
    *
    * @param contribution The contribution whose properties to check
    */
    static hasInternalContent(contribution: Contributions_Contracts.Contribution): boolean;
    /**
    * Determine whether or not the given contribution provides hostable content
    *
    * @param contribution The contribution whose properties to check
    * @param uriProperty The property name which contains the content uri ("uri" by default)
    */
    static hasContent(contribution: Contributions_Contracts.Contribution, uriProperty?: string): boolean;
    /**
     * Processes a mustache template string with the given replacement object
     * @param string templateString The mustache template string
     * @param any replacementObject
     * @return string The template string with all replacements made
     */
    static resolveTemplateString(templateString: string, replacementObject: any): IPromise<string>;
    /**
     * Processes a URI template string with the given replacement object and base URI
     * @param string templateString The mustache template string
     * @param any replacementObject
     * @param string baseUri
     * @return string The template string with all replacements made
     */
    static resolveUriTemplate(templateString: string, replacementObject: any, baseUri: string): IPromise<string>;
    /**
     * Get an absolute URI for a given property on a contribution and a replacements object
     * @param
     */
    static resolveUriTemplateProperty(contribution: Contributions_Contracts.Contribution, replacementObject: any, propertyName?: string, baseUri?: string): IPromise<string>;
    /**
     * Publish tracing data for a given contribution
     * @param Contributions_Contracts.Contribution contribution
     * @param any data
     */
    static publishTraceData(contribution: Contributions_Contracts.Contribution, data?: string, contributionId?: string): void;
    private static publishData;
}
}
declare module "VSS/Controls" {
import "jQueryUI/core";
import "jQueryUI/widget";
/**
 * Returns a unique integer from an increasing sequence.
 */
export function getId(): number;
/**
 * Returns a unique string suitable for use as an id for an HTML element.
 */
export function getHtmlId(): string;
export type TrueOrFalse = "true" | "false" | boolean;
export interface AriaAttributes {
    activedescendant?: string;
    atomic?: TrueOrFalse;
    autocomplete?: "inline" | "list" | "both" | "none";
    busy?: TrueOrFalse;
    checked?: TrueOrFalse | "mixed" | "undefined";
    controls?: string;
    describedby?: string;
    disabled?: TrueOrFalse;
    dropeffect?: "copy" | "move" | "link" | "execute" | "popup" | "none";
    expanded?: TrueOrFalse | "undefined";
    flowto?: string;
    grabbed?: TrueOrFalse | "undefined";
    haspopup?: TrueOrFalse | "undefined";
    hidden?: TrueOrFalse | "undefined";
    invalid?: TrueOrFalse | "grammar" | "spelling";
    label?: string;
    labelledby?: string;
    level?: string | number;
    live?: "off" | "polite" | "assertive";
    multiline?: TrueOrFalse;
    multiselectable?: TrueOrFalse;
    orientation?: "vertical" | "horizontal";
    owns?: string;
    posinset?: string | number;
    pressed?: TrueOrFalse | "mixed" | "undefined";
    readonly?: TrueOrFalse;
    relevant?: "additions" | "removals" | "text" | "all" | "additions text";
    required?: TrueOrFalse;
    selected?: TrueOrFalse | "undefined";
    setsize?: string | number;
    sort?: "ascending" | "descending" | "none" | "other";
    valuemax?: string | number;
    valuemin?: string | number;
    valuenow?: string | number;
    valuetext?: string;
}
export interface EnhancementOptions {
    earlyInitialize?: boolean;
    cssClass?: string;
    coreCssClass?: string;
    tagName?: string;
    width?: number | string;
    height?: number | string;
    title?: string;
    role?: string;
    id?: number | string;
    prepend?: boolean;
    change?: Function;
    /**
     * Legacy option. Superseded by ariaAttributes property.
     */
    ariaLabel?: string;
    /**
     * Add these aria attributes to the Enhancement.
     */
    ariaAttributes?: AriaAttributes;
}
export class Enhancement<TOptions> {
    static ENHANCEMENTS_DATA_KEY: string;
    static ENHANCEMENT_OPTIONS_KEY: string;
    static ENHANCEMENT_OPTIONPREFIX_KEY: string;
    static optionsPrefix: string;
    private static enhancementList;
    private _id;
    private _typeName;
    private _eventNamespace;
    private _trackedElements;
    private _delayedFunctions;
    protected _enhancementOptions: EnhancementOptions;
    _options: TOptions;
    _initialized: boolean;
    _element: JQuery;
    _disposed: boolean;
    /**
     * @param options
     */
    constructor(options?: TOptions, enhancementOptions?: EnhancementOptions);
    /**
     * @param type
     * @return
     */
    static getTypeName(type?: any): string;
    /**
     * @return
     */
    static getOptionPrefix(type: any): string;
    /**
     * @param type
     * @param element
     */
    static getEnhancementOptions(type: any, element: any): any;
    /**
     * @param type
     * @param element
     * @param options
     * @return
     */
    static enhance<TOptions>(type: new (options: TOptions, enhancementOptions: EnhancementOptions) => Enhancement<TOptions>, element: Enhancement<any> | JQuery | Node | string, options?: ((element: JQuery) => TOptions) | TOptions, enhancementOptions?: EnhancementOptions): Enhancement<TOptions>;
    /**
     * @param type
     * @param element
     * @return
     */
    static getInstance(type?: any, element?: any): Enhancement<any>;
    static getInstanceO<TOptions>(type?: any, element?: any): Enhancement<TOptions>;
    /**
     * @param type
     * @param selector
     * @param options
     * @param errorCallback
     */
    static registerEnhancement<TOptions>(type?: {
        new (options: TOptions): Enhancement<TOptions>;
    }, selector?: string, options?: TOptions, errorCallback?: IErrorCallback, enhancementOptions?: EnhancementOptions): void;
    /**
     * @param type
     * @param context
     * @param errorCallback
     * @return
     */
    static ensureEnhancements(type?: any, context?: any, errorCallback?: any): Enhancement<any>[];
    /**
     * @param type
     * @param context
     * @param errorCallback
     * @return
     */
    static ensureEnhancement(type?: any, context?: any, errorCallback?: any): Enhancement<any>;
    /**
     * @param type
     * @param widgetName
     * @param widgetOptions
     */
    static registerJQueryWidget<TOptions>(type?: any, widgetName?: any, widgetOptions?: TOptions, enhancementOptions?: EnhancementOptions): void;
    /**
     * @return
     */
    protected _getUniqueId(): string;
    /**
     * @return
     */
    getId(): string;
    /**
     * @param id
     */
    protected _setId(id: string): void;
    /**
     * Sets options related to the creation of this control or enhancement of an element as this control.
     * Note: Options are merged.
     * @param EnhancementOptions
     */
    setEnhancementOptions(enhancementOptions: EnhancementOptions): void;
    /**
     * @return
     */
    getTypeName(): string;
    /**
     * @return
     */
    protected _getEventNameSpace(): string;
    getType(): Function;
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    initialize(): void;
    /**
     * @return
     */
    _ensureInitialized(): boolean;
    protected _attemptInitialize(): void;
    enhance($element: any): void;
    /**
     * @param element
     */
    protected _enhance(element: JQuery): void;
    /**
     * @param element
     */
    protected _setElement(element: JQuery): void;
    protected _setStyles(): void;
    protected _setAriaAttributes(element?: JQuery): void;
    /**
     * Gets the element associated with this control.
     *
     * @return
     */
    getElement(): JQuery;
    /**
     * @param element
     * @param eventType
     * @param args
     */
    _fire(element?: any, eventType?: any, args?: any): any;
    /**
     * @param element
     * @param eventType
     * @param handler
     * @param track
     */
    _bind(element?: any, eventType?: any, handler?: any, track?: any): Enhancement<TOptions>;
    /**
     * @param element
     * @param eventType
     * @param handler
     * @param track
     */
    _unbind(element?: any, eventType?: any, handler?: any, track?: any): Enhancement<TOptions>;
    /**
     * Executes the provided function after the specified amount of time
     *
     * @param name (Optional) Name for this operation. Allows subsequent calls to cancel this action.
     * @param msDelay Delay in milliseconds to wait before executing the Function
     * @param cancelPendingOps If true, cancel any pending requests with this name. If false, and there are outstanding requests with this name already in progress, then do nothing.
     * @param func Method to execute after the delay
     */
    delayExecute(name?: string, msDelay?: number, cancelPendingOps?: boolean, func?: Function): void;
    /**
     * Cancels any pending delayed functions (delayExecute calls) with the specified name
     *
     * @param name Name (supplied in the delayExecute call) of the operations to cancel
     * @return True if any operation was canceled. False if no operations with the specified name were in progress
     */
    cancelDelayedFunction(name: string): boolean;
    protected _cleanup(): void;
    protected _dispose(): void;
    dispose(): void;
    /**
     * @return
     */
    isDisposed(): boolean;
    protected _getEnhancementOption(key: string): any;
    private _trackElement;
    private _untrackElement;
}
/**
 * Creates a the control specified by TControl in the given container.
 * @typeparam TControl extends Control<TOptions> - a reference to the type of control to create. Should be the
 *            same type as the constructor function passed as the first parameter to this function. Note: TypeScript
 *            doesn't support the constraint of a type parameter referencing any other type parameter in the same
 *            list, but callers should ensure that TControl extends Control<TOptions>.
 * @typeparam TOptions - The type that is passed in as the options for this control. The instantiated control must
 *            an options parameter of this type.
 * @param controlType: new (options: TOptions) => TControl - the constructor function (ClassName) of this type.
 * @param container: JQuery - a JQuery element to place the control in.
 * @param controlOptions: TOptions - Options to pass in for this control. See the interface for the options type
 *        for more details.
 * @param enhancementOptions?: EnhancementOptions - Optional options for the control enhancement.
 * @return TControl - returns an instance of the controlType (first parameter), typed as a TControl (first type param).
 */
export function create<TControl extends Control<any>, TOptions>(controlType: new (options: TOptions) => TControl, container: JQuery, controlOptions: TOptions, enhancementOptions?: EnhancementOptions): TControl;
export class Control<TOptions> extends Enhancement<TOptions> {
    /**
     * Creates a the control specified by TControl in the given container.
     * @typeparam TControl extends Control<TOptions> - a reference to the type of control to create. Should be the
     *            same type as the constructor function passed as the first parameter to this function. Note: TypeScript
     *            doesn't support the constraint of a type parameter referencing any other type parameter in the same
     *            list, but callers should ensure that TControl extends Control<TOptions>.
     * @typeparam TOptions - The type that is passed in as the options for this control. The instantiated control must
     *            an options parameter of this type.
     * @param controlType: new (options: TOptions) => TControl - the constructor function (ClassName) of this type.
     * @param container: JQuery - a JQuery element to place the control in.
     * @param controlOptions: TOptions - Options to pass in for this control. See the interface for the options type
     *        for more details.
     * @param enhancementOptions?: EnhancementOptions - Optional options for the control enhancement.
     * @return TControl - returns an instance of the controlType (first parameter), typed as a TControl (first type param).
     */
    static create<TControl extends Control<any>, TOptions>(controlType: new (options: TOptions) => TControl, container: JQuery, controlOptions: TOptions, enhancementOptions?: EnhancementOptions): TControl;
    /**
     * @param type
     * @param container
     * @param options
     * @return
     */
    static createIn<TOptions>(type?: any, container?: any, options?: TOptions, koCompatable?: boolean): Control<any>;
    private _overlay;
    private _elementInDomPromise;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    _getUniqueId(): string;
    /**
     * @param id
     */
    _setId(id: string): void;
    dispose(): void;
    showElement(): void;
    hideElement(): void;
    enableElement(enabled: any): void;
    showBusyOverlay(): JQuery;
    hideBusyOverlay(): void;
    isVisible(): boolean;
    _createElement(): void;
    _initializeElement(): void;
    _setStyles(): void;
    createIn(container: JQuery): void;
    protected _createIn(container: JQuery): void;
    /**
     * Set Focus to the control
     */
    focus(): void;
    /**
     * Fires the change event for the control immediately
     *
     * @param sender Source element of the event
     */
    protected _fireChange(sender?: any): any;
    /**
    * Get a promise that is resolved once the containing element for this
    * control has been added to the DOM hierarchy.
    */
    protected _getInDomPromise(): IPromise<any>;
    private _waitForElementInDom;
    /**
     * Sets the role for the current control using the specified role value on the specified element.
     * If no element specified, default element is used.
     *
     * @param role Role to assign.
     * @param element Element to apply the role (default is root element).
     */
    protected setRole(role: string, element?: JQuery): void;
    /**
     * Sets the attribute for the current control using the specified attribute name, value on the specified element.
     * If no element specified, default element is used.
     *
     * @param attribute Attribute name to set value.
     * @param value Attribute value to set.
     * @param element Element to apply the attribute (default is root element).
     */
    protected setAttribute(attribute: string, value: string | number, element?: JQuery): void;
}
export class BaseControl extends Control<any> {
}
export class BaseDataSource {
    protected _source: any;
    private _items;
    private _allItems;
    _options: any;
    constructor(options?: any);
    setSource(source: any): void;
    getSource(): any;
    /**
     * @param source
     */
    prepareSource(source?: any): void;
    getComparer(): any;
    ensureItems(): void;
    /**
     * @param all
     */
    getItems(all?: any): any;
    /**
     * @param allItems
     */
    setItems(items: any, allItems?: any): void;
    /**
     * @param all
     */
    getCount(all?: any): any;
    /**
     * @param all
     */
    getItem(index: any, all?: any): any;
    /**
     * @param all
     * @param textOnly
     * @return
     */
    getItemText(index: any, all?: any, textOnly?: any): string;
    /**
     * Gets first matching index to text input
     *
     * @param itemText
     * @param startsWith
     * @param all
     */
    getItemIndex(itemText: any, startsWith?: any, all?: any): any;
    /**
     * Returns an array of all indexes that match the search criteria
     * @param itemText
     * @param startsWith
     * @param all
     */
    getItemIndexes(itemText: string, startsWith?: boolean, all?: boolean): number[];
    /**
     * Returns an array of all indexes that match the search criteria
     * @param itemText
     * @param startsWith
     * @param all
     * @param first Only return the first result
     */
    private _getItemIndexesInternal;
    private _getInputTextToItemComparer;
    nextIndex(selectedIndex: any, delta: any, all: any): number;
}
}
declare module "VSS/Controls/AjaxPanel" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Panels = require("VSS/Controls/Panels");
export class AjaxPanel extends Panels.AjaxPanel {
    constructor(options?: any);
}
}
declare module "VSS/Controls/CheckboxList" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
/**
 * Recommended structure for an item in a CheckboxList control.
 * Not enforced - you may supply raw string items if preferred.
 */
export interface ICheckboxListItem {
    /**
     * The item's identifier or representative value.
     */
    value: any;
    /**
     * The item's display text. Ignored if 'content' is supplied.
     */
    text?: string;
    /**
     * Custom display element to render instead of 'text'.
     */
    content?: JQuery;
    /**
     * The item's tooltip.
     */
    title?: string;
    /**
     * Whether the item is checked.
     */
    checked: boolean;
    /**
     * Css class to be applied to this item.
     */
    cssClass?: string;
}
export interface ICheckboxListOptions extends Controls.EnhancementOptions {
    /**
     * List of items to be displayed.
     */
    items?: ICheckboxListItem[];
    /**
     * Css class applied to all items.
     */
    itemCssClass?: string;
    /**
     * Determine use arrow keys or TAB for navigation between tree nodes, in arrow keys mode only one node will have tabIndex at one time.
     * @defaultvalue false
     */
    useArrowKeysForNavigation?: boolean;
}
/**
 * Presents a list view of items, with checkboxes for each item.
 */
export class CheckboxListO<TOptions extends ICheckboxListOptions> extends Controls.Control<TOptions> {
    static enhancementTypeName: string;
    private _items;
    private _checkedItems;
    private _idMap;
    private _inputHasTabIndex;
    /**
     * @param options
     */
    initializeOptions(options?: ICheckboxListOptions): void;
    initialize(): void;
    enableElement(enabled: boolean): void;
    setItems(items: any[]): void;
    getCheckedItems(): any[];
    getUncheckedItems(): any[];
    getCheckedValues(): any[];
    getUncheckedValues(): any[];
    setCheckedValues(values: any[]): void;
    _initializeElement(): void;
    private _getItemValue;
    private _checkItemState;
    private _draw;
    /**
     * @param e
     * @return
     */
    private _onCheckClick;
}
export class CheckboxList extends CheckboxListO<ICheckboxListOptions> {
}
}
declare module "VSS/Controls/Combos" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
import Validation = require("VSS/Controls/Validation");
import Virtualization = require("VSS/Controls/Virtualization");
export function extendWithout(options?: any, toDelete?: any): any;
export class ListDataSource extends Controls.BaseDataSource {
}
export class BaseComboBehavior {
    combo: Combo;
    protected _options: any;
    protected _dataSource: Controls.BaseDataSource;
    private _onForceHideDropPopupDelegate;
    private _onParentsScrollDelegate;
    private _onWheelDelegate;
    private _dropPopup;
    constructor(combo: any, options?: any);
    initialize(): void;
    dispose(): void;
    setMode(value: any): void;
    canType(): boolean;
    /**
     * Get value for aria-autocomplete attribute of parent.
     */
    getAriaAutocomplete(): string;
    /**
     * Get additional text to use to label the control for screen reader users.
     */
    getAriaDescription(): string;
    getValue<TNever = never>(): any;
    getDropPopup<TDropPopup extends BaseComboDropPopup>(): TDropPopup;
    getDataSource<TDataSource extends Controls.BaseDataSource>(): TDataSource;
    /**
     * @return
     */
    getDropOptions(): any;
    getDropWidth(): number;
    showDropPopup(): boolean;
    hideDropPopup(): boolean;
    toggleDropDown(): void;
    isDropVisible(): boolean;
    setSource(source: any): void;
    /**
     * @return
     */
    getSelectedIndex(): number;
    setSelectedIndex(selectedIndex: any, fireEvent: any): void;
    /**
     * @return
     */
    getText(): string;
    /**
     * @param value
     * @param fireEvent
     */
    setText(value: string, fireEvent?: boolean): void;
    /**
     * @param e
     * @return
     */
    upKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    downKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    pageUpKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    pageDownKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    leftKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    rightKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyDown(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyPress(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyUp(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    onForceHideDropPopup(e?: JQueryEventObject): any;
    onParentsScroll(e: JQueryEventObject): any;
    /**
     * Gets the text of the given index based on allItems in datasource. Default behavior returns datasource getItemText
     * Can be overridden by the getItemText option
     * @param index
     * @param all - Search allItems from data source
     */
    protected getItemText(index: number, all?: boolean): string;
    private _attachGlobalEvents;
    private _detachGlobalEvents;
}
export interface IBaseComboDropPopup {
    /**
     * Returns the selected index of the drop popup. If nothing is selected return -1
     */
    getSelectedIndex(): number;
    getSelectedValue(): string;
    setSelectedValue(value: string): void;
    selectNext(page?: boolean): boolean;
    selectPrev(page?: boolean): boolean;
    /**
     * Updates drop popup rendering based on current data
     */
    update(): void;
    dispose(): any;
}
export class BaseComboDropPopup extends Controls.BaseControl implements IBaseComboDropPopup {
    combo: Combo;
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    setPosition(): void;
    /**
     * Returns selected index of drop popup
     * Base implementation, should be overridden
     */
    getSelectedIndex(): number;
    getSelectedValue(): string;
    getSelectedItem(): JQuery;
    setSelectedValue(value: string): void;
    selectNext(page?: boolean): boolean;
    selectPrev(page?: boolean): boolean;
    /**
     * Updates drop popup rendering based on current data
     * Base implementation, should be overridden
     */
    update(): void;
    dispose(): void;
    /**
     * @param e
     * @return
     */
    private _onMouseDown;
}
/**
 * @publicapi
 */
export interface IComboOptions {
    /**
     * Id added to the underlying input for accessibility.
     */
    id?: string;
    /**
     * Type of the combo. It can be 'list', 'date-time', 'multi-value', 'tree' or 'treeSearch'.
     * Refer to ComboTypeOptionsConstants for type value.
     * @defaultvalue "list"
     */
    type?: string;
    /**
     * Mode of the combo. It can be 'text' or 'drop'. Used by the combo of 'list' type. Determines whether to show drop icon or not.
     */
    mode?: string;
    /**
     * Sets the initial value for the combo.
     */
    value?: string;
    /**
     * Allows screen readers to read combo value. Should be used along with id.
     */
    label?: string;
    /**
     * Data source of the combo.
     */
    source?: any[];
    /**
     * Determines whether the combo is enabled or not.
     */
    enabled?: boolean;
    /**
     * Obsolete, this is not being used.
     */
    dropWidth?: string | number;
    /**
     * Indicates whether or not the dropdown should be able to expand past the input control.
     */
    fixDropWidth?: boolean;
    /**
     * Specifies the max size when auto-expand drop bigger than combo
     */
    maxAutoExpandDropWidth?: number;
    /**
     * Specifies whether the combo can be edited or not. The difference from enabled is items in the dropdown can be selected.
     */
    allowEdit?: boolean;
    noDropButton?: boolean;
    validator?: any;
    /**
     * Extra css class applied to combo.
     */
    cssClass?: string;
    /**
     * Css class for drop icon.
     */
    iconCss?: string;
    /**
     * Css class for the input.
     */
    inputCss?: string;
    /**
     * Css class applied for invalid state.
     */
    invalidCss?: string;
    /**
     * Css class applied for disabled state.
     */
    disabledCss?: string;
    /**
     * Css class applied to drop button when hovered.
     */
    dropButtonHoverCss?: string;
    /**
     * Set to 'true' to disable selecting all text in the combobox when it gets focus from another app
     */
    disableTextSelectOnFocus?: boolean;
    /**
     * Set to 'true' to enable filtering of dropdown items
     */
    enableFilter?: boolean;
    /**
     * Enable or disable autocomplete
     */
    autoComplete?: boolean;
    /**
     * Enable custom compare delegate for filtering and autocomplete behavior
     * if sorted, needs to implement -1 textInput for lower value, 0 for matching, 1 for greater value
     * if not sorted, can return 0 for matching and not zero (-1 or 1) for not matching.
     * Parameter matchPartial determines if the input text is to be compared with full or part of the item text
     */
    compareInputToItem?: (item: any, textInput: string, matchPartial?: boolean) => number;
    /**
     * Override getItemText from datasource in combos
     */
    getItemText?: (item: any) => string;
    /**
     * Called when the text of the combo changes.
     */
    change?: () => any;
    focus?: (e: JQueryEventObject) => any;
    blur?: (e: JQueryEventObject) => any;
    /**
     * Called when selected item changes. Argument is the index of the selected item.
     */
    indexChanged?: (index: number) => void;
    onKeyDown?: (e: JQueryEventObject) => any;
    /**
     * Options passed to the ComboDropPopup
     */
    dropOptions?: IComboDropOptions;
    /**
     * Placeholder text shown on input.
     */
    placeholderText?: string;
    /**
    * Called when the drop popup shows.
    */
    dropShow?: (dropPopup: BaseComboDropPopup) => void;
    /**
     * Called when the drop popup hides.
     * Return true to close drop popup.
     */
    dropHide?: (dropPopup: BaseComboDropPopup) => boolean;
    /**
     * Error message for accessibility purpose, i.e. for screen reader to recognize the error message
     */
    errorMessage?: string;
    /**
     * Obsolete. No effect.
     */
    setTitleOnlyOnOverflow?: boolean;
    /**
    * Aria attributes
    */
    ariaAttributes?: Controls.AriaAttributes;
    isFocusableWhenDisabled?: boolean;
}
/**
* Constant for Combo type options
*/
export module ComboTypeOptionsConstants {
    /**
    * list type
    */
    let ListType: string;
    /**
    * date time type
    */
    let DateTimeType: string;
    /**
    * multi value type
    */
    let MultiValueType: string;
    /**
    * tree type
    */
    let TreeType: string;
    /**
    * tree search type
    */
    let TreeSearchType: string;
}
export interface IComboDropOptions {
    /**
     * Parent combo behavior. Gives access to behavior public functions to drop popup
     */
    combo?: BaseComboBehavior;
    /**
     * Element that drop popup will be anchored to for display
     */
    anchor?: JQuery;
    /**
     * Used for position of the drop popup in relation to the anchor. (eg. "right-top", "right-bottom")
     */
    dropElementAlign?: string;
    dropBaseAlign?: string;
    /**
     * Element that drop popup will be created in
     */
    host?: JQuery;
    /**
     * Width of the drop popup
     */
    width?: number;
    /**
     * Datasource of drop popup items
     */
    dataSource?: Controls.BaseDataSource;
    /**
     * Initial selected index of drop popup
     */
    selectedIndex?: number;
    /**
     * Delegate for on selection. Invoked with .call(this, selectedIndex, accept)
     * selectedIndex - selected index of drop popup
     * accept - When set to true user has clicked and selected an item
     */
    selectionChange?: (selectedIndex: number, accept: any) => void;
    /**
     * Max number of rows to appear in the drop down
     */
    maxRowCount?: number;
    /**
     * CSS to apply to drop popup items
     */
    itemCss?: string;
    /**
     * Delegate for on click event
     */
    itemClick?: (e?: JQueryEventObject, itemIndex?: number, $target?: JQuery, $li?: JQuery) => void;
    /**
     * Render a drop popup item, return value will be appended to drop popup li item
     */
    getItemContents?: (item: string) => any;
    /**
     * Only set the HTML title attribute if the contents overflow the visible area.
     */
    setTitleOnlyOnOverflow?: boolean;
    /**
     * DEPRECATED - Alternate renderer for a drop popup item
     */
    createItem?: (index: any) => JQuery;
}
/**
 * @publicapi
 */
export class ComboO<TOptions extends IComboOptions> extends Controls.Control<TOptions> {
    static invalidAttribute: string;
    static enhancementTypeName: string;
    static registerBehavior(behaviorMode: any, behaviorType: any): void;
    static attachBehavior(combo: any, options?: any): any;
    focus(): void;
    protected _input: JQuery;
    protected _currentText: string;
    protected _blockBlur: boolean;
    private _dropButton;
    private _behavior;
    private _ariaDescription;
    private _errorAriaDescription;
    private _tooltip;
    private _onInputFocusInProgress;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    _dispose(): void;
    private _disposeBehavior;
    _createIn(container: any): void;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    initialize(): void;
    getBehavior<TBehavior extends BaseComboBehavior>(): TBehavior;
    /**
     * Gets the current text value of the combo.
    
     * @returns {string}
     * @publicapi
     */
    getText(): string;
    /**
     * Sets the text of the combo.
     *
     * @param text New value to set.
     * @param fireEvent Determines whether to fire change event or not (default false).
     * @publicapi
     */
    setText(text: string, fireEvent?: boolean): void;
    getDropButton(): JQuery;
    /**
     * Gets the input element of combo
     *
     * @return
     */
    getInput(): JQuery;
    getInputText(): string;
    private _updateTooltip;
    setInputText(text: string, fireEvent?: boolean): void;
    /**
     * @return
     */
    getSelectedIndex(): number;
    setSelectedIndex(selectedIndex: number, fireEvent?: boolean): void;
    /**
     * Gets the underlying value of the combo. If the type is 'list', value is string. If the type is 'date-time', value is Date. If the type is 'multi-value', value is string[].
     *
     * @returns {<TValue>}
     * @publicapi
     */
    getValue<TValue>(): TValue;
    /**
     * @param newValue
     */
    fireChangeIfNecessary(newValue?: string): any;
    /**
     * Programmatically toggles the dropdown.
     * @publicapi
     */
    toggleDropDown(): void;
    /**
     * @param e
     * @return
     */
    showDropPopup(e?: JQueryEventObject): void;
    hideDropPopup(): any;
    isDropVisible(): boolean;
    isBlockingBlur(): boolean;
    blockBlur(): void;
    cancelBlockBlur(): void;
    /**
     * @param e
     * @return
     */
    _onInputKeyDown(e?: JQueryEventObject): any;
    setTextSelection(selectionStart: number): void;
    /**
     * Sets a new source for the combo.
     *
     * @param source New source for the combo.
     * @publicapi
     */
    setSource(source: any[] | Function): void;
    /**
     * Gets the enabled state of the combo.
     *
     * @returns {boolean}
     * @publicapi
     */
    getEnabled(): boolean;
    /**
     * Sets the enabled state of the combo.
     *
     * @param value True for enabled, false for disabled.
     * @publicapi
     */
    setEnabled(value: boolean): void;
    /**
     * Gets the mode of the combo.
     *
     * @returns {string}
     * @publicapi
     */
    getMode(): string;
    /**
     * Sets the mode of the combo.
     *
     * @param value 'drop' or 'text'.
     * @publicapi
     */
    setMode(value: string): void;
    /**
     * Sets the type of the combo.
     *
     * @param value 'list', 'date-time', 'multi-value', TreeView.ComboTreeBehaviorName or TreeView.SearchComboTreeBehaviorName.
     * @publicapi
     */
    setType(type: string): void;
    /**
     * Gets the type of the combo.
     *
     * @returns {string}
     * @publicapi
     */
    getComboType(): string;
    /**
     * Sets the invalid state of the combo.
     *
     * @param value True for invalid, false for valid.
     * @publicapi
     */
    setInvalid(value: boolean): void;
    /**
     * Return true if the combo is in valid state. Otherwise return false.
     */
    isValid(): Boolean;
    private _ensureBehavior;
    private _decorate;
    protected _setAriaAttributes(): void;
    private _updateStyles;
    /**
     * @param e
     * @return
     */
    private _onDropButtonClick;
    /**
     * @param e
     * @return
     */
    protected _onInputClick(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    protected _onInputFocus(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    protected _onInputBlur(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    private _onMouseDown;
    /**
     * @param e
     * @return
     */
    private _onInputKeyPress;
    /**
     * @param e
     * @return
     */
    private _onInputKeyUp;
    updateAriaAttributes(isDropVisible?: boolean): void;
    updateAriaActiveDescendant(): void;
}
export class Combo extends ComboO<IComboOptions> {
}
export class ComboListDropPopup extends BaseComboDropPopup {
    virtualizingListView: Virtualization.VirtualizingListView;
    protected _dataSource: Controls.BaseDataSource;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    protected _initializeVirtualization(): void;
    /**
     * @param page
     * @return
     */
    selectPrev(page?: boolean): boolean;
    /**
     * @param page
     * @return
     */
    selectNext(page?: boolean): boolean;
    /**
     * Returns selected index of internal list view
     * @return
     */
    getSelectedIndex(): number;
    getSelectedValue(): string;
    setSelectedValue(value: any): void;
    getSelectedItem(): JQuery;
    getDataSource<TDataSource extends Controls.BaseDataSource>(): TDataSource;
    /**
     * Update internal list view to display current data
     */
    update(): void;
}
export class ComboListBehavior extends BaseComboBehavior {
    private _enableAutoFill;
    protected _maxItemLength: number;
    constructor(combo: any, options?: any);
    initialize(): void;
    setSource(source: any): void;
    getDropOptions(): any;
    getValue<TNever>(): any;
    /**
     * Finds the max item length inside the data source
     */
    getMaxItemLength(): number;
    /**
     * Gets the drop width of this behavior
     */
    getDropWidth(): number;
    /**
     * @param value
     * @return
     */
    getSelectedIndex(value?: string, all?: any): number;
    setSelectedIndex(selectedIndex: number, fireEvent?: boolean): void;
    /**
     * @param value
     * @param fireEvent
     */
    setText(value: string, fireEvent?: boolean): void;
    /**
     * @param e
     * @return
     */
    upKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    downKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    pageUpKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    pageDownKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyDown(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyPress(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyUp(e?: JQueryEventObject): any;
    /**
     * @param page
     * @return
     */
    selectPrev(page?: boolean): boolean;
    /**
     * @param page
     * @return
     */
    selectNext(page?: boolean): any;
    _createDataSource(): Controls.BaseDataSource;
    /**
     * Called on drop selection changed
     * @param selectedIndex - Represents index in datasource._items
     * @param accept - User has performed a click action
     */
    _dropSelectionChanged(selectedIndex: any, accept: any): void;
    /**
     * Set selected index
     *
     * @param selectedIndex new selected index
     * @param fireEvent flag to whether to fire index changed
     */
    protected _setSelectedIndex(selectedIndex: number, fireEvent?: boolean): void;
    private _tryAutoFill;
    /**
     * Limit what is shown in the dropdown based on text entry in combobox
     */
    private _applyFilter;
    protected _filterData(inputText: string): void;
}
export class ComboControlValidator extends Validation.BaseValidator<Validation.BaseValidatorOptions> {
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    /**
     * @return
     */
    isValid(): boolean;
}
export interface IDateTimeComboOptions extends IComboOptions {
    dateTimeFormat?: string;
    defaultTimeOfDay?: number;
}
export class DatePanel extends Controls.BaseControl {
    private _date;
    private _selectedDate;
    private _$selectedItem;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    prevMonth(): void;
    nextMonth(): void;
    prevYear(): void;
    nextYear(): void;
    selectDate(date: Date): void;
    setSelectedDate(date: Date): void;
    getSelectedDate(): Date;
    getSelectedItem(): JQuery;
    private _draw;
    private _drawCalendarTable;
    /**
     * @param e
     * @return
     */
    private _onKeyDown;
    /**
     * @param e
     * @return
     */
    private _onClick;
}
export class ComboDateDropPopup extends BaseComboDropPopup {
    private _datePanel;
    private _selectedDate;
    initialize(): void;
    getSelectedDate(): Date;
    getSelectedItem(): JQuery;
    setSelectedDate(date: Date): void;
    /**
     * @param e
     * @return
     */
    private _onChange;
}
export class ComboDateBehavior extends BaseComboBehavior {
    private _timeValue;
    constructor(combo: any, options?: any);
    initialize(): void;
    canType(): boolean;
    getAriaAutocomplete(): string;
    getAriaDescription(): string;
    getValue(): Date;
    /**
     * @return
     */
    getDropOptions(): any;
    getDropWidth(): number;
    /**
     * Get's the current value as a date or null if there is no (valid) date.
     *
     * @return
     */
    getSelectedDate(): Date;
    /**
     * Sets a date value on the combo using the behavior's dateTime format
     *
     * @param selectedDate The date value to set
     */
    setSelectedDate(selectedDate: Date, fireChange?: boolean): void;
    /**
     * @param e
     * @return
     */
    upKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyDown(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    downKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    pageUpKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    pageDownKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    leftKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    rightKey(e?: JQueryEventObject): any;
    private _onChange;
    private _getSelectedDate;
    private _addDays;
    private _getMonthLength;
}
export class DatePicker extends Combo {
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
}
export class ComboMultiValueDropPopup extends ComboListDropPopup {
    private _checkStates;
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    getCheckedItems(): string[];
    getValue(): string;
    toggleCheckbox(selectedIndex: any): void;
    private _createItem;
    private _onItemClick;
}
export class ComboMultiValueBehavior extends ComboListBehavior {
    static Default_Seperate_Char: string;
    static Default_Join_Char: string;
    constructor(combo: any, options?: any);
    canType(): boolean;
    getValue(): string[];
    /**
     * @return
     */
    getDropOptions(): any;
    /**
     * @param e
     * @return
     */
    keyDown(e?: JQueryEventObject): any;
    private _onChange;
}
}
declare module "VSS/Controls/Dialogs" {
/// <amd-dependency path="jQueryUI/core" />
/// <amd-dependency path="jQueryUI/button" />
/// <amd-dependency path="jQueryUI/dialog" />
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
/// <reference types="jquery" />
/// <reference types="jqueryui" />
/// <reference types="highcharts" />
import Controls = require("VSS/Controls");
import Panels = require("VSS/Controls/Panels");
import Q = require("q");
/**
 * Prevents clicking diabled buttons which happens in Edge.
 * See Bug 380864: Inactive "OK" button is clickable on EDGE
 */
export function preventClickingDisabledButtons(dialogElement: JQuery, buttons: any): void;
/**
 * @publicapi
 */
export interface IDialogOptions extends Panels.IAjaxPanelOptions {
    /**
     * Content of the dialog. It can be either a jQuery selector or a jQuery object.
     */
    content?: string | JQuery;
    /**
     * Text to add to the close button tooltip.
     */
    closeText?: string;
    /**
     * Text to be displayed in the dialog as the content.
     */
    contentText?: string;
    /**
     * Title of the dialog.
     */
    title?: string;
    /**
     * Subtitle of the dialog.
     */
    subtitle?: string;
    /**
     * Specifies where the dialog should be displayed when opened. This option is conveyed to underlying jQuery UI Dialog. See http://api.jqueryui.com/dialog/#option-position for more details.
     */
    position?: string;
    attachResize?: boolean;
    /**
     * Indicates whether the dialog is resizable or not.
     * @defaultvalue true
     */
    resizable?: boolean;
    /**
     * Determines whether or not the dialog resizes automatically when the
     * window is resized.
     * @defaultvalue true
     */
    dynamicSize?: boolean;
    /**
     * Delegate to be executed when the dialog is opened.
     */
    open?: (eventArgs: any) => any;
    /**
     * Delegate to be executed before the dialog is closed.
     */
    beforeClose?: (eventArgs: any) => any;
    /**
     * Delegate to be executed when the dialog is closed.
     */
    close?: (eventArgs: any) => any;
    /**
     * Delegate to be executed when the dialog is initialized completely (including sizing and positioning).
     */
    initialize?: () => void;
    defaultButton?: string;
    /**
     * Specifies which buttons should be displayed on the dialog. This option is conveyed to underlying jQuery UI Dialog. See http://api.jqueryui.com/dialog/#option-buttons for more details.
     */
    buttons?: any;
    /**
     * Specifies the jQuery selector for the default element to be focused initially.
     * @defaultvalue "First tabbable element"
     */
    initialFocusSelector?: string;
    /**
     * Indicates whether global progress indicator is enabled for the dialog or not.
     * @defaultvalue true
     */
    hasProgressElement?: boolean;
    /**
     * Specifies whether the dialog should be displayed when closed.
     * @defaultvalue true
     */
    disposeOnClose?: boolean;
    noFocusOnClose?: boolean;
    /**
     * Width of the dialog in px or %.
     * @defaultvalue 500
     */
    width?: number | string;
    /**
     * Height of the dialog in px or %.
     * @defaultvalue "auto"
     */
    height?: number | string;
    /**
     * Determines if the standard 24-px margin will be applied to all content.
     * @defaultvalue true
     */
    contentMargin?: boolean;
    /**
     * An optional boolean to specify whether or not to use the Bowtie styling for this Dialog.
     * @privateapi
     */
    useBowtieStyle?: boolean;
    /**
     * An optional variable to specify the version of Bowtie styling for this Dialog.
     * Defaults to 1, but 2 should be used for the updated styling in TFS
     * @privateapi
     */
    bowtieVersion?: number;
    /**
     * Additional class to apply to the container dialog element.
     */
    dialogClass?: string;
    /**
     * An optional boolean to indicate that the leftmost dialog button should not get
     * the "cta" (call to action) style applied automatically.
     * @defaultvalue false
     * @privateapi
     */
    noAutoCta?: boolean;
    /**
     * An optional variable to specify that the dialog should take on legacy UI styles
     * Defaults to false.
     * @privateapi
     */
    useLegacyStyle?: boolean;
    widthPct?: number;
    heightPct?: number;
    /**
     * Hide the X button.
     * @defaultValue "false"
     */
    hideCloseButton?: boolean;
    /**
     * Min height of the dialog in px.
     * @defaultvalue "auto"
     */
    minHeight?: number | string;
    /**
     * Min width of the dialog in px.
     * @defaultvalue "auto"
     */
    minWidth?: number | string;
    /**
     * Max height of the dialog in px.
     * @defaultvalue "auto"
     */
    maxHeight?: number | string;
    /**
     * Max width of the dialog in px.
     * @defaultvalue "auto"
     */
    maxWidth?: number | string;
    preventAutoResize?: boolean;
}
/**
 * @publicapi
 */
export class DialogO<TOptions extends IDialogOptions> extends Panels.AjaxPanelO<TOptions> {
    static enhancementTypeName: string;
    static _dialogActionInProgress: boolean;
    /**
     * The maximum width as specified in the options when the dialog was created.
     */
    private _specifiedMaxWidth;
    /**
     * The maximum height as specified in the options when the dialog was created.
     */
    private _specifiedMaxHeight;
    /**
     *     This should be used in cases where you don't want the user to execute more than 1 particular action involving a Dialog
     *     in parallel. For example, clicking a link that does some server processing before opening a dialog. On slow connections
     *     the user may be able to click the link several times before the first dialog ever opens.
     *
     * @param actionDelegate
     *     The function to execute which will involve initializing a Dialog. It takes a single optional
     *     paramater which is a cancellation routine. Call this when you encounter a situation (such as an error)
     *     where you wish to cancel the operation and have subsequent dialog actions execute without being blocked.
     *
     */
    static beginExecuteDialogAction(actionDelegate: Function): void;
    static create<T extends Controls.Control<any>>(dialogType: {
        new (options: any): T;
    }, options?: any): T;
    private static _getNextDialogZIndex;
    static show<T extends Dialog>(dialogType: {
        new (options: any): T;
    }, options?: any): T;
    private _title;
    private _subtitle;
    private _progressElement;
    private _dialogResult;
    private _onWindowResizeDelegate;
    private _onHubNavigateDelegate;
    private _secondOverlay;
    private _closeTooltip;
    private _resizeIconTooltip;
    protected _closedByNavigation: boolean;
    private _resizing;
    private static RESIZE_STEP;
    /**
     * Creates a new dialog with the provided options
     */
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    private _addResizeKeydownHandler;
    private _resize;
    private _autoSizeAndPosition;
    /**
     * Ensure there is at least one CTA button (left-most default) unless:
     * - There are no buttons, or
     * - There is at least one warning button
     * - The dialog sets the noAutoCta property to true
     * @param dialogOptions
     */
    private _ensureCtaButton;
    onLoadCompleted(content: any): void;
    /**
     * Tries to set the focus using the specified or default selector
     */
    setInitialFocus(): void;
    /**
     * Sets focus on the first enabled input element in the dialog.
     *
     * @param field The field to set focus.
     */
    setFormFocusDelayed($field: any): void;
    /**
     * Sets a new title for the dialog.
     *
     * @param title New title value.
     * @publicapi
     */
    setTitle(title: string): void;
    /**
     * Gets the current title of the dialog.
     *
     * @returns {string}
     * @publicapi
     */
    getTitle(): string;
    /**
     * Sets a new subtitle for the dialog
     * @param subtitle
     */
    setSubtitle(subtitle: string): void;
    /**
     * Gets the current subtitle of the dialog
     */
    getSubtitle(): string;
    centerDialog(): void;
    /**
     * Gets the current dialog result which will be used when ok button is clicked.
     *
     * @returns {any}
     * @publicapi
     */
    getDialogResult(): any;
    /**
     * Sets the dialog result.
     *
     * @param dialogResult Result object used when ok button is clicked.
     * @publicapi
     */
    setDialogResult(dialogResult: any): void;
    /**
     * Shows the dialog.
     */
    show(): void;
    /**
     * @param e
     * @return
     */
    onOpen(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    onClose(e?: JQueryEventObject): any;
    /**
     * Called when the initialization is completed including the sizing and positioning where all
     * element in the dialog are visible.
     */
    protected onInitialize(): void;
    /**
     * Closes the dialog.
     * @publicapi
     */
    close(): void;
    dispose(): void;
    /**
     * Remove the second overlay added as an Edge/IE hack (see comment in create() method).
     * We call this several times because there are several different ways that people use to close dialogs,
     * and onClose() can even be overridden.
     */
    private _removeSecondOverlay;
    private _updateSubtitle;
    /**
     * @param e
     * @return
     */
    onDialogResize(e?: JQueryEventObject): any;
    private _updateTitle;
    /**
     * @param e
     * @return
     */
    private _onWindowResize;
    /**
     * @param e
     * @return
     */
    private _onDialogResizing;
    /**
     * The JQuery UI Dialog unfortunately sets an explicit height for the dialog when it is moved,
     * meaning it will no longer auto-size when the contents are adjusted. However, the dialog
     * contents container will still have "auto" for its height. Ensure that the dialog contents
     * container gets set to an explicit height as well so that if its contents adjust, we show
     * a scrollbar instead of overflowing the dialog container.

     * Furthermore, we want to set the maximum height to be the distance between the current
     * top of the dialog to the bottom edge of the window. Dialogs will only grow down when
     * being auto-sized, so the dialog should not grow below the bottom of the window.
     * @param e
     * @param ui
     */
    private _onDialogMove;
    private _onDialogResizeStart;
    private _onDialogResizeStop;
    private _ensureDialogContentHeight;
    /**
     * Set the css maximum height of the dialog.
     */
    private _setMaxHeight;
    /**
     * Set the maximum size jQueryUI will allow the dialog to be.
     */
    private _setMaxSize;
    private _hideCloseButtonTooltip;
    private _hideResizeIconTooltip;
}
export class Dialog extends DialogO<IDialogOptions> {
}
/**
 * @publicapi
 */
export interface IModalDialogOptions extends IDialogOptions {
    /**
     * Display text for ok button.
     * @defaultvalue "ok"
     */
    okText?: string;
    /**
     * Delegate executed when ok button is clicked and a dialog result is available.
     */
    okCallback?: Function;
    /**
     * Display text for cancel button.
     * @defaultvalue "cancel"
     */
    cancelText?: string;
    /**
     * Delegate executed when cancel button is clicked.
     */
    cancelCallback?: Function;
}
/**
 * @publicapi
 */
export class ModalDialogO<TOptions extends IModalDialogOptions> extends DialogO<TOptions> {
    static enhancementTypeName: string;
    static EVENT_BUTTON_STATUS_CHANGE: string;
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    initialize(): void;
    /**
     * Updates the enabled state of the ok button.
     *
     * @param enabled True if enabled, otherwise false.
     * @publicapi
     */
    updateOkButton(enabled: boolean): void;
    processResult(result: any): void;
    /**
     * @param e
     * @return
     */
    onOkClick(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    onResultReady(e?: JQueryEventObject, args?: any): any;
    /**
     * @param e
     * @return
     */
    onCancelClick(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    onButtonStatusChange(e?: JQueryEventObject, args?: any): any;
}
export class ModalDialog extends ModalDialogO<IModalDialogOptions> {
}
export interface IConfirmationDialogOptions extends IModalDialogOptions {
    successCallback: Function;
}
export class ConfirmationDialogO<TOptions extends IConfirmationDialogOptions> extends ModalDialogO<TOptions> {
    $errorContainer: JQuery;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    _onSuccess(data: any): void;
    _onError(error: any): void;
    /**
     * @param e
     * @return
     */
    onOkClick(e?: JQueryEventObject): any;
}
export class ConfirmationDialog extends ConfirmationDialogO<IConfirmationDialogOptions> {
}
/**
 * Represents a button used in MessageDialog.
 *
 * Mirrored in VSS.SDK.Interfaces.
 */
export interface IMessageDialogButton {
    /**
     * Used as HTML id of the button.
     */
    id: string;
    /**
     * Text to display on the button.
     */
    text: string;
    /**
     * When true, the dialog's promise is rejected instead of resolved when this button is clicked.
     */
    reject?: boolean;
    /**
     * Specifies how the button should look.
     * Possible values:
     *   (undefined) - Default
     *   "warning" - Red
     */
    style?: string;
}
/**
 * Used by MessageDialogO.showDialog().
 *
 * Mirrored in VSS.SDK.Interfaces as IOpenMessageDialogOptions.
 */
export interface IShowMessageDialogOptions {
    /**
     * Array of buttons to show. Default is [Button.Ok, Button.Cancel]
     */
    buttons?: IMessageDialogButton[];
    /**
     * Button to use when the user presses the Esc key. Default is the last button.
     */
    escapeButton?: IMessageDialogButton;
    /**
     * If this is set, the user will be presented with a text box. Non-rejecting buttons will be disabled until the user types in this string.
     */
    requiredTypedConfirmation?: string;
    /**
     * Text for the title bar of the dialog.
     */
    title?: string;
    /**
     * Width of dialog in px.
     */
    width?: number;
    /**
     * Height of dialog in px.
     */
    height?: number;
    /**
     * Use Bowtie styling. Default is true.
     */
    useBowtieStyle?: boolean;
    /**
     * Option to override default focus setting (which sets focus to the next dialog when the current dialog is closed).
     */
    noFocusOnClose?: boolean;
    /**
    * Optional delegate that can be called when a dialog button is clicked. This can be used to get a value from UI in the dialog before it is removed from the DOM.
    */
    beforeClose?: (button: IMessageDialogButton) => void;
}
/**
 * Result returned when a MessageDialog is closed.
 *
 * Mirrored in VSS.SDK.Interfaces.
 */
export interface IMessageDialogResult {
    /**
     * Button that was clicked to dismiss the dialog.
     */
    button: IMessageDialogButton;
}
/**
 * Used internally by MessageDialogO.
 */
export interface IMessageDialogOptions extends IDialogOptions {
    buttons?: IMessageDialogButton[] | any;
    escapeButton?: IMessageDialogButton;
    /**
    * If set to true, no button is highlighted as the default button. Otherwise, the first button is the default.
    */
    noDefaultButton?: boolean;
    requiredTypedConfirmation?: string;
    /**
    * Optional delegate that can be called when a dialog button is clicked. This can be used to get a value from UI in the dialog before it is removed from the DOM.
    */
    beforeClose?: (button: IMessageDialogButton) => void;
}
/**
 * Class for creating simple dialog boxes. Use MessageDialog.showDialog().
 */
export class MessageDialogO<TOptions extends IMessageDialogOptions> extends DialogO<TOptions> {
    private _deferred;
    private _textbox;
    initializeOptions(options?: TOptions): void;
    initialize(): void;
    private initializeTypedConfirmation;
    /**
     * Returns a promise that is resolved or rejected when the dialog is closed.
     */
    getPromise(): Q.Promise<IMessageDialogResult>;
    /**
     * Show a MessageDialog.
     * @param message the message to display in the dialog. If it's a string, the message is displayed as plain text (no html). For HTML display, pass in a jQuery object.
     * @param methodOptions options affecting the dialog
     * @returns a promise that is resolved when the user accepts the dialog (Ok, Yes, any button with Button.reject===false), or rejected if the user does not (Cancel, No, any button with Button.reject===true).
     */
    static showMessageDialog(message: string | JQuery, methodOptions?: IShowMessageDialogOptions): Q.Promise<IMessageDialogResult>;
    onClose(e?: JQueryEventObject): any;
    /**
     * Returns an object suitable for initializing the given button for our parent Dialog.
     * @param button
     */
    private getButtonOptions;
    /**
    * Common message dialog buttons
    */
    static buttons: MessageDialogButtons;
}
/**
* Common message dialog buttons
*/
export interface MessageDialogButtons {
    /** OK button */
    ok: IMessageDialogButton;
    /** Cancel button */
    cancel: IMessageDialogButton;
    /** Yes button */
    yes: IMessageDialogButton;
    /** No button */
    no: IMessageDialogButton;
    /** Close button */
    close: IMessageDialogButton;
}
export class MessageDialog extends MessageDialogO<IMessageDialogOptions> {
}
export interface CopyContentDialogOptions extends IModalDialogOptions {
    dialogLabel?: string;
    dialogLabelExtend?: any;
    excludeTextPanel?: boolean;
    copyAsHtml?: boolean;
    data?: any;
    textAreaCopyClass?: string;
    pageHtml?: string;
    disableEdit?: boolean;
}
export class CopyContentDialog extends ModalDialogO<CopyContentDialogOptions> {
    static enhancementTypeName: string;
    private _$textArea;
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    /**
     * Initializes the dialog.
     */
    initialize(): void;
    /**
     * Initializes the dialog UI.
     */
    private _decorate;
    private _getDefaultLabelText;
    private _initializeRichEditor;
    /**
     * Initializes the text area panel
     *
     * @param $container The text area panel container.
     */
    private _initializeTextPanel;
}
/**
 * Shows the specified dialog type using specified options.
 *
 * @param dialogType Type of the dialog to show.
 * @param options Options of the dialog.
 * @returns {Dialog}.
 */
export function show<TDialog extends Dialog>(dialogType: new (options: any) => TDialog, options?: any): TDialog;
/**
 * Show a MessageDialog.
 * @param message the message to display in the dialog. If it's a string, the message is displayed as plain text (no html). For HTML display, pass in a jQuery object.
 * @param methodOptions options affecting the dialog
 * @returns a promise that is resolved when the user accepts the dialog (Ok, Yes, any button with Button.reject===false), or rejected if the user does not (Cancel, No, any button with Button.reject===true).
 */
export function showMessageDialog(message: string | JQuery, options?: IShowMessageDialogOptions): Q.Promise<IMessageDialogResult>;
export function showConfirmNavigationDialog(message: string, title?: string): Q.Promise<IMessageDialogResult>;
}
declare module "VSS/Controls/EditableGrid" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Combos = require("VSS/Controls/Combos");
import Controls = require("VSS/Controls");
import Grids = require("VSS/Controls/Grids");
export class CellEditor extends Controls.BaseControl {
    constructor(options: any);
    initialize(): void;
    getValue(): string;
    getDisplayValue(): string;
    setValue(value: string, doNotSavePrevious?: boolean): void;
    clearValue(setEmpty?: boolean): void;
    setSize($cellContext: JQuery): void;
    dispose(): void;
    setPosition(top: number, left: number): void;
    getHeight(): number;
    focus(): void;
    fireEndEdit(e?: JQueryEventObject): void;
    beginEdit(initValue: string): void;
    _attachEvents(): void;
    _detachEvents(): void;
    _fireChangedIfNeeded(): void;
    _handleKeydown(e: JQueryEventObject): boolean;
    _insertNewLineAtCursor(): void;
    _setCaretPositionToEnd($element: JQuery): void;
    _decorateElement(): void;
    _resetPosition(): void;
    valueChanged: () => void;
    endEdit: (e?: JQueryEventObject) => void;
    _prevValue: string;
    private _inEditMode;
    private _initValue;
}
export class TextCellEditor extends CellEditor {
    initialize(): void;
    setPosition(top: number, left: number): void;
    getHeight(): number;
    focus(): void;
    _attachEvents(): void;
    _detachEvents(): void;
    _handleKeydown(e: JQueryEventObject): boolean;
    _resetPosition(): void;
    _editableArea: JQuery;
}
export class RichTextCellEditor extends TextCellEditor {
    getValue(): string;
    private _getLastHtmlTag;
    private _hasNonbreakingSpaceAtEnd;
    setValue(htmlString: string, doNotSavePrevious?: boolean): void;
    clearValue(setEmpty?: boolean): void;
    setSize($cellContext: JQuery): void;
    _insertNewLineAtCursor(): void;
    _attachEvents(): void;
    _detachEvents(): void;
    _createElement(): void;
    _decorateElement(): void;
    _handleKeydown(e: JQueryEventObject): boolean;
    _setCaretPositionToEnd($element: JQuery): void;
}
export class PlainTextCellEditor extends TextCellEditor {
    constructor(options: any);
    getValue(): string;
    setValue(value: string, doNotSavePrevious?: boolean): void;
    clearValue(setEmpty?: boolean): void;
    setSize($cellContext: JQuery): void;
    _createElement(): void;
    _attachEvents(): void;
    _detachEvents(): void;
    _setCaretPositionToEnd($element: JQuery): void;
}
export class ComboCellEditor extends CellEditor {
    private _comboControl;
    private _label;
    constructor(options: any);
    initialize(): void;
    _populateUINodes(node: any, uiNode: any): any;
    _updateEditControl(values: string[], controlType: string): void;
    getComboControl(): Combos.Combo;
    createIn(container: any): void;
    _attachEvents(): void;
    _detachEvents(): void;
    setSize($cellContext: JQuery): void;
    setPosition(top: number, left: number): void;
    getHeight(): number;
    focus(): void;
    _resetPosition(): void;
    getValue(): string;
    setValue(value: string, doNotSavePrevious?: boolean): void;
    clearValue(setEmpty?: boolean): void;
    _createElement(): void;
}
export class CellInfo {
    constructor(rowInfo: any, dataIndex: number, columnInfo: any, columnOrder: number);
    rowInfo: any;
    columnInfo: any;
    dataIndex: number;
    columnOrder: number;
}
export class RowHeightInfo {
    constructor(height: number);
    height: number;
    isInvalid: boolean;
}
export class EditableGrid extends Grids.GridO<any> {
    static Commands: {
        CMD_APPEND: string;
        CMD_CUT: string;
        CMD_COPY: string;
        CMD_PASTE: string;
        CMD_INSERT_ROW: string;
        CMD_DELETE_ROWS: string;
        CMD_CLEAR_ROWS: string;
        CMD_INSERT_COLUMNS: string;
        CMD_DELETE_COLUMNS: string;
        CMD_RENAME_COLUMN: string;
    };
    constructor(options?: any);
    initialize(): void;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    getPinAndFocusElementForContextMenu(eventArgs: any): {
        pinElement: JQuery;
        focusElement: JQuery;
    };
    _getClickedColumnIndex(e?: JQueryEventObject): number;
    protected _onHeaderKeyDown(e?: JQueryEventObject): void;
    protected _getNextHeaderElement($target: JQuery): JQuery;
    protected _getPreviousHeaderElement($target: JQuery): JQuery;
    protected _getFocusableHeaderElement(): JQuery;
    _shouldAttachContextMenuEvents(): boolean;
    onContextMenu(eventArgs: any): any;
    /**
     * gets context menu items list
     *
     * @return new list of context menu items
     */
    _getContextMenuItems(): any;
    _updateContextMenuCommandStates(menu: any): void;
    _onContextMenuItemClick(e?: any): void;
    _onInsertRow(selectedDataIndices: number[], selectedRowIndices: number[]): void;
    _onDeleteRows(selectedDataIndices: number[], selectedRowIndices: number[]): void;
    _onClearRows(selectedDataIndices: number[], selectedRowIndices: number[]): void;
    getSelectedRowIndices(): number[];
    _drawCell(rowInfo: any, dataIndex: number, expandedState: number, level: number, column: any, indentIndex: number, columnOrder: number): any;
    onHyperLinkClick(dataIndex: number, columnIndex: string): void;
    onBeginCellEdit(dataIndex: number, columnIndex: string): void;
    onEndCellEdit(dataIndex: number, columnIndex: string, newValue: string, ignoreValueChange?: boolean): void;
    canEditCell(dataIndex: number, columnIndex: string): boolean;
    onCellChanged(dataIndex: number, columnIndex: string, newValue: string): void;
    _appendRow(): void;
    _applyColumnSizing(columnIndex: number, initialWidth?: number, finish?: boolean): void;
    _invalidateRowHeights(): void;
    ensureRowSelectionWhenLayoutComplete(command: any, indicesToSelect?: number[]): void;
    protected _onDeleteHeader(e: JQueryEventObject): void;
    private _focusGrid;
    whenLayoutComplete(command: any, indicesToSelect?: number[]): void;
    private _setSelection;
    private _validateIndicesToSelect;
    onLayoutComplete(command: any, indicesToSelect?: number[]): void;
    _getRowHeightInfo(dataIndex: number): RowHeightInfo;
    _setRowHeight(dataIndex: number, height: number): void;
    private _setCellValue;
    _setColumnInfo(column: any, index: number): void;
    getCellEditorForColumn(index: any): CellEditor;
    getCurrentEditRowIndex(): number;
    layout(): void;
    private _layoutInternal;
    _getSelectedCellInfo(): CellInfo;
    _onContainerMouseDown(e?: any): void;
    private _setRole;
    private _setCellEditor;
    _handleEditorEndEdit(e?: JQueryEventObject, $currentCell?: JQuery): void;
    private _handleEndEdit;
    private _allowCellResize;
    private _resizeCellsInRowToHeight;
    _onKeyDown(e?: JQueryEventObject): any;
    _createFocusElement(): JQuery;
    private _selectCellForSelectedRowIndex;
    private _getCellForRow;
    _onUpKey(e?: JQueryEventObject, bounds?: any): void;
    _onDownKey(e?: JQueryEventObject, bounds?: any): void;
    _onRightKey(e?: JQueryEventObject): void;
    _onLeftKey(e?: JQueryEventObject): void;
    _selectNextOrPrevCell(next: boolean, doNotGetCellIntoView?: boolean): boolean;
    _getRowsPerPage(e?: JQueryEventObject): number;
    _onPageUpPageDownKey(e?: JQueryEventObject, bounds?: any): void;
    _onHomeKey(e?: JQueryEventObject, bounds?: any): void;
    _onEndKey(e?: JQueryEventObject, bounds?: any): void;
    _handleCellSelectionAfterViewPortUpdate(): void;
    handleHeaderSelectionAfterViewPortUpdate(): void;
    _onEnterKey(e?: JQueryEventObject, bounds?: any): any;
    _isHyperLinkCell(cellInfo: CellInfo): boolean;
    _onBackSpaceKey(e?: JQueryEventObject): void;
    _onDeleteKey(e?: JQueryEventObject): any;
    cacheRows(aboveRange: any, visibleRange: any, belowRange: any): void;
    _drawRows(visibleRange: any, includeNonDirtyRows: any): void;
    setHeightForLowerContentSpacer(height: number): void;
    setHeightForUpperContentSpacer(height: number): void;
    _includeNewlyInsertedRowsInViewport(affectedIndices: number[]): void;
    _adjustContentSpacerHeightsPostDelete(): void;
    private _calculateHeightForUpperContentSpacer;
    private _calculateHeightForLowerContentSpacer;
    _getOuterRowHeight(index: number): number;
    protected _addSpacingElements(): void;
    getSelectedCellIntoView(): boolean;
    _getVisibleRowIndices(): {
        first: number;
        last: number;
    };
    _getVisibleRowIndicesAndDoCalculations(): {
        first: number;
        last: number;
    };
    _layoutContentSpacer(): void;
    _onCanvasScroll(e?: any): boolean;
    private _onScroll;
    _onLastRowVisible(rowIndex: number): void;
    private _isScrolledIntoView;
    _tryFinishColumnSizing(cancel: any): void;
    _onContainerResize(e?: JQueryEventObject): any;
    _selectRowAndCell($cell: JQuery, doNotGetCellIntoView?: boolean): void;
    getSelectedCell(): JQuery;
    selectSameRowNthCell(n: number, doNotGetCellIntoView?: boolean): boolean;
    _selectNextRowNthCell(n: number, doNotGetCellIntoView?: boolean): boolean;
    _selectPrevRowLastCell(doNotGetCellIntoView?: boolean): boolean;
    _selectNextRowFirstCell(doNotGetCellIntoView?: boolean): boolean;
    private _areEqual;
    _onKeyPress(e?: JQueryEventObject): any;
    private _isChar;
    _onRowDoubleClick(e?: JQueryEventObject): any;
    _cleanUpGrid(): void;
    private _deleteEditors;
    _editCell($cell: JQuery, delayEdit: boolean, clearExisting: boolean, charCode?: number): void;
    private _editCellInternal;
    _canEdit(cellInfo: CellInfo): boolean;
    _onRowMouseDown(e?: JQueryEventObject): any;
    _onRowClick(e?: JQueryEventObject): any;
    private _getRowFromCell;
    private _getRowFromEvent;
    private _areCellInfoEqual;
    onCellSelectionChanged($cell?: JQuery, delayEdit?: boolean): void;
    private _selectCell;
    private _getCellFromEvent;
    private _getCellInfoFromEvent;
    _updateViewport(includeNonDirtyRows?: boolean): void;
    postUpdateViewPort(): void;
    _ensureRowDrawn(dataIndex: any): boolean;
    /**
     * @param rowIndex
     * @param force
     * @return
     */
    _getRowIntoView(rowIndex: number, force?: boolean): boolean;
    private _getRowHeightBetweenRows;
    private _scrollCanvasUp;
    private _scrollCanvasDown;
    updateRows(indices?: number[]): void;
    _updateRow(rowInfo: any, rowIndex: number, dataIndex: number, expandedState: any, level: number, columnsToUpdate?: {
        [id: number]: boolean;
    }, forceUpdateHeight?: boolean): void;
    _updateRowStyle(rowInfo: any): void;
    private _isCellEmpty;
    private _getEmptyRowOuterHeight;
    _updateRowAndCellHeights(dataIndex: number, $row: JQuery, forceUpdate?: boolean): void;
    _clearSelections(): void;
    _fireEndEdit(): void;
    _rowHeightsDifferencePostDelete: number;
    _emptyRowOuterHeight: number;
    _gettingRowIntoView: boolean;
    _inEditMode: boolean;
    _lastVisibleRange: any;
    private _currentCellEditor;
    private _editRowIndex;
    private _heightForUpperContentSpacer;
    private _heightForLowerContentSpacer;
    private _rowMaxHeight;
    private _$selectedCell;
    private _selectedCellInfo;
    private _columnIndexToEditorMap;
    private _columnResizeInProgress;
    private _gridRowHolder;
    private _belowContentSpacer;
    private _isLayoutInProgress;
    private _borderHeight;
    private _selectCellOnLayoutComplete;
    private _editableHeaderColumnClassName;
}
}
declare module "VSS/Controls/ExternalHub" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Controls = require("VSS/Controls");
export interface INavigatedHubEventArgs {
    navigatedHubId: string;
    navigatedHubGroupId: string;
}
export class ExternalHub extends Controls.BaseControl {
    private static HUB_SWITCH_LOAD_DELAY;
    private _navigationIndex;
    private _hubsService;
    private _xhrHubSwitchingEnabled;
    private _extensionHost;
    initialize(): void;
    dispose(): void;
    private isHubXHRNavigable;
    private getNavigationSettings;
    /**
     * Navigate the page to the specified hub
     *
     * @param hubId Id of the hub to navigate to
     * @param url (Optional) Specific url to navigate to. The hub's default url if not specified.
     * @param cancelCallback Callback to invoke if the navigation was cancelled by the user (after prompted with unsaved changes)
     * @returns true if the navigation was handled.
     */
    private navigateToNewHub;
    private preXhrHubNavigate;
    prepareForHubNavigate(): void;
    hubNavigateStarting(): void;
    private popStateSubscription;
    private postXhrHubNavigate;
    private finishNavigateToNewHub;
    handleNewPlatformFps(xhrData: Contracts_Platform.PageXHRData, newPageContext: PageContext, contributionId?: string): IPromise<any>;
    private showSpinner;
    private hideSpinner;
    private hasStaticContentVersionChanged;
    private createHost;
    private beginGetHubContentUri;
}
}
declare module "VSS/Controls/FileInput" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
import Utils_File = require("VSS/Utils/File");
/**
* Options for the file input control.
*/
export interface FileInputControlOptions {
    /**
     * DEPRECATED. Use initialDrop instead for better experience when folders are dropped.
     */
    initialFiles?: FileList;
    initialDrop?: DataTransfer;
    maximumNumberOfFiles?: number;
    maximumTotalFileSize?: number;
    maximumSingleFileSize?: number;
    detectEncoding?: boolean;
    fileNamesCaseSensitive?: boolean;
    resultContentType?: FileInputControlContentType;
    /**
    * Specifies the allowed file extensions. For example: [ "zip", "exe" ]
    */
    allowedFileExtensions?: string[];
    updateHandler: (updateEvent: FileInputControlUpdateEventData) => void;
    /**
    * Callback executed whenever a user bumps into the limit of the file upload control.
    * @param currentMessage The message provided by the control itself.
    * @param limitEvent The context data about why the limit was hit.
    * @returns A message that will be shown to the user in place of currentMessage.
    */
    limitMessageFormatter?: (currentMessage: string, limitEvent: FileInputControlLimitEventData) => string;
    /**
     * Accessibility: aria-describedby for 'Browse' button
     */
    browseButtonAriaDescribedBy?: string;
}
/**
* File result from files uploaded to the FileInputControl.
*/
export interface FileInputControlResult {
    name: string;
    type: string;
    size: number;
    lastModifiedDate: Date;
    content?: string;
    encoding?: Utils_File.FileEncoding;
    file?: File;
}
export enum FileInputControlContentType {
    Base64EncodedText = 0,
    RawText = 1,
    RawFile = 2
}
/**
* Event data passed to FileInputControl update events.
*/
export interface FileInputControlUpdateEventData {
    loading: boolean;
    files: FileInputControlResult[];
}
/**
* Context for the limit message handler on why the upload limit was reached.
*/
export interface FileInputControlLimitEventData {
    /**
    * Size of the file that was too large, in bytes.
    */
    fileSize?: number;
    /**
    * Total size of all files, if the size was too large, in bytes.
    */
    totalSize?: number;
    /**
    * Number of files the user attempted to upload, if it was capped by maximumNumberOfFiles in the options.
    */
    fileCount?: number;
}
/**
* Information about a row in the file input control
*/
export interface FileInputControlRow {
    $listElement: JQuery;
    $statusElement: JQuery;
    $fileNameElement: JQuery;
    result: FileInputControlResult;
}
/**
* HTML5 based file input control which accepts one or multiple files with
* browse and drag/drop support. Reads content as a base64 encoded string.
*/
export class FileInputControl extends Controls.Control<FileInputControlOptions> {
    private _$fileInputContainer;
    private _$fileList;
    private _inputOptions;
    private _results;
    private _pendingResults;
    private _rows;
    private _$overallStatusContainer;
    private _$overallStatusText;
    private _$errorMessageContainer;
    private _$browseButton;
    static createControl($container: JQuery, options: FileInputControlOptions): FileInputControl;
    /**
    * Is this control supported on the current browser? Requires HTML5 FileReader support which
    * is present on all supported browsers except IE9.
    */
    static isSupported(): boolean;
    initializeOptions(options?: any): void;
    initialize(): void;
    /**
     * Override default control focus behavior, focus on 'browse' button by default and if not visible then first 'remove' link
     */
    focus(): void;
    private _triggerUpdateEvent;
    private _updateOverallStatus;
    private _getTotalFilesSize;
    private _addFiles;
    private _addFile;
    private _getFriendlySizeString;
    private _clearError;
    private _displayLimitError;
    private _displayError;
    private _getFirstRemoveLink;
    getFiles(): FileInputControlResult[];
    isLoadInProgress(): boolean;
    getRows(): FileInputControlRow[];
    /**
    * Clear all files in the list.
    */
    clear(): void;
}
export interface FileDropTargetOptions {
    filesDroppedCallback?: (fileList: FileList) => any;
    dropCallback: (dataDrop: DataTransfer) => any;
    dragEnterCallback?: (e: JQueryEventObject) => boolean;
    dragLeaveCallback?: (e: JQueryEventObject) => boolean;
    dragOverCssClass?: string;
}
export class FileDropTarget extends Controls.Enhancement<FileDropTargetOptions> {
    static makeDropTarget($element: JQuery, options: FileDropTargetOptions): FileDropTarget;
    private _dropTargetOptions;
    private _dragEventDelegate;
    private _dragLeaveEventDelegate;
    private _dropEventDelegate;
    private _dragOverClassName;
    _enhance($element: JQuery): void;
    _dispose(): void;
    private _handleDragEvent;
    private _handleDragLeaveEvent;
    private _handleDropEvent;
}
/**
 * Clones the DataTransfer in a duck-type instance.
 * DataTransfer is a mutable structure, so we cannot store it
 * because browser would clear it at will.
 * `files` is kept, but `items` is cleared so we need to deeply clone it too.
 */
export function cloneDataTransfer(dataTransfer: DataTransfer): DataTransfer;
}
declare module "VSS/Controls/Filters" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
import Utils_UI = require("VSS/Utils/UI");
/**
 * Options for the FlterControl
 */
export interface IFilterControlOptions extends Controls.EnhancementOptions {
    /**
     * Hide or show corresponding clause section
     */
    enableGrouping?: boolean;
    hideLogicalOperator?: boolean;
    hideOperatorHeader?: boolean;
    /**
    * All controls will be in read only mode
    */
    readOnly?: boolean;
    /**
    * All field and operators control should not allow edit
    */
    hasFixedFields?: boolean;
    /**
     * Enable add or remove clause behavior
     */
    enableRowAddRemove?: boolean;
    /**
     * Add clause behavior will prepend instead of append. Used with enableRowAddRemove
     */
    prependAddRow?: boolean;
    /**
     * Allows user to create the control with zero rows and remove the last remaining row.
     */
    allowZeroRows?: boolean;
    /**
     * Opt-in: Add-Remove buttons will append instead of prepend. Used with enableRowAddRemove
     */
    appendAddRemoveColumn?: boolean;
    /**
     * Add blur propogation to field, operator, and value controls
     */
    propogateControlBlur?: boolean;
}
/**
 * Model for FilterControl
 */
export interface IFilter {
    clauses?: IFilterClause[];
    maxGroupLevel?: number;
    groups?: Utils_UI.IFilterGroup[];
}
/**
 * Model for an individual clause
 */
export interface IFilterClause {
    index?: number;
    logicalOperator?: string;
    fieldName?: string;
    operator?: string;
    value?: string;
}
/**
 * Info of a clause role including member controls, element, and model information
 */
export interface IFilterClauseInfo {
    clause?: IFilterClause;
    $row?: JQuery;
    logicalOperatorControl?: any;
    fieldNameControl?: any;
    operatorControl?: any;
    valueControl?: any;
    group?: Utils_UI.IFilterGroup;
}
export class FilterControlO<TOptions extends IFilterControlOptions> extends Controls.Control<TOptions> {
    static enhancementTypeName: string;
    protected static ADD_REMOVE_CLASS: string;
    protected static ADD_CLAUSE_ROW_CLASS: string;
    private _clauseTable;
    private _groupHeaderCell;
    private _filter;
    constructor(options?: any);
    /**
     * Get the default clause for this filter.
     */
    _getDefaultClause(): void;
    /**
     * Update the and/or dropdown based on the given clause
     *
     * @param andOrControl The control to be updated.
     * @param clause The clause associated with the control.
     */
    _updateAndOrControl(andOrControl: any, clause: any): void;
    /**
     * Update the field dropdown based on the given clause
     *
     * @param fieldControl The control to be updated.
     * @param clause The clause associated with the control.
     */
    _updateFieldControl(fieldControl: any, clause: any): void;
    /**
     * Update the operator dropdown based on the given clause
     *
     * @param operatorControl The control to be updated.
     * @param clause The clause associated with the control.
     * @param updateClause True to update the clause with the new operator/value.
     */
    _updateOperatorControl(operatorControl: any, clause: any, updateClause?: boolean): void;
    /**
     * Update the value dropdown based on the given clause
     *
     * @param valueControl The control to be updated.
     * @param clause The clause associated with the control.
     */
    _updateValueControl(valueControl: any, clause: any): void;
    /**
     * Validate the given clause.
     *
     * @param clauseInfo The clause info.
     */
    _validateClause(clauseInfo: any): void;
    /**
     * Handler called when the field name control's value is changed.
     *
     * @param clauseInfo The clause info.
     * @param oldValue The old field name.
     */
    _handleFieldNameChanged(clauseInfo: any, oldValue: string): void;
    /**
     * Handler called when the operator control's value is changed.
     *
     * @param clauseInfo The clause info.
     * @param oldValue The old operator value.
     */
    _handleOperatorChanged(clauseInfo: any, oldValue: string): void;
    /**
     * Mark this filter as dirty.
     */
    _setDirty(): void;
    /**
     * @param options
     */
    initializeOptions(options?: IFilterControlOptions): void;
    setFilter(filter: IFilter): void;
    protected _createClauseTable(): void;
    private _createHeaderRow;
    _getInsertClauseTooltipText(): string;
    _getRemoveClauseTooltipText(): string;
    getFilters(): IFilter;
    private _createClauseRow;
    createClauseValueControl(container: JQuery, options?: any): any;
    /**
     * Gets the string to be displayed in place of "add new clause" hyperlink.
     */
    _getAddNewClauseText(): string;
    private _createAddRemoveColumn;
    private _createAddClauseRow;
    private _onClauseChange;
    getClauseValue(valueControl: any, clause: any): string;
    /**
     * @param e
     * @return
     */
    private _addClauseClick;
    /**
     * @param e
     * @return
     */
    protected _removeClauseClick(e?: JQueryEventObject, clauseInfo?: IFilterClauseInfo): any;
    private _updateGroupingSpan;
    private _groupSelectedClauses;
    /**
     * @param e
     * @return
     */
    private _ungroupClick;
    private _createTableAndFocus;
    private _createTableAndFocusDelete;
    private _handleFilterModified;
    private _onControlBlurred;
}
export class FilterControl extends FilterControlO<IFilterControlOptions> {
}
}
declare module "VSS/Controls/FormInput" {
import Combos = require("VSS/Controls/Combos");
import Controls = require("VSS/Controls");
import FormInput_Contracts = require("VSS/Common/Contracts/FormInput");
/**
* Options for the file input control.
*/
export interface FormInputControlOptions {
    inputsViewModel: InputsViewModel;
    headerLabel: string;
    comboControlMap: {
        [key: string]: Combos.Combo;
    };
}
export interface ExtendedInputDescriptor extends FormInput_Contracts.InputDescriptor {
    /**
     * A list of functions to be called when this input is deleted.
     */
    deleteCallbacks: (() => void)[];
    /**
     * A list of functions, all of which must return true for this input to be considered valid
     */
    dependencies: InputViewModelDelegate<boolean>[];
    /**
     * A list of functions to be called when the state of all dependencies of this input being satisfied changes.
     */
    dependenciesSatisfiedCallbacks: ((satisfied: boolean) => void)[];
    /**
     * Gets whether this input should be invisible until all of its dependencies are satisfied or not.
     */
    hideUntilSatisfied: boolean;
    /**
     * Gets whether this input is deletable.
     */
    isDeletable: boolean;
    /**
     * Gets whether this input should be invalidated when one of its dependency's value changes or not.
     * Odd name is due to the fact that the default should be to invalidate (based on FormInput_Contracts.InputDescriptor).
     */
    noInvalidateOnDependencyChange: boolean;
    /**
     * Gets whether or not to display the valid icon for this input.
     */
    noValidIcon: boolean;
    /**
     * Information to use to validate this input's value
     */
    validation: ExtendedInputValidation;
    /**
     * A list of functions to be called when the value of this input is changed.
     */
    valueChangedCallbacks: InputViewModelDelegate<void>[];
}
export interface ExtendedInputValidation extends FormInput_Contracts.InputValidation {
    /**
     * A function called when checking input validity. Validation.isValid must be true for the input to be considered valid.
     */
    validateFunction: InputViewModelDelegate<Validation>;
}
export interface Validation {
    /**
     * True if input is valid, false otherwise.
     */
    isValid: boolean;
    /**
     * Error message if input is not valid
     */
    error: string;
}
export interface InputGroup {
    $header: JQuery;
    $table: JQuery;
    memberCount: number;
}
export interface InputViewModelDelegate<T> {
    (inputViewModel: InputViewModel): T;
}
export class FormInputControl extends Controls.Control<FormInputControlOptions> {
    private _$inputsContainer;
    private _headerLabel;
    private _comboControlMap;
    private _inputGroups;
    private _$inputIdToElements;
    private _inputsViewModel;
    static createControl($container: JQuery, options: FormInputControlOptions): FormInputControl;
    initializeOptions(options?: any): void;
    initialize(): void;
    deleteControl(): void;
    private _createGroup;
    addInputViewModel(inputViewModel: InputViewModel): void;
    removeInputViewModel(inputViewModel: InputViewModel, removeFromInputsViewModel?: boolean): void;
    showInputViewModel(inputViewModel: InputViewModel): void;
    hideInputViewModel(inputViewModel: InputViewModel): void;
    private _showHideInputViewModel;
    private _createDeleteButton;
    getGroupHeader(groupName?: string): JQuery;
    getInputFieldById(id: string): JQuery;
    createRowBeforeInput(id: string): JQuery;
    createRowAfterInput(id: string): JQuery;
    private _addDescriptionIcon;
    private _createInputField;
    private _textInputValueChanged;
    private _radioInputValueChanged;
    private _setupTooltip;
    private static _fixLinkTargets;
    static getProgressIconForInput(inputId: string): JQuery;
    static getValidationIconForInput(inputId: string): JQuery;
}
export class FormInputViewModel {
    protected _inputsViewModels: {
        [key: string]: InputsViewModel;
    };
    protected _dependentInputsLoadingCallback: any;
    protected _dependentInputsLoadedCallback: any;
    protected _inputValidChangedCallback: any;
    protected _inputValuesChangedCallback: any;
    protected _queryForValuesCallback: any;
    protected _isDirty: boolean;
    mapInputIdToComboControl: {
        [key: string]: Combos.Combo;
    };
    constructor(dependentInputsLoadingCallback: any, dependentInputsLoadedCallback: any, inputValidChangedCallback: any, inputValuesChangedCallback: any, queryForValuesCallback?: any);
    addInputsViewModel(key: string, inputsViewModel: InputsViewModel): void;
    isDirty(): boolean;
    inputsAreValid(inputsKey: string): boolean;
    queryInputValues(inputsViewModel: InputsViewModel, inputsToQuery: InputViewModel[], callback: any, callbackContext: any): void;
    onInputValuesChanged(inputViewModel: InputViewModel): void;
    protected _beginQueryForValues(inputValues: FormInput_Contracts.InputValues[], inputsViewModel: InputsViewModel): IPromise<FormInput_Contracts.InputValue[]>;
    protected _showOrHideProgressIndicator(inputId: string, show: boolean): void;
}
export class InputsViewModel {
    private _inputViewModels;
    private _mapNameToInputViewModel;
    private _mapNameDependencyCount;
    protected _satisfiedDependentInputs: InputViewModel[];
    private _valuesChangedCallback;
    private _formInputViewModel;
    constructor(formInputViewModel: FormInputViewModel, inputDescriptors: FormInput_Contracts.InputDescriptor[], inputValues: {
        [key: string]: any;
    }, inputValidChangedCallback: InputViewModelDelegate<void>, valuesChangedCallback: InputViewModelDelegate<void>);
    addInputViewModel(inputDescriptor: ExtendedInputDescriptor, inputValue?: any, inputValidChangedCallback?: InputViewModelDelegate<void>, valuesChangedCallback?: InputViewModelDelegate<void>): InputViewModel;
    removeInputViewModel(inputViewModel: InputViewModel): void;
    areDirty(): boolean;
    areValid(): boolean;
    getInputViewModels(): InputViewModel[];
    getInputViewModelById(id: string): InputViewModel;
    getInputsAsDictionary(): {
        [inputId: string]: any;
    };
    allDependentsSatisfied(inputViewModel: InputViewModel): boolean;
    private _invalidateDependencies;
    private _updateDependencies;
    protected _querySatisfiedDependentInputValues(): void;
    private _isADependent;
    private _onValueChanged;
    private _onBlur;
}
export class InputViewModel {
    private _inputDescriptor;
    private _validation;
    private _value;
    private _selectedIndex;
    private _isValid;
    private _isDirty;
    private _dependenciesSatisfied;
    private _validationError;
    private _dependencies;
    private _validityDelegate;
    private _validityFollowers;
    private _blurCallback;
    private _inputValidChangedCallback;
    private _valueChangedCallbacks;
    private _valuesChangedCallback;
    private _dependenciesSatisfiedCallbacks;
    private _deleteCallbacks;
    private _suppressValidityChangeNotifications;
    constructor(inputDescriptor: FormInput_Contracts.InputDescriptor, inputValue: any, inputValidChangedCallback: InputViewModelDelegate<void>, blurCallback: InputViewModelDelegate<void>, valueChangedCallbacks: InputViewModelDelegate<void>[], valuesChangedCallback: InputViewModelDelegate<void>, dependencies?: InputViewModelDelegate<boolean>[], dependenciesSatisfiedCallbacks?: ((satisfied: boolean) => void)[], deleteCallbacks?: (() => void)[]);
    private _addFunctions;
    validate(): void;
    isDirty(): boolean;
    isValid(): boolean;
    isRequired(): boolean;
    isEmpty(): boolean;
    isDropList(): boolean;
    getId(): string;
    getValue(): any;
    getValidationMessage(): string;
    getSelectedIndex(): number;
    setSelectedIndex(index: number): void;
    getInputDescriptor(): ExtendedInputDescriptor;
    getPossibleValueAtIndex(index: number): FormInput_Contracts.InputValue;
    setValue(value: any): void;
    refresh(): void;
    dependsOn(inputValueId: string): boolean;
    invalidateValues(): void;
    invalidateOnDependencyChange(): boolean;
    updateValues(values: FormInput_Contracts.InputValues): void;
    onBlur(): void;
    suppressValidityChangeNotifications(suppress: boolean): void;
    addValueChangedCallback(callback: InputViewModelDelegate<void>, addToFront?: boolean): void;
    removeValueChangedCallback(callback: InputViewModelDelegate<void>): boolean;
    setValidityDelegate(validityDelegate: InputViewModel): void;
    addValidityFollower(follower: InputViewModel, addToFront?: boolean): void;
    removeValidityFollower(follower: InputViewModel): void;
    addDependency(dependency: InputViewModelDelegate<boolean>, addToFront?: boolean): void;
    checkDependenciesSatisfied(): boolean;
    getDependenciesSatisfied(): boolean;
    private _dependenciesSatisfiedChange;
    inputDependenciesSatisfied(satisfied: boolean): boolean;
    addDependenciesSatisfiedCallback(callback: (satisfied: boolean) => void, addToFront?: boolean): void;
    deleteViewModel(): void;
    addDeleteCallback(callback: () => void, addToFront?: boolean): void;
    private _invalidateValue;
    private _setValue;
    private _computeSelectedIndex;
    private _setDirty;
    private _setValid;
    private _getDefaultIndex;
    private _getSelectedIndex;
    private _getDefaultValue;
    private _validate;
    private _validateBoolean;
    private _validateGuid;
    private _validateNumber;
    private _validateString;
    private _validateUri;
}
}
declare module "VSS/Controls/Grids" {
/// <amd-dependency path="jQueryUI/droppable" />
/// <amd-dependency path="VSS/Utils/Draggable" />
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
/// <reference types="jquery" />
/// <reference types="jqueryui" />
/// <reference types="highcharts" />
/// <reference types="vss-common" />
import Controls = require("VSS/Controls");
import Menus = require("VSS/Controls/Menus");
import Search = require("VSS/Search");
/**
 * @publicapi
 */
export interface IGridOptions {
    /**
     * Data source of the grid. It can be array of arrays ([[], [], [], ...]),  array of objects ([{}, {}, {}, ...])
     * @defaultvalue "[]"
     */
    source?: any;
    /**
     * Specifies the expand states of each item in the source. If an item has a total of n descendants; -n makes the item collapsed, n makes the item expanded, 0 means no children and descendants.
     */
    expandStates?: number[];
    /**
     * Determines whether the header is displayed or not
     * @defaultvalue true
     */
    header?: boolean;
    /**
     * Height of the grid in px or %
     */
    height?: string;
    /**
     * Width of the grid in px or %
     */
    width?: string;
    /**
     * Determines whether multiple selection is allowed or not
     * @defaultvalue true
     */
    allowMultiSelect?: boolean;
    /**
     * Determines whether moving columns is allowed or not
     * @defaultvalue true
     */
    allowMoveColumns?: boolean;
    /**
     * Determines whether selecting text is allowed or not
     * @defaultvalue false
     */
    allowTextSelection?: boolean;
    /**
     * Determines whether the last cell should fill remaining content (if exists)
     * @defaultvalue false
     */
    lastCellFillsRemainingContent?: boolean;
    /**
     * List of columns to be displayed in the grid
     * @defaultvalue "[]"
     */
    columns?: IGridColumn[];
    /**
     * Options about the gutter. If specified false, gutter will be invisible
     * @defaultvalue false
     */
    gutter?: IGridGutterOptions;
    /**
     * Options about the context menu displayed when gutter clicked
     */
    contextMenu?: IGridContextMenu;
    /**
     * Initial sort info for the grid
     * @defaultvalue "[]"
     */
    sortOrder?: IGridSortOrder[];
    /**
     * Specifies whether grid should be sorted initially using the sortOrder option
     * @defaultvalue true
     */
    autoSort?: boolean;
    asyncInit?: boolean;
    initialSelection?: boolean;
    sharedMeasurements?: boolean;
    payloadSize?: number;
    extendViewportBy?: number;
    coreCssClass?: string;
    draggable?: any;
    droppable?: any;
    sort?: Function;
    enabledEvents?: any;
    openRowDetail?: any;
    suppressRedraw?: boolean;
    keepSelection?: boolean;
    /**
     * Specifies whether to use the legacy grid style rather than Bowtie.
     * @defaultvalue false
     */
    useLegacyStyle?: boolean;
    /**
     * @privateapi
     * Type of the formatter which is used for retrieving the content from the grid
     * Used in beginTableFormat, called when triggering a copy action
     */
    formatterType?: new (grid: GridO<any>, options?: any) => ITableFormatter;
}
export interface IGridContextMenu {
    /**
     * Menu items to be shown when gutter clicked. Value can be a list of menu items or a function which returns an a list of menu items
     */
    items?: any;
    /**
     * Execute action for the popup menu
     */
    executeAction?: (args: any) => any;
    contributionIds?: string[];
    /**
     * Specifies whether to use the modern bowtie styling (bowtie styles are in preview and subject to change).
     * @defaultvalue false
     */
    useBowtieStyle?: boolean;
    /**
     * Column index for the context menu, if using bowtie styling
     */
    columnIndex?: number | string;
    /**
     * Specifies whether loading of contributions are suppresed at start
     * @defaultvalue false
     */
    suppressInitContributions?: boolean;
}
export interface IGridGutterOptions {
    /**
     * Determines whether a context menu is show in the gutter or not
     * @defaultValue false
     */
    contextMenu?: boolean;
    checkbox?: boolean;
    icon?: IGridGutterIconOptions;
}
export interface IGridGutterIconOptions {
    /**
     * String or number value to get the icon value from source item corresponding to current row
     */
    index?: any;
    /**
     * String or number value to get the icon tooltip value from source item corresponding to current row
     */
    tooltipIndex?: any;
}
export interface IGridColumn {
    /**
     * Index of the column which can be either number or string. If number specified, each item of the data source is expected to be an array. Then array[index] is displayed in the column. If string specified, each item if the data source is expected to be an object. Then object[index] is displayed in the column.
     * @defaultvalue "index in the columns array"
     */
    index?: any;
    /**
     * Name of the column used for identification purposes
     */
    name?: string;
    /**
     * Determines whether moving this column is enabled or not
     * @defaultvalue true
     */
    canSortBy?: boolean;
    /**
     * Determines whether sorting this column is enabled or not
     * @defaultvalue true
     */
    canMove?: boolean;
    /**
     * Width of the column in pixels
     * @defaultvalue 100
     */
    width?: number;
    /**
     * Css class to be added to the header cell
     */
    headerCss?: string;
    /**
     * Css class to be added to the header cell container
     */
    headerContainerCss?: string;
    /**
     * Css class to be added to the cells under this column
     */
    rowCss?: string;
    /**
     * Display text of the column
     * @defaultvalue ""
     */
    text?: string;
    /**
     * Tooltip text of the column
     * @defaultvalue ""
     */
    tooltip?: string;
    /**
     * Specifies how ordering should be performed ("asc" or "desc")
     * @defaultvalue "asc"
     */
    order?: string;
    /**
     * Determines whether the column should be hidden or not
     * @defaultvalue false
     */
    hidden?: boolean;
    /**
     * Determines whether column moving effects this column or not
     * @defaultvalue false
     */
    fixed?: boolean;
    /**
    * Prevents the HTML table formatter from HTML encoding
    * @defaultvalue false
    */
    noHtmlEncode?: boolean;
    /**
     * If the value of cell is Date, format is used (like 'mm/dd/yyyy')
     */
    format?: string;
    hrefIndex?: number;
    indentOffset?: number;
    indent?: boolean;
    maxLength?: number;
    fieldId?: any;
    comparer?: (column: IGridColumn, order: number, rowA: any, rowB: any) => number;
    isSearchable?: boolean;
    getCellContents?: (rowInfo: any, dataIndex: number, expandedState: number, level: number, column: any, indentIndex: number, columnOrder: number) => void;
    getHeaderCellContents?: (IGridColumn: any) => JQuery;
    getColumnValue?: (dataIndex: number, columnIndex: number | string, columnOrder?: number) => any;
    /**
    * Custom click handler for the column header
    */
    onHeaderClick?: (column: IGridColumn) => void;
}
export interface IGridSortOrder {
    /**
     * Refers to column index
     */
    index: any;
    /**
     * Determines whether to sort ascending (default) or descending
     * @defaultvalue "asc"
     */
    order?: string;
}
export interface IGridRowInfo {
    dataIndex?: number;
    rowIndex?: number;
    row?: JQuery;
    dirty?: boolean;
    gutterRow?: any;
}
/**
 * Base item for a grid source (represents a row)
 */
export interface IGridSourceItem {
    [key: string]: any;
}
/**
 * Contract for the grid source.
 * Implementers should return source and expandStates arrays.
 */
export interface IGridSource {
    /**
     * Grid to update the source
     */
    grid: Grid;
    /**
     * Gets the source which can be consumed by the grid
     */
    getSource(): any[];
    /**
     * Gets the expand states of the source
     */
    getExpandStates(): number[];
    /**
     * Updates the source of the grid
     */
    update(items: IGridSourceItem[]): any;
}
/**
 * Default datasource implementation for the grid. It can be used for a flat list.
 */
export class GridDefaultSource implements IGridSource {
    grid: Grid;
    protected _source: any[];
    constructor(items: IGridSourceItem[]);
    update(items: IGridSourceItem[]): void;
    getSource(): any[];
    getExpandStates(): number[];
    protected _updateSource(items: IGridSourceItem[]): void;
}
/**
 * Item contract for a hierarchical data source.
 * It can either have its own properties to be shown in the grid or values array can be used.
 * If values used, column.index should correspond to the index in the values.
 */
export interface IGridHierarchyItem extends IGridSourceItem {
    /**
     * Values to be used by grid to display grid content. index: number should be used for columns if values are used.
     */
    values?: any[];
    /**
     * Children of this item
     */
    children?: IGridHierarchyItem[];
    /**
     * Determines whether this item should be displayed collapsed or not
     */
    collapsed?: boolean;
}
/**
 * Hierarchical datasource implementation.
 */
export class GridHierarchySource extends GridDefaultSource implements IGridSource {
    private _expandStates;
    constructor(items: IGridHierarchyItem[]);
    getExpandStates(): any[];
    protected _updateSource(items: IGridHierarchyItem[]): void;
    private _prepareItems;
}
/**
 * @publicapi
 */
export class GridO<TOptions extends IGridOptions> extends Controls.Control<TOptions> {
    static enhancementTypeName: string;
    static MAX_COPY_SIZE: number;
    static PAYLOAD_SIZE: number;
    static EVENT_ROW_UPDATED: string;
    static EVENT_ROW_TOGGLED: string;
    static EVENT_SELECTED_INDEX_CHANGED: string;
    static DATA_DRAGGING_ROWINFO: string;
    static DATA_DROPPING_ROWINFO: string;
    private static TOOLTIP_TARGET_SELECTOR;
    private _selectionStart;
    private _header;
    private _gutterHeader;
    private _columnSizing;
    private _columnMoving;
    private _columnMovingElement;
    private _columnMovingPinElement;
    private _columnInsert;
    private _unitEx;
    private _sizingElement;
    private _ddRowAcceptStatus;
    private _ddRowOverStatus;
    private _ddDropStarted;
    private _activeAriaId;
    private _copyInProgress;
    private _previousCanvasHeight;
    private _previousCanvasWidth;
    private _$popupMenuPinTarget;
    private _showingContextMenu;
    private _automaticContextMenuColumn;
    private _contextMenuKeyPressedState;
    private _lastFocusTime;
    /**
     *  Offset height, that shifts the row boundaries up and determines whether the pointer is over a particular row or not
     *  e.g. An offset percentage (passed in by the consumer of the grid) of 50 shifts each row boundary up half the row height for the purposes of calculating whether the mouse
     *  pointer is over the current row or not. The net effect of this is, if the pointer is in the top half of the current row/bottom half of the previous row,
     *  then the pointer is assumed to interesect with the current row.
     */
    private _rowOffsetHeight;
    private _isAboveFirstOrBelowLastRow;
    _contentSpacer: any;
    _dataSource: any[];
    /**
     * For a tree grid, the number of children the row has. If the row is not expanded, it's the negative of the number of children it has.
     */
    _expandStates: number[];
    /**
     * For a tree grid, the nesting level of the row.
     */
    _indentLevels: number[] | null | undefined;
    _columns: IGridColumn[];
    _sortOrder: any[];
    _visibleRange: any[];
    _count: number;
    _expandedCount: number;
    _selectedIndex: number;
    _indentIndex: number;
    _selectionCount: number;
    _selectedRows: any;
    _rowHeight: number;
    _cellOffset: number;
    _gutterWidth: number;
    _contentSize: any;
    _rows: any;
    _scroller: any;
    _canvasDroppable: JQuery;
    _canvas: JQuery;
    _canvasHeight: number;
    _canvasWidth: number;
    _headerCanvas: JQuery;
    _gutter: JQuery;
    _popupMenu: Menus.PopupMenu;
    _resetScroll: boolean;
    _ignoreScroll: boolean;
    _scrollTop: number;
    _scrollLeft: number;
    _droppable: any;
    _draggable: any;
    _draggingRowInfo: any;
    _cancelable: any;
    _active: boolean;
    _cellMinWidth: number;
    private _draggableOverGrid;
    private _tooltip;
    private _tooltipMouseOverHandler;
    private _tooltipMouseOutHandler;
    private _focusStateData;
    private _focusedElement;
    /**
     * Deprecated.  Please use _canvas instead.
     */
    _focus: JQuery;
    /**
     * Creates new Grid Control
     *
     * @param options The initialization options for the grid which have the following properties
     *
     *    "columns" is a required property containing the array of grid column descriptors that have the following structure:
     *    {
     *        index: The index for the
     *        text:      column header text, string, optional, default: "",
     *        width:     width in pixels of the column, number, optional, default: 100,
     *        canSortBy: true if the grid can be sorted by the column, boolean, optional, default: true
     *        canMove: true if this column can be moved (has effect only if allowMoveColumns is set to true for the grid as well), boolean, optional, default: true
     *        getCellContents: function that returns cell contents, function, optional, default: this._drawCell
     *            The function takes the same parameters as _drawCell and should return a jQuery object
     *            that represents the cell's contents. The first element will be appended to the row.
     *            If the function returns null or undefined nothing will be appended for that cell.
     *        getHeaderCellContents: function that returns column header cell contents, function, optional, default: this._drawHeaderCellValue
     *            The function takes the same parameters as _drawHeaderCellValue and should return a jQuery object
     *            that represents the cell's contents. The first element will be appended to the header cell's contents.
     *            If the function returns null or undefined nothing will be appended for that header cell.
     *        getColumnValue: function that returns the value for a cell contents, function, optional, default: this.getColumnValue;
     *            The return value of the function will be converted to a string an added as the cell contents.
     *    }
     *    "enabledEvents" is an optional property containing an object with properties for each of the enabled events.
     *    {
     *        GridO.EVENT_ROW_UPDATED: true
     *    }
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * Gets the number of selected items.
     * @returns {number}
     * @publicapi
     */
    getSelectionCount(): number;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    initialize(): void;
    /**
     * Gets the row information for the item currently being dragged.
     *
     * @return
     */
    getDraggingRowInfo(): any;
    /**
     * Get the rows that currently have a draggable item "over" them
     */
    _getDragOverRows(): any;
    _getAcceptStatus(dataIndex: number): any;
    /**
     * Clear the cached row acceptance map
     */
    _resetRowAcceptStatus(): void;
    /**
     * See if the row has accepted and activate if it has.
     */
    _rowDropTryActivate(droppingRowInfo: any, e?: any, ui?: any): any;
    _rowIntersect(draggable: any, targetRowInfo: any): any;
    private _calculateIntersectPosition;
    initializeDataSource(suppressRedraw?: boolean): void;
    /**
     * Sets the initial selected index.
     */
    selectInitialRow(): void;
    /**
     * Sets the source of the grid using GridSource object.
     *
     * @param source GridSource object to set the grid source.
     * @publicapi
     */
    setDataSource(source: IGridSource): void;
    /**
     * Sets the data source, expands states, columns and sort order of the grid.
     *
     * @param source New source for the grid (See grid options for details).
     * @param expandStates Expand states for the new source. If source is not in hierarchical structure, specify null (See grid options for details).
     * @param columns New columns for the grid (See grid options for details).
     * @param sortOrder New sort order for the grid (See grid options for details).
     * @param selectedIndex Index of the rows to be selected after new data source is set.
     * @param suppressRedraw If true, grid is not redrawn after data source is set.
     * @publicapi
     */
    setDataSource(source?: any[], expandStates?: number[], columns?: IGridColumn[], sortOrder?: IGridSortOrder[], selectedIndex?: number, suppressRedraw?: boolean): any;
    _setColumnInfo(column: IGridColumn, index: number): void;
    /**
     * Gets the information about a row associated with the given data index.
     *
     * Returns a rowInfo object containing rowIndex, dataIndex and a jQuery wrapper for the actual row.
     *
     * @param dataIndex The data index for the record to retrieve.
     * @returns {IGridRowInfo}
     * @publicapi
     */
    getRowInfo(dataIndex: number): IGridRowInfo;
    /**
     * Gets the data being used to display the row at the provided data index.
     *
     * @param dataIndex The data index for the record to retrieve.
     * @return {any}
     * @publicapi
     */
    getRowData(dataIndex: number): any;
    /**
     * Gets the columns currently being displayed in the grid.
     * @returns {IGridColumn[]}
     * @publicapi
     */
    getColumns(): IGridColumn[];
    /**
     * Gets the current sort order being used in the grid.
     * @returns {IGridSortOrder[]}
     * @publicapi
     */
    getSortOrder(): IGridSortOrder[];
    /**
     * Set new column info for the column associated with the specified column name.
     *
     * @param columnName Name of the column to change the options.
     * @param options New column options.
     * @publicapi
     */
    setColumnOptions(columnName: string, options?: IGridColumn): void;
    _getDataIndex(visibleIndex: any): any;
    _getRowIndex(dataIndex: any): number;
    expandNode(dataIndex: any): void;
    collapseNode(dataIndex: any): void;
    expandAllNodes(): boolean;
    collapseAllNodes(): boolean;
    /**
     * Expands all rows of the grid (if source data is hierarchical).
     * @publicapi
     */
    expandAll(): void;
    /**
     * Collapses all rows of the grid (if source data is hierarchical).
     * @publicapi
     */
    collapseAll(): void;
    /**
     * Expands all rows at or below specified level (if source data is hierarchical).
     *
     * @param level Level to expand.
     * @publicapi
     */
    expandByLevel(level: number): void;
    /**
     * Collapses all rows at or below specified level (if source data is hierarchical).
     *
     * @param level Level to collapse.
     * @publicapi
     */
    collapseByLevel(level: number): void;
    /**
     * Expand or collapse node(s), and set selection focus at a given target index or at the current selected index as default behavior.
     *
     * @param expand If true, expands the node, otherwise collapsed.
     * @param applyToAllRows True to expand or collapse all nodes, false to expand or collapse the node at a given target index, or at the current selected index as default behavior.
     * @param targetIndex The node index to be expanded or collapsed, and get selection focus.
     * @returns {boolean}
     * @publicapi
     */
    tryToggle(expand: boolean, applyToAllRows: boolean, targetIndex?: number): boolean;
    _getVisibleRowIndices(): {
        first: number;
        last: number;
    };
    /**
     * @param rowIndex
     * @param force
     * @return
     */
    _getRowIntoView(rowIndex: number, force?: boolean): boolean;
    /**
     * @param force
     */
    getSelectedRowIntoView(force?: boolean): boolean;
    cacheRows(aboveRange: any, visibleRange: any, belowRange: any): void;
    _drawRowsInternal(visibleRange: any, includeNonDirtyRows: any): {
        rowsFragment: any;
        gutterFragment: any;
    };
    /**
     * Sets up full-row bowtie styling whether hovering over the main row or the row gutter.
     */
    private setupFullRowHover;
    _drawRows(visibleRange: any, includeNonDirtyRows: any): void;
    /**
     * Updates the row identified by the given rowIndex.
     *
     * @param rowIndex Index of row to be updated
     * @param dataIndex DataIndex of row to be updated
     * @param columnsToUpdate HashSet of column indices. If given,
     * only columns in this set will be updated.
     */
    updateRow(rowIndex: number, dataIndex?: number, columnsToUpdate?: {
        [id: number]: boolean;
    }): void;
    _updateRow(rowInfo: any, rowIndex: any, dataIndex: any, expandedState: any, level: any, columnsToUpdate?: {
        [id: number]: boolean;
    }): void;
    private _rowHasContextMenu;
    private _addContextMenuContainer;
    /**
     * Updates the container element for the row identified by rowIndex
     *
     * @param rowIndex Index of row to be updated
     * @param keepContent If set, the content of the container element (i.e.,
     * any column data) will not be removed
     * @return Returns DOM row container element
     */
    _updateRowSize(rowIndex: number, row: any, keepContent?: boolean): any;
    /**
     * Default implementation for creating the contents of a given cell.
     *
     * Custom Drawn Columns:
     * If you want a custom drawn column, then the preferred method is to set a "getCellContents" property
     * on the column to a function that takes the same parameters as this function and returns a jQuery
     * object that represents the contents.
     *
     * @param rowInfo The information about grid row that is being rendered.
     * @param dataIndex The index of the row.
     * @param expandedState Number of children in the tree under this row recursively.
     * @param level The hierarchy level of the row.
     * @param column Information about the column that is being rendered.
     * @param indentIndex Index of the column that is used for the indentation.
     * @param columnOrder The display order of the column.
     * @return Returns jQuery element representing the requested grid cell. The first returned element will be appended
     * to the row (unless the function returns null or undefined).
     */
    _drawCell(rowInfo: any, dataIndex: number, expandedState: number, level: number, column: any, indentIndex: number, columnOrder: number): any;
    /**
     * Default implementation for creating the element that represents content of a header cell.
     *
     * Custom Drawn Column Header:
     * If you want a custom drawn column header, then the preferred method is to set a "getHeaderCellContents" property
     * on the column to a function that takes the same parameters as this function and returns a jQuery
     * object that represents the contents.
     *
     * @param column Information about the header column that is being rendered.
     * @return Returns jQuery element representing the requested header cell contents.
     */
    _drawHeaderCellValue(column: any): JQuery;
    protected _isIndentedHeaderColumn(column: any): boolean;
    _layoutHeader(): void;
    layout(): void;
    redraw(): void;
    /**
     * Gets the value for a column. The default use of the return value is to
     * convert it to a string and set it as the cell's text value.
     *
     * @param dataIndex The index for the row data in the data source
     * @param columnIndex The index of the column's data in the row's data array
     * @param columnOrder The index of the column in the grid's column array. This is the current visible order of the column
     * @return
     */
    getColumnValue(dataIndex: number, columnIndex: number | string, columnOrder?: number): any;
    getColumnText(dataIndex: any, column: any, columnOrder?: any): any;
    _getExpandState(dataIndex: any): number;
    /**
     * @param rowIndex
     * @param dataIndex
     * @param options
     */
    _selectRow(rowIndex: number, dataIndex?: number, options?: any): void;
    /**
     * @return
     */
    getSelectedRowIndex(): number;
    setSelectedRowIndex(selectedRowIndex: any): void;
    /**
     * @return
     */
    getSelectedDataIndex(): number;
    /**
     * @return The last data index of the grid
     */
    getLastRowDataIndex(): number;
    /**
     * @return
     */
    getSelectedDataIndices(): number[];
    /**
     * Ensures that an item (identified by a data index) has an associated row by
     * expanding any enclosing collapsed rows. Returns the rowIndex of the associated row.
     *
     * @param dataIndex The data index of the item to ensure is expanded
     * @return
     */
    ensureDataIndexExpanded(dataIndex: number): number;
    /**
     * Sets the selected item in the grid by the data index.
     * Optionally ensure that the item is not hidden by collapsed rows.
     *
     * @param dataIndex The data index of item to show
     * @param expandNodes If true, all containing collapsed nodes will be expanded
     */
    setSelectedDataIndex(dataIndex: number, expandNodes?: boolean): void;
    selectionChanged(selectedIndex: any, selectedCount: any, selectedRows: any): void;
    selectedIndexChanged(selectedRowIndex: any, selectedDataIndex: any): void;
    _updateRowSelectionStyle(rowInfo: any, selectedRows: any, focusIndex: any): void;
    /**
     * @param timeout
     */
    focus(timeout?: number): void;
    /**
     * Gets info about the row on which context menu is opened.
     *
     * If no context menu is open, returns null.
     *
     * @returns {IGridRowInfo}
     * @publicapi
     */
    getContextMenuRowInfo(): IGridRowInfo;
    /**
     * Creates the context menu options. This function is intended to be overriden by derived objects.
     *
     * @param rowInfo The information about the row with context
     * @param menuOptions The menu information. See _createContextPopupMenuControl
     * @return
     */
    _createContextMenu(rowInfo: any, menuOptions: any): Menus.PopupMenu;
    /**
     *     Creates the PopupMenu control that houses the context menu items for the Grid. Note: this is intentionally
     *     abstracted from _createContextMenu to allow directly calling it from deep derivations and avoiding inheritance
     *     base propagation.
     *
     * @param menuOptions
     *     The menu information:
     *     {
     *         contextInfo: { item, rowInfo}
     *         items: the list of menu items
     *     }
     *
     * @return
     */
    _createContextPopupMenuControl(menuOptions: any): Menus.PopupMenu;
    /**
     * @param e
     * @return
     */
    _onContainerResize(e?: JQueryEventObject): any;
    /**
     * @return
     */
    _onColumnResize(column: any): any;
    /**
     * @return
     */
    _onColumnMove(sourceIndex: any, targetIndex: any): any;
    /**
     * @param column
     * @param add
     */
    _sortBy(column?: any, add?: boolean): void;
    /**
     * @param sortOrder
     * @param sortColumns
     * @return
     */
    onSort(sortOrder: any, sortColumns?: any): any;
    /**
     * @param sortOrder
     * @param sortColumns
     * @return
     */
    _trySorting(sortOrder: any, sortColumns?: any): any;
    /**
     * Finds the closest comparable ancestors of two elements
     * Comparable ancestors are ancestor gridItems which share the same parent gridItem
     * @param zippedArray
     * @param elemA
     * @param elemB
     * @return
     */
    private _getComparableAncestors;
    /**
     * @param e
     * @param selector
     */
    _getRowInfoFromEvent(e?: JQueryEventObject, selector?: string): any;
    /**
     * Handles the row mouse down event
     * @param e
     * @return
     */
    _onRowMouseDown(e?: JQueryEventObject): any;
    /**
     * @return
     */
    onRowMouseDown(eventArgs: any): any;
    /**
     * Handles the row mouse up event
     * @param e
     * @return
     */
    _onRowMouseUp(e?: JQueryEventObject): any;
    /**
     * @param eventArgs
     * @return
     */
    onRowMouseUp(eventArgs: JQueryEventObject): any;
    /**
     * @return
     */
    onRowClick(eventArgs: any): any;
    /**
     * @return
     */
    onRowDoubleClick(eventArgs: any): any;
    /**
     * @return
     */
    onGutterClick(eventArgs: any): any;
    /**
     * @return
     */
    onEnterKey(eventArgs: any): any;
    /**
     * @return
     */
    onDeleteKey(eventArgs: any): any;
    _onOpenRowDetail(e?: any, eventArgs?: any): boolean;
    /**
     * @return
     */
    onOpenRowDetail(eventArgs: any): any;
    /**
     * @return
     */
    onContextMenu(eventArgs: any): any;
    /**
     * @param e
     * @return
     */
    _onBlur(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    _onFocus(e?: JQueryEventObject): any;
    _onKeyPress(e?: JQueryKeyEventObject): any;
    /**
     * @param e
     * @return
     */
    _onKeyDown(e?: JQueryKeyEventObject): any;
    _onBackSpaceKey(e?: JQueryKeyEventObject): void;
    _onUpKey(e?: JQueryKeyEventObject, bounds?: any): void;
    _onDownKey(e?: JQueryKeyEventObject, bounds?: any): void;
    _onRightKey(e?: JQueryKeyEventObject): void;
    _onLeftKey(e?: JQueryKeyEventObject): void;
    private _onHorizontalArrowKey;
    _onPageUpPageDownKey(e?: JQueryKeyEventObject, bounds?: any): void;
    _getRowsPerPage(e?: BaseJQueryEventObject): number;
    _onHomeKey(e?: JQueryKeyEventObject, bounds?: any): void;
    _onEndKey(e?: JQueryKeyEventObject, bounds?: any): void;
    _onTabKey(e?: JQueryKeyEventObject): void;
    _onEscapeKey(e?: JQueryKeyEventObject): void;
    /**
     * @param e
     * @return
     */
    _onKeyUp(e?: JQueryKeyEventObject): any;
    private _focusHeader;
    protected _getFocusableHeaderElement(): JQuery;
    protected _getHeaderSortColumn(className: string): JQuery;
    /**
     * Enables raising the custom event with the provided event name.
     *
     * @param eventName Name of the event to enable.
     */
    enableEvent(eventName: string): void;
    /**
     * Disables raising the custom event with the provided event name.
     *
     * @param eventName Name of the event to disable.
     */
    disableEvent(eventName: string): void;
    /**
     * Gets the collection of expand states for the grid.
     */
    getExpandStates(): number[];
    /**
     * Generates a table of the selected items in the grid.
     *
     * @param operationCompleteCallback A callback function invoked when the
     * current selection is available to the client for processing.
     * @param errorCallback
     */
    beginFormatTable(operationCompleteCallback: IResultCallback, errorCallback?: IErrorCallback, formatterType?: new (grid: GridO<TOptions>, options?: any) => ITableFormatter, options?: any): void;
    _createElement(): void;
    protected _addSpacingElements(): void;
    /**
     * Obsolete, unused.
     */
    _createFocusElement(): JQuery;
    private _getMode;
    private _getRole;
    private _buildDom;
    /**
     * Gets the Focus Element for the Grid.
     *
     * This is the actual element that receives focus and that all the event bindings, like 'keydown', are bound to.
     */
    getFocusElement(): JQuery;
    _shouldAttachContextMenuEvents(): boolean;
    _attachEvents(): void;
    _getDraggedRowsInfo(e?: JQueryEventObject): any;
    private _setupDragDrop;
    /**
     * Setup the provided draggable and droppable options
     */
    setupDragDrop(draggableOptions: any, droppableOptions: any): void;
    disableDragDrop(): void;
    enableDragDrop(): void;
    /**
     * Delegate out to the row accept handlers to determine if the dragging item will be accepted.
     */
    private _droppableAcceptHandler;
    private _droppableDropHandler;
    /**
     * Called when an item is being dragged that will be accepted by rows in this grid.
     */
    private _droppableActivateHandler;
    /**
     * Called when an item stops being dragged that will be accepted by rows in this grid.
     */
    private _droppableDeactivateHandler;
    /**
     * Called when a draggable item is over the grid.
     */
    private _droppableOverHandler;
    /**
     * Called when a draggable item is no longer over the grid.
     */
    private _droppableOutHandler;
    /**
     * Called when the mouse moves while the draggable item is over the grid.
     *
     * @param outOfGrid Indicates if this move event is being triggered as the mouse is leaving the grid.
     */
    private _droppableOverMoveHandler;
    /**
     * Gets the draggable instance from the element which is being dragged.
     */
    private _getDraggable;
    /**
     * Clean up all state stored during drag/drop operations.
     */
    private _cleanupDragDropState;
    /**
     * Unregister the mouse move event which is setup during drag/drop operations.
     */
    private _unregisterDragMouseMove;
    /**
     * Clear the record of which rows the draggable objects are "over"
     */
    private _resetRowOverStatus;
    private _rowDropAccept;
    private _rowDropActivate;
    private _rowDropDeactivate;
    private _rowDropOver;
    private _rowDropOut;
    private _rowDrop;
    private _rowDragCreateHelper;
    /**
     * Invokes the provided handler
     */
    private _invokeDragHandler;
    private _takeMeasurements;
    /**
     *     Ensures that the selected index is correctly set. That is, it will be a noop if the index doesnt change
     *     and will handle indexes that are out of bounds.
     *
     * @param index OPTIONAL: The index to select
     */
    private _ensureSelectedIndex;
    _determineIndentIndex(): void;
    private _updateRanges;
    private _updateExpansionStates;
    private _updateExpansionStateAndRedraw;
    /**
     * @param includeNonDirtyRows
     */
    _updateViewport(includeNonDirtyRows?: boolean): void;
    private _setContextMenuColumn;
    _cleanUpRows(): void;
    private _getGutterIconClass;
    private _drawGutterCell;
    _drawHeader(): void;
    private _fixColumnsWidth;
    _layoutContentSpacer(): void;
    _fixScrollPos(): void;
    /**
     * @param includeNonDirtyRows
     */
    _redraw(includeNonDirtyRows?: boolean): void;
    selectAll(): void;
    /**
     * Clear the selected rows & selection count, but maintain the selected index.
     */
    _clearSelection(): void;
    /**
     * Highlights the row at the specified rowIndex
     *
     * @param rowIndex Index of the row in the visible source (taking the expand/collapse states into account)
     * @param dataIndex Index of the row in the overall source
     * @param options Specifies options such as:
     *     - keepSelectionStart: Keepd the rowIndex as the basis for range selection
     *     - doNotFireEvent: Prevents firing events
     *     - toggle: Toggles the row in the selection
     */
    _addSelection(rowIndex: number, dataIndex?: number, options?: any): void;
    private _updateRowActionList;
    private _setFocusedGridElement;
    /**
     * Highlights the rows beginning from the selection start until the row at the specified rowIndex
     *
     * @param rowIndex Index of the row in the visible source (taking the expand/collapse states into account)
     * @param dataIndex Index of the row in the overall source
     */
    private _addSelectionRange;
    /**
     * This is especially necessary for screen readers to read each
     * row when the selection changes.
     */
    private _updateActiveDescendant;
    private _updateAriaProperties;
    private _updateSelectionStyles;
    private _selectionChanged;
    private _selectedIndexChanged;
    _showContextMenu(eventArgs: any): void;
    getPinAndFocusElementForContextMenu(eventArgs: any): {
        pinElement: JQuery;
        focusElement: JQuery;
    };
    /**
     * @param e
     * @return
     */
    _onContainerMouseDown(e?: JQueryEventObject): any;
    _measureCanvasSize(): void;
    private _setupDragEvents;
    private _clearDragEvents;
    /**
     * @param e
     * @return
     */
    private _onDocumentMouseMove;
    /**
     * @param e
     * @return
     */
    private _onDocumentMouseUp;
    /**
     * @param e
     * @return
     */
    private _onHeaderMouseDown;
    /**
     * @param e
     * @return
     */
    private _onHeaderMouseUp;
    /**
     * @param e
     * @return
     */
    _onHeaderClick(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    _onHeaderDblClick(e?: JQueryEventObject): any;
    protected _onHeaderKeyDown(e?: JQueryEventObject): void;
    protected _onHeaderScroll(e?: JQueryEventObject): void;
    protected _getNextHeaderElement($target: JQuery): JQuery;
    protected _getPreviousHeaderElement($target: JQuery): JQuery;
    private _moveSizingElement;
    /**
     *     Given a column index will provide the visible index of this column. That is, it will take in to consideration any
     *     hidden columns and omit them from the index count.
     *
     * @param columnIndex The 0-based global column index
     * @return The 0-based visible column index
     */
    private _getVisibleColumnIndex;
    /**
     * @param columnIndex
     * @param initialWidth
     * @param finish
     */
    _applyColumnSizing(columnIndex: number, initialWidth?: number, finish?: boolean): void;
    _tryFinishColumnSizing(cancel: any): void;
    /**
     * @param columnIndex
     * @param left
     */
    private _moveColumnMovingElement;
    private _applyColumnMoving;
    private _tryFinishColumnMoving;
    _getSortColumns(sortOrder: any): any[];
    /**
     * @param sortOrder
     * @param sortColumns
     * @return
     */
    private _onSort;
    /**
     * @param e
     * @return
     */
    _onSelectStart(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    _onCanvasScroll(e?: JQueryEventObject): any;
    /**
     * @param e
     * @param handler
     * @param eventName
     * @param args
     */
    private _handleEvent;
    /**
     * @param e
     * @return
     */
    _onRowClick(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    _onRowDoubleClick(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    private _onGutterClick;
    /**
     * @param e
     * @return
     */
    _onEnterKey(e?: JQueryKeyEventObject, bounds?: any): any;
    /**
     * @param e
     * @return
     */
    _onDeleteKey(e?: JQueryKeyEventObject): any;
    /**
     * @param e
     * @return
     */
    protected _onContextMenu(e?: JQueryEventObject, args?: any): any;
    /**
     * @return
     */
    private _onToggle;
    private _isAncestorFolderToggled;
    ancestorFolderToggled(rowInfo: any): void;
    nonAncestorFolderToggled(rowInfo: any, currSelectedDataIndex: any): void;
    afterOnToggle(rowInfo: any): void;
    private _folderToggled;
    private _raiseToggleEvent;
    copySelectedItems(formatterType?: new (grid: GridO<TOptions>, options?: any) => ITableFormatter, copyAsHtml?: boolean, options?: any): void;
    _ensureRowDrawn(dataIndex: any): boolean;
    private _onMouseOver;
    private _onMouseOut;
    /**
     * Ensures that all data objects in the selection have been downloaded and are available to process.
     *
     * @param itemsAvailableCallback
     * @param errorCallback
     */
    _beginEnsureSelectionIsAvailable(itemsAvailableCallback?: IResultCallback, errorCallback?: IErrorCallback): void;
    _dispose(): void;
}
export class Grid extends GridO<IGridOptions> {
}
export class ListView extends Grid {
    static enhancementTypeName: string;
    constructor(options?: any);
}
export class GridSearchAdapter extends Search.SearchAdapter<any> {
    private _grid;
    private _gridData;
    private _results;
    private _searchableColumns;
    constructor();
    /**
     *     Attaches the Grid to the filter provider to allow for retrieval of paged data.
     *     The grid is loaded asynchronously, so can't be attached on page load when initialized.
     *
     * @param grid The grid to get data from
     */
    attachGrid(grid: Grid): void;
    /**
     * Adds additional items to the search strategy
     *
     * @param addItemsCallback The function which adds items to the search strategy.
     * @param searchCallback The function which searches the newly updated strategy.
     */
    addMoreItems(addItemsCallback: Function, searchCallback: () => any): void;
    /**
     * Creates SearchableObjects for all available work items
     *
     * @return An array of SearchableObjects.
     */
    createSearchableObjects(): Search.SearchableObject<any>[];
    /**
     *     Handles the results in the UI by filtering through all available items to the ones
     *     provided in the results array.
     *
     * @param results An array of items
     * @param finished Represents whether or not the search is finished
     */
    handleResults(results: any[], finished: boolean): void;
    /**
     *     Handles an error being thrown in the search process.
     *
     * @param message Specific error message if provided.
     */
    handleError(message: string): void;
    /**
     *     Handles the search results being cleared and the view resetting to normal.
     */
    handleClear(): void;
    /**
     *     Returns whether or not there is more data to be loaded.
     *
     * @return True if no more data needs to be loaded, false otherwise
     */
    isDataSetComplete(): boolean;
    /**
     *     Build the list of searchable columns.
     */
    private getSearchableColumns;
}
export interface ITableFormatter {
    /**
     * Gets the formatted items as string.
     */
    getTableFromSelectedItems(): string;
    /**
     * Determines whether the formatted string includes html or not.
     */
    includesHtml?: boolean;
}
export class TabDelimitedTableFormatter implements ITableFormatter {
    _options: any;
    _grid: Grid;
    constructor(grid: Grid, options?: any);
    /**
     * Iterates through the selected rows and builds a table containing the results.
     *
     * @return A tab-delimited plain-text table containing all rows and all columns in the current selection.
     */
    getTableFromSelectedItems(): string;
    getFormattedColumnValue(column: any, value: string): string;
}
export class HtmlTableFormatter implements ITableFormatter {
    _options: any;
    _grid: Grid;
    includesHtml: boolean;
    constructor(grid: Grid, options?: any);
    processColumns(columns: any[]): any[];
    getTableFromSelectedItems(): string;
    getFormattedColumnValue(column: any, value: string): string;
    protected _getSelectedDataIndicesFromGrid(): number[];
}
}
declare module "VSS/Controls/Header" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS/Controls/Header" />
import Contributions_Contracts = require("VSS/Contributions/Contracts");
import Controls = require("VSS/Controls");
export interface ContributableHeaderOptions extends Controls.EnhancementOptions {
    contributionId?: string;
    elementContributionType?: string;
    context?: any;
}
export class ContributableHeader<TOptions extends ContributableHeaderOptions> extends Controls.Control<TOptions> {
    initializeOptions(options?: ContributableHeaderOptions): void;
    protected renderContributions(): void;
    protected filterContributions(contributions: Contributions_Contracts.Contribution[]): Contributions_Contracts.Contribution[];
    protected groupContributionsByAlignment(contributions: Contributions_Contracts.Contribution[]): IDictionaryStringTo<Contributions_Contracts.Contribution[]>;
    private renderContributedSection;
}
export interface HeaderModel {
    brandIcon: string;
    brandName: string;
    context: any;
    contributionId: string;
    elementContributionType: string;
    supportsContribution: boolean;
    userDisplayName: string;
}
/**
 * @exemptedapi
 */
export class Header<TModel extends HeaderModel> extends ContributableHeader<TModel> {
    initialize(): void;
    protected renderLeftSection(container: JQuery): void;
    protected renderRightSection(container: JQuery): void;
}
}
declare module "VSS/Controls/Histogram" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
export interface HistogramBarData {
    /**
     * Value of the bar.
     */
    value?: number;
    /**
     * Text value displayed when the bar is hovered.
     */
    title?: string;
    /**
     * State of the bar which effects vizualization.
     */
    state?: string;
    /**
     * Specifies whether the bar is selected or not.
     */
    selected?: boolean;
    /**
     * Action of this bar.
     */
    action?: Function;
    /**
     * Action arguments.
     */
    actionArgs?: any;
}
export interface IHistogramOptions extends Controls.EnhancementOptions {
    /**
     * List of bars to display in the histogram.
     */
    bars?: HistogramBarData[];
    /**
     * A generator function to return a list of bars to display in the histogram.
     */
    barGenerator?: () => HistogramBarData[];
    /**
     * Determines whether to render default bars before actual bar data loaded.
     */
    renderDefaultBars?: boolean;
    /**
     * Number of bars to display.
     */
    barCount?: number;
    /**
     * Width of a bar in px.
     */
    barWidth?: number;
    /**
     * Height of a bar in px.
     */
    barHeight?: number;
    /**
     * Space between the bars in px.
     */
    barSpacing?: number;
    /**
     * Hover state.
     */
    hoverState?: string;
    /**
     * Selected state.
     */
    selectedState?: string;
    /**
     * Determines whether the interaction is allowed or not.
     */
    allowInteraction?: boolean;
}
export class HistogramO<TOptions extends IHistogramOptions> extends Controls.Control<TOptions> {
    constructor(options?: any);
    initialize(): void;
    refresh(items: HistogramBarData[]): void;
    _clearBars(): void;
    _getBarCount(): number;
    private _getBarWidth;
    private _getBarSpacing;
    private _getBarMaxHeight;
    private _load;
    private _decorate;
    private _renderDefaultBars;
    private _renderBars;
    /**
     * @param index
     * @param item
     * @return
     */
    private _createBar;
}
export class Histogram extends HistogramO<IHistogramOptions> {
}
}
declare module "VSS/Controls/KeyboardShortcuts" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
/// <amd-dependency path="VSS/LoaderPlugins/Css!widget" />
/**
 * Constants for well known shortcut keys.
 *
 * Example combo would be ShortcutKeys.ALT + "+q";
 */
export module ShortcutKeys {
    var ALT: string;
    var CONTROL: string;
    var SHIFT: string;
}
/**
 * NOTICE:
 * This interface is equivalent to mousetrap's ExtendedKeyboardEvent, but
 * we duplicate it to avoid adding an extra dependency on @types/mousetrap
 * for consumers of the vss sdk.
 */
export interface IEKeyboardEvent extends KeyboardEvent {
    returnValue: boolean;
}
export type KeyboardAction = (e: IEKeyboardEvent, combo: string) => void;
export interface IShortcutGroup {
    /**
     *  The name of the group
     */
    name: string;
    /**
     * The list of shortcuts in the group
     */
    shortcuts: IShortcut[];
}
export interface IShortcut extends IShortcutOptions {
    /**
     * Shortcut combinations that map to this action
     */
    combos: string[];
    /**
      * Shortcut combinations to display on the help dialog
      */
    combosToDisplay: string[];
}
export interface IShortcutOptions {
    /**
     * Description of the shortcut
     */
    description: string;
    /**
     * Action which gets called when shortcut is pressed
     */
    action: KeyboardAction;
    /**
     * The Dom Element to bind the shortcut to
     */
    element?: Element;
    /**
     * Defaults to false. Pass in True if you would like the shortcut to be hidden from the help dialog
     */
    hideFromHelpDialog?: boolean;
    /**
     * Defaults to false. Use true in the rare case that you want the last key of the chord to propagate to the focused element
     */
    allowPropagation?: boolean;
    /**
     * List combos which you want to be always active even if the user has focus on an input box
     */
    globalCombos?: string[];
    /**
     * Is this a navigation shortcurt? If so, we will handle reseting shortcuts so
     * if this is an in memory navigation you don't have mixed shortcut state
     */
    isPageNavigationShortcut?: boolean;
}
/**
* ShortcutManager handles registering multiple groups of keyboard shortcuts
*/
export interface IShortcutManager {
    /**
    * Gets the shortcut groups
    */
    getShortcutGroups(): IShortcutGroup[];
    /**
     * Register a shortcut
     * @param group Name of a shortcut group.
     * @param combo Keyboard combination.
     * @param description Description of the shortcut
     * @param action Action which gets called when shortcut is pressed
     * @param allowPropagation Defaults to false. Use true in the rare case that you want the last key of the chord to propagate to the focused element
     *
     * @returns ShortcutManager
     */
    registerShortcut(group: string, combo: string, description: string, action: KeyboardAction, allowPropagation?: boolean): IShortcutManager;
    /**
     * Unregister a shortcut
     * @param group Name of a shortcut group.
     * @param combo Keyboard combination.
     * @param action Action which gets called when shortcut is pressed
     *
     */
    unRegisterShortcut(group: string, combo: string): void;
    /**
     * Register a group of shortcuts
     * @param group Name of a shortcut group.
     * @param combos Keyboard combinations that all map to same action.
     * @param description Description of the shortcut
     * @param action Action which gets called when shortcut is pressed
     * @param allowPropagation Defaults to false. Use true in the rare case that you want the last key of the chord to propagate to the focused element
     *
     * @returns ShortcutManager
     */
    registerShortcuts(group: string, combos: string[], description: string, action: KeyboardAction, allowPropagation?: boolean): IShortcutManager;
    /**
     * Register a shortcut
     * @param group Name of a shortcut group.
     * @param combo Keyboard combination.
     * @param options The options to configure this shortcut with
     *
     * @returns ShortcutManager
     */
    registerShortcut(group: string, combo: string, options: IShortcutOptions): IShortcutManager;
    /**
     * Register a group of shortcuts
     * @param group Name of a shortcut group.
     * @param combos Keyboard combinations that all map to same action.
     * @param options The options to configure this shortcut with
     *
     * @returns ShortcutManager
     */
    registerShortcuts(group: string, combos: string[], options: IShortcutOptions): IShortcutManager;
    /**
     * Removes a group of shortcuts
     * This is used when a group of shortcuts is no longer applicable and you want to de-register them. For example,
     * if you had a ajax popup that needed its own shortcuts but you want to clear those when it is closed.
     *
     * NOTE: This will remove all shortcuts for a given group regardless of where they were registered from.
     *
     * @param group Name of a shortcut group.
     */
    removeShortcutGroup(group: string): any;
    /**
     * Show the shortcut dialog
     *
     * @param onClose Optional callback that is called when the shortcut dialog is closed.
     */
    showShortcutDialog(onClose?: () => void): void;
}
export class ShortcutManager implements IShortcutManager {
    private static AREA;
    private static FEATURE;
    private static _instance;
    static getInstance(): IShortcutManager;
    private _registeredCombos;
    private _shortcutsGroups;
    private _shortcutDialog;
    private _globalCombos;
    private _originalStopCallback;
    constructor();
    private reset;
    getShortcutGroups(): IShortcutGroup[];
    getGlobalCombos(): string[];
    registerShortcut(group: string, combo: string, description: string, action: KeyboardAction, allowPropagation?: boolean): ShortcutManager;
    registerShortcut(group: string, combo: string, options: IShortcutOptions): ShortcutManager;
    registerShortcuts(group: string, combos: string[], description: string, action: KeyboardAction, allowPropagation?: boolean): ShortcutManager;
    registerShortcuts(group: string, combos: string[], options: IShortcutOptions): ShortcutManager;
    unRegisterShortcut(group: string, combo: string): void;
    removeShortcutGroup(group: string): void;
    showShortcutDialog(onClose?: () => void): void;
    private renderDialogContent;
    private renderShortcutGroups;
    private renderShortcut;
    private renderGroup;
    private renderHelpLink;
}
}
declare module "VSS/Controls/Menus" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Contributions_Services = require("VSS/Contributions/Services");
import Controls = require("VSS/Controls");
export var menuManager: IMenuManager;
/**
 * Amount of time in ms after a blur that a menu waits before closing.
 */
export var BLUR_CLOSE_TIMEOUT: number;
export enum MenuItemState {
    None = 0,
    Disabled = 1,
    Hidden = 2,
    Toggled = 4
}
export enum MenuSelectionMode {
    /**
     * No selection available.
     */
    None = 0,
    /**
     * Single item can be selected.
     */
    SingleSelect = 1,
    /**
     * Multiple items can be selected.
     */
    MultiSelect = 2
}
export interface IMenuItemSpec extends IContributedMenuItem {
    /**
     * Id of the menu item. Used to distinguish the menu item when action is executed or when changing command state of a menu item
     */
    id?: string;
    /**
     * The id of the contribution that defines the menu item.
     */
    contributionId?: string;
    rank?: number;
    /**
     * Display text of the menu item
     */
    text?: string;
    /**
     * Display html of the menu item (mutually exclusive with text)
     */
    html?: string | JQuery | (() => string | JQuery);
    /**
     * Text displayed when mouse is hovered on the menu item.
     * @defaultvalue the value of the text option
     */
    title?: string;
    /**
     * Set title to text if not provided.
     * @defaultvalue false, unless showText is specified as false then true
     */
    setDefaultTitle?: boolean;
    /**
     * Set the item's title only when the text overflows and when the mouse is hovering over it
     */
    setTitleOnlyOnOverflow?: boolean;
    /**
     * Icon for the menu item
     */
    icon?: string;
    /**
     * Determines whether the menu item is a separator or not. If specified along with text, menu item acts like a group text
     * @defaultvalue false
     */
    separator?: boolean;
    /**
     * Indicates that this menu item is a separator between menu item groups.
     */
    isGroupSeparator?: boolean;
    /**
     * Determines whether the menu item is initially disabled or not
     * @defaultvalue false
     */
    disabled?: boolean;
    /**
     * If explicitly set to false, menu item will not be focusable via keyboard navigation.
     * Use only for menu items that have alternative means of being focused.
     */
    focusable?: boolean;
    /**
     * Children of this menu item
     */
    childItems?: any;
    /**
     * If childItems is a function and dynamic is true, call the function to update the child items every time they are displayed.
     */
    dynamic?: boolean;
    /**
     * Extra css class name for this menu item
     */
    cssClass?: string;
    groupId?: string;
    /**
     * Determines whether to show text for this item or not.
     * @defaultvalue true
     */
    showText?: boolean;
    /**
     * Determines whether to show html for this item or not.
     * @defaultvalue true
     */
    showHtml?: boolean;
    /**
     * Determines whether to disable icon for this item or not.
     * @defaultvalue false
     */
    noIcon?: boolean;
    arguments?: any;
    action?: (commandArgs: any) => void;
    /**
     * Set to true for menu items that are contributed my an extension.
     */
    isContribution?: boolean;
    /**
     * The id of the extension that contributed the menu item.
     */
    sourceExtensionId?: string;
    /**
     * Extra option overriding default settings
     */
    extraOptions?: any;
    /**
     * Determines whether clicking a menu item with children opens sub menu or not.
     * @defaultValue true
     */
    clickOpensSubMenu?: boolean;
    /**
     *  Option to renders a split drop menu item (eg a chevron or triangle)
     */
    splitDropOptions?: ISplitDropMenuItemSpec;
    /**
     * Options to enable pinning for the menu item.
     */
    pinningOptions?: IMenuItemPinningOptions;
    /**
     * Options to control the pinning behavior of this item's submenu.
     */
    pinningMenuOptions?: IMenuPinningOptions;
    /**
     * If true, item gets 'selected' class.
     */
    selected?: boolean;
    /**
     * If this is true, and there are child items, don't show the
     * drop indicator icon.
     */
    hideDrop?: boolean;
    /**
     * Menu options for any sub menu created by this menu.
     */
    childOptions?: MenuOptions;
    /**
     * By default, a menu item's id will be used as a command id to execute
     * an action. Set this to false if this menu item's action should not
     * default to the item's id.
     */
    idIsAction?: boolean;
    /**
     * Text to be used by screen reader
     */
    ariaLabel?: string;
}
export interface ISplitDropMenuItemSpec extends IMenuItemSpec {
}
/**
 * Options for pinnable menu items. This is intended to support the case where there is a menu of
 * pinned items (the target menu), with a submenu that displays all items (the source menu). Every
 * pinnable item should be added to both menus (the id of two items that are the same must match).
 * See also IMenuPinningOptions
 */
export interface IMenuItemPinningOptions {
    /**
     * Set to true if the item is pinnable.
     */
    isPinnable?: boolean;
    /**
     * Whether or not the menu item is pinned.
     */
    isPinned?: boolean;
    /**
     * Set to true to hide the pin button.
     */
    hidePin?: boolean;
    /**
     * Don't hide this item when it would otherwise be hidden due to hidePinnedItems or hideUnpinnedItems
     * setting on parent menu.
     */
    neverHide?: boolean;
    /**
     * Callback to be called when the user pins or unpins the item.
     * menuItem is the MenuItem that was clicked.
     * siblingMenuItem is the matching MenuItem from the other Menu.
     */
    onPinnedChanged?: (menuItem: MenuItem, pinned: boolean, siblingMenuItem?: MenuItem) => void;
    /**
     * Unique identifier for a group of pinnable menu items.
     */
    groupId?: string;
}
/**
 * Options for menus with pinnable items. This is intended to support the case where there is a menu of
 * pinned items (the target menu), with a submenu that displays all items (the source menu). Set
 * isPinnableTarget and hideUnpinnedItems on the target menu, set isPinnableSource and optionally
 * hidePinnedItems on the source menu.
 * See also IMenuItemPinningOptions.
 */
export interface IMenuPinningOptions {
    /**
     * Set to true to hide unpinned items in this item's submenu.
     */
    hideUnpinnedItems?: boolean;
    /**
     * Set to true to hide pinned items in this item's submenu.
     */
    hidePinnedItems?: boolean;
    /**
     * Set to true if this item's submenu is the target pinned items are pinned to. The pinning source should be a submenu of this item's submenu.
     */
    isPinningTarget?: boolean;
    /**
     * Set to true if this item's submenu is where all pinnable items are shown. The pinning target should be the parent menu of this item.
     */
    isPinningSource?: boolean;
    /**
     * Set to true on the pinning target if newly-pinned items should be moved to be after every other pinnable item with the same group id.
     */
    pinItemsToEnd?: boolean;
    /**
     * If true, close this menu when an item is pinned/unpinned.
     */
    closeOnPin?: boolean;
    /**
     * Unique identifier for a group of pinnable menu items.
     */
    groupId?: string;
    /**
     * Set on the target menu to hide the source menu when all items are pinned.
     */
    hideEmptySourceMenu?: boolean;
}
export interface IMenuManager {
    getCommandState(commandId: any, context: any): any;
    updateCommandStates(commands: ICommand[]): void;
    executeCommand(args?: any): void;
    attachExecuteCommand(handler: IEventHandler): void;
    detachExecuteCommand(handler: IEventHandler): void;
    fire(eventName: string, sender: any, eventArgs: any): void;
    attachEvent(eventName: string, handler: IEventHandler): void;
    detachEvent(eventName: string, handler: IEventHandler): void;
}
export interface MenuBaseOptions {
    type?: string;
    contextInfo?: any;
    arguments?: any;
    updateCommandStates?: Function;
    getCommandState?: Function;
    overflow?: string;
    align?: string;
    useBowtieStyle?: boolean;
    ariaLabel?: string;
    cssClass?: string;
    cssCoreClass?: string;
    /**
     * Determines the selection mode of the menu.
     * @default None
     */
    selectionMode?: MenuSelectionMode | ((item: IMenuItemSpec) => MenuSelectionMode);
}
export class MenuBase<TOptions extends MenuBaseOptions> extends Controls.Control<TOptions> {
    _type: any;
    _parent: any;
    _children: any[];
    _commandStates: any;
    actionArguments: any;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * Get the root menu of this object. (Not the immediate parent)
     */
    getOwner(): MenuOwner<MenuOwnerOptions>;
    getParent(): MenuBase<TOptions>;
    /**
     * Get the parent menu of this.
     */
    getParentMenu(): Menu<MenuOptions>;
    getContextInfo(): any;
    /**
     * @return
     */
    getActionArguments(): any;
    /**
     * Returns the menu type. The values are outlines in the MenuType enumeration
     *
     * @return The menu type value
     */
    getMenuType(): number;
    updateCommandStates(commands: ICommand[]): void;
    isMenuBar(): boolean;
    _fireUpdateCommandStates(context: any): void;
    _clear(): void;
    private _updateCommandStates;
    /**
     * Update contributed menu items that have already been added to the menu.
     * @param items
     */
    protected _updateContributedMenuItems(items: IMenuItemSpec[]): void;
}
export interface MenuItemOptions extends MenuBaseOptions {
    item?: any;
    immediateShowHide?: boolean;
    clickToggles?: boolean;
}
export class MenuItem extends MenuBase<MenuItemOptions> {
    static enhancementTypeName: string;
    static getScopedCommandId(id: string, scope: string): string;
    _parent: Menu<MenuOptions>;
    private _highlightHover;
    private _highlightPressed;
    private _index;
    private _isPinned;
    private _pinElement;
    private _isPinFocused;
    /**
     * The <li> that represents this MenuItem or the <a> tag inside of it.
     */
    private _$menuItemElement;
    private _tooltip;
    private _closeSubmenuOnMouseLeave;
    /**
     * ID of pointer event that was handled by the pointer down event.
     */
    private _handledPointerId;
    /**
     * Ignore all clicks until after this time.
     */
    private _blockClickUntil;
    /**
     * Stop propagation of the next mouse leave event.
     * Useful only when _closeSubmenuOnMouseLeave is
     * set. Use this when we close a menu from under
     * the user's mouse cursor (as when we pin/unpin
     * an item), but we don't want the parent menus to
     * close.
     */
    private _quenchMouseLeave;
    /**
     * Don't open sub menus on hover if this is true.
     * This might happen if a menu item is clicked to
     * dismiss the submenu - we don't want to re-show
     * the menu on the next mouse event, (wait until
     * the mouse has left the element first).
     */
    private _blockHoverOpenSubMenu;
    private _isHidden;
    _item: any;
    _align: any;
    private static PinnedIconClass;
    private static UnpinnedIconClass;
    private static _pinDescribedById;
    private static _unpinDescribedById;
    /**
     * @param options
     */
    constructor(options?: MenuItemOptions);
    /**
     * @param options
     */
    initializeOptions(options?: MenuItemOptions): void;
    /**
     * Get the parent menu of this menu item.
     */
    getParentMenu(): Menu<MenuOptions>;
    getCommandId(): string;
    getAction(): any;
    hasAction(): boolean;
    hasSubMenu(): any;
    isDecorated(): boolean;
    isDefault(): boolean;
    isSeparator(): boolean;
    /**
     * Returns if this menu item is a label.  Labels are menu items that aren't actions, like separators, but contain content, such as text.
     *     NOTE: Currently, Labels are implemented using separators.  However, there are plans to revisit this.
     */
    isLabel(): any;
    /**
     * Returns the selected state of this menu item (not to be confused with the
     * select() method's notion of state)
     */
    isSelected(): boolean;
    getCommandState(commandId?: string, context?: any): MenuItemState;
    getIndex(): number;
    setIndex(value: number): void;
    /**
     * Set to true to hide this menu item.
     *
     * Even if this is set to false, the menu item may be hidden for other reasons. See isHidden().
     * @param value
     */
    setIsHidden(value: boolean): void;
    isHidden(): boolean;
    isEnabled(): boolean;
    isFocusable(): boolean;
    isToggled(): boolean;
    isPinnable(): any;
    isPinned(): boolean;
    private getSelectionMode;
    initialize(): void;
    update(item: any): void;
    updateItems(items: any): void;
    _decorate(): void;
    private _getExternalIcon;
    select(ignoreFocus?: boolean, setKeyboardFocus?: boolean): void;
    focusPin(value?: boolean): void;
    deselect(): void;
    escaped(): void;
    /**
     * @param options
     */
    execute(options?: {
        e: JQueryEventObject;
        keepHighlight?: boolean;
    }): any;
    executeAction(args?: any, e?: JQueryEventObject): any;
    collapse(options?: any): void;
    setFocus(setKeyboardFocus?: boolean): void;
    removeFocus(): void;
    /**
     * Called to show the hover highlight the button
     */
    showHoverHighlight(): void;
    /**
     * Called to make the button appear to be 'pressed'
     */
    showPressedHighlight(): void;
    /**
     * Called to make the button appear to be 'pressed'
     */
    removePressedHighlight(): void;
    /**
     * Called to remove all highlighting on the button
     */
    removeHighlight(): void;
    /**
     * Updates the title of a menu item using either the specified text or
     * the function provided in the options
     *
     * @param text New title to be displayed
     */
    updateTitle(title: string): void;
    private _setTooltip;
    /**
     * Updates the text of a menu item using either the specified text or
     * the function provided in the options
     *
     * @param text New text to be displayed
     */
    updateText(text: string): void;
    getSubMenu(create?: boolean): Menu<MenuOptions>;
    tryShowSubMenu(options?: any): boolean;
    showSubMenu(options?: any): void;
    hideSubMenu(options?: any): void;
    hideSiblings(options?: any): void;
    getAriaRole(): string;
    private _attachMenuEvents;
    private _createIconElement;
    private _createTextElement;
    private _createHtmlElement;
    private _createDropElement;
    private _createSeparatorElement;
    private _updateState;
    /**
     * Update contributed menu items that have already been added to the menu.
     * @param items
     */
    protected _updateContributedMenuItems(updatedItems: IMenuItemSpec[]): void;
    private _onPointerDown;
    private _onPointerUp;
    private _onTouchStart;
    private _onMouseEnter;
    private _onMouseLeave;
    private _onMouseDown;
    private _onMouseUp;
    private _onClick;
    private _onDropClick;
    private _onPinClick;
    toggleIsPinned(isPinned?: boolean, options?: {
        unfocus: boolean;
    }): void;
    private _onKeyDown;
}
export interface MenuContributionProviderOptions {
    defaultTextToTitle?: boolean;
}
export class MenuContributionProvider {
    private static readonly ACTION_TYPE;
    private static readonly HYPERLINK_ACTION_TYPE;
    private static DEFAULT_CONTRIBUTION_SOURCE_TIMEOUT;
    private static _contributionGetItemsTimeout;
    private _webContext;
    private _contributionIds;
    private _contributionType;
    private _contributionQueryOptions;
    private _getMenuActionContext;
    private _contributionsPromise;
    private _contributedMenuItems;
    private _options;
    private _menu;
    constructor(menu: Menu<MenuOptions>, webContext: Contracts_Platform.WebContext, contributionIds: string[], contributionType: string, contributionQueryOptions: Contributions_Services.ContributionQueryOptions, getMenuActionContext: () => any, options: MenuContributionProviderOptions);
    private _immediateInstanceRequired;
    private _getContributions;
    private _getContributionWithSource;
    private _makeThennable;
    private _contributionToMenuItems;
    /**
     * Given a contributed menu item, create a menu item with the same properties.
     * Prevents a contributed menu item specifying properties not on the IContributedMenuItem interface
     * @param contributedItem
     * @return IMenuItemSpec
     */
    private static _getMenuItemFromContributedMenuItem;
    private _updateContributedMenuFromSource;
    private _getBasicMenuItemFromContribution;
    private _getMenuAction;
    /**
     * Handles an extension calling updateMenuItems() to update its contributions.
     * @param items
     * @param contributionWithSource
     */
    private _updateContributedMenuItems;
    getContributedMenuItems(context: any): IPromise<IContributedMenuItem[]>;
    /**
     * Gets the time in ms to wait to get actions from action provider or for the actions to run
     */
    getContributionSourceTimeout(): number;
}
export interface MenuOptions extends MenuBaseOptions {
    suppressInitContributions?: boolean;
    contributionIds?: string[];
    contributionType?: string;
    contributionQueryOptions?: Contributions_Services.ContributionQueryOptions;
    /**
     * Time to wait in milliseconds for contribution iframes to be loaded.
     */
    contributionSourceTimeoutMs?: number;
    /**
     * Items to be displayed in the menu
     */
    items?: IMenuItemSpec[];
    /**
     * Action executed when a menu item is clicked
     */
    executeAction?: Function;
    getContributionContext?: Function;
    /**
     * Control the behavior of pinnable items in the menu.
     */
    pinningMenuOptions?: IMenuPinningOptions;
    /**
     * If true, any time a menu item w/ a sub-menu is hovered,
     * that sub-menu will be opened. If false, this menu must be
     * in an "active" state to show the sub menu.
     */
    alwaysOpenSubMenuOnHover?: boolean;
    /**
     * If true, do not add a separator between grouped items and
     * ungrouped items.
     */
    doNotSeparateUngroupedItems?: boolean;
}
/**
 * @publicapi
 */
export class Menu<TOptions extends MenuOptions> extends MenuBase<TOptions> {
    static enhancementTypeName: string;
    static CONTRIBUTION_ITEMS_UPDATED_EVENT: string;
    private _items;
    private _itemsSource;
    private _childrenCreated;
    private _popupElement;
    private _skipUpdateMenuItemStates;
    private _positioningRoutine;
    private _pinElement;
    private _menuContributionProvider;
    private _asyncLoadingDelay;
    private _contributedItemsDelay;
    private _menuUpdateNeeded;
    /** True if mouse down event has been received on this menu, and mouse up event has not been received. Only tracked for Edge. */
    private _mouseIsDown;
    private _shouldSelectFirstItem;
    private _shownTime;
    /**
     * Time the Menu was last displayed.
     */
    readonly shownTime: number;
    protected _contributedItems: IContributedMenuItem[];
    protected _contributionProviderOptions: MenuContributionProviderOptions;
    protected _contributionPromise: IPromise<IContributedMenuItem[] | void>;
    _menuItems: MenuItem[];
    _selectedItem: MenuItem;
    _visible: boolean;
    _active: boolean;
    _focusItem: MenuItem;
    openSubMenuOnHover: boolean;
    /**
     * @param options
     */
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    private _initializeItemsSource;
    _decorate(): void;
    /**
     * Gets the item which has the specified command id.
     *
     * @param id  Id associated with the menu item.
     * @return {MenuItem}
     * @publicapi
     */
    getItem(id: string): MenuItem;
    /**
     * Gets an array of all menu items.
     *
     * @return {MenuItem[]}
     * @publicapi
     */
    getItems(): MenuItem[];
    /**
     * Gets the item which has the specified tag
     *
     * @param tag Associated with the menu item
     * @return
     */
    getItemByTag(tag: string): MenuItem;
    getMenuItemSpecs(): IMenuItemSpec[];
    /**
     * Get the parent menu of this menu, if there is one.
     */
    getParentMenu(): Menu<MenuOptions>;
    /**
     * Get the pinning options for this menu.
     */
    getMenuPinningOptions(): IMenuPinningOptions;
    getCommandState(commandId: string, context?: any): MenuItemState;
    /**
     * Updates the command states of the items with the specified ids.
     *
     * @param commands List of commands to update.
     * @publicapi
     */
    updateCommandStates(commands: ICommand[]): void;
    updateItems(items: any): void;
    private _updateItems;
    protected _updateItemsWithContributions(items: any, contributedMenuItems: IContributedMenuItem[]): void;
    protected _updateCombinedSource(items: any): void;
    /**
     * Create a list from itemsSource to reflect the order of items after grouping is done.
     * Groups of items come before all ungrouped items.
     * A separator goes between each group of items.
     * Ungrouped items remain at the end of the menu with their manually-specified separators still in tact.
     * If any groups are defined, separators are guaranteed not to be the first or last item in the menu.
     */
    getGroupedItems(): IMenuItemSpec[];
    appendItems(appendedItems: any): void;
    appendItem(item: IMenuItemSpec): void;
    /**
     * Move a menu item to appear immediately after the other given menu item.
     * @param item
     * @param after
     */
    moveMenuItemAfter(item: MenuItem, after: MenuItem): boolean;
    removeItem(item: IMenuItemSpec): boolean;
    removeMenuItem(menuItem: MenuItem): boolean;
    private _updateAllSourceMenus;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    /**
     * @return
     */
    _getMenuItemType(): any;
    /**
     * @param extraOptions
     * @return
     */
    getMenuItemOptions(item: any, extraOptions?: any): any;
    _getFirstMenuItem(): MenuItem;
    /**
     * @param item
     * @param ignoreFocus
     */
    _selectItem(item?: MenuItem, ignoreFocus?: boolean, setKeyboardFocus?: boolean): void;
    selectDefaultItem(ignoreFocus?: boolean): void;
    selectFirstItem(): boolean;
    selectLastItem(): void;
    selectNextItem(): boolean;
    selectPrevItem(): boolean;
    /**
     * @param options
     * @return
     */
    selectDown(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectUp(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectRight(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectLeft(options?: any): boolean;
    /**
     * Show the menu.
     *
     * Options:
     *  immediate: whether to show the menu immediately or after a short delay (default false)
     *  showTimeout: optional number of milliseconds to wait before showing when immediate is false
     *  callback: function to call after menu is shown
     *  align: how to align the menu with its parent
     *  setFocus: whether to set the focus to the menu (default true)
     */
    show(options?: any): boolean;
    /**
     * @param options
     */
    hide(options?: any): void;
    hideChildren(excludedItem: MenuItem, options?: any): void;
    /**
     * @param options
     * @return
     */
    escape(options?: any): boolean;
    ownFocus(): void;
    attach(parent: any): void;
    /**
     * @return
     */
    getMenuItemAlignment(): string;
    updateMenuItemStates(): void;
    executeAction(eventArgs: any): any;
    /**
     * Scrolls to ensure that the MenuItem is visible
     *
     * @param item MenuItem which is to be shown
     */
    private _ensureVisible;
    private _getItems;
    _clear(): void;
    /**
     * @param menuItemElement
     */
    private _createChildMenuItem;
    private _createSplitDropMenuItem;
    private _ensureChildren;
    private _enhanceChildren;
    /**
     * Updates aria set related properties, use after modifying the child items of the menu.
     */
    updateAriaSetProperties(): void;
    /**
     * Get the first item at or after the given index that is focusable.
     * @param index
     * @param options
     */
    protected _getNextFocusableItem(index: number, options?: {
        rollOver: boolean;
    }): MenuItem;
    /**
     * Get the first item at or after the given index that is enabled.
     * @param index
     * @param options
     */
    private _getNextEnabledItem;
    /**
     * Get the next item at or after the given index that meets the given condition.
     * @param condition
     * @param index
     * @param options
     */
    private _getNextItem;
    /**
     * Get the closest item at or before the given index that is focusable.
     * @param index
     * @param options
     */
    private _getPrevFocusableItem;
    /**
     * Get the closest item at or before the given index that is enabled.
     * @param index
     * @param options
     */
    private _getPrevEnabledItem;
    /**
     * Get the closest item at or before the given index that meets the given condition.
     * @param condition
     * @param index
     * @param options
     */
    private _getPrevItem;
    private _ensurePopup;
    private _getPopupAlign;
    private _showPopup;
    _hidePopup(): void;
    private _updateMenuItemStates;
    private _startShowTimeout;
    private _startHideTimeout;
    private _attachAncestorScroll;
    private _detachAncestorScroll;
    protected _dispose(): void;
    _onParentScroll(e: Event): void;
    private _onMouseDown;
    private _onMenuKeyDown;
    /**
     * Change the contribution options for this menu and reload the contributed menu items
     *
     * @param contributionIds The contribution ids to query for this menu
     * @param contributionType Optional type of contributions to include
     * @param contributionQueryOptions Optional contribution query options
     */
    setContributedItemOptions(contributionIds: string[], contributionType?: string, contributionQueryOptions?: Contributions_Services.ContributionQueryOptions): void;
    /**
     * Load contributed menu items.
     */
    refreshContributedItems(): void;
    /**
     * Load contributed menu items.
     */
    private _refreshContributedMenuItems;
    /**
     * Update contributed menu items that have already been added to this menu.
     *
     * Menu items must have an id set in order to be updated. Extensions can only update menu items that they contributed.
     *
     * Exposed to extensions as the updateMenuItems() method on the context object passed to getMenuItems().
     * @param contributedMenuItems
     */
    updateContributedMenuItems(contributedMenuItems: IMenuItemSpec[]): void;
    /**
     * Creates context object to be passed to extensions.
     */
    private _getContributionContext;
}
export interface MenuOwnerOptions extends MenuOptions {
    /**
     * Determines whether icons are visible or not
     * @defaultvalue true
     */
    showIcon?: boolean;
    markUnselectable?: boolean;
    showTimeout?: number;
    hideTimeout?: number;
    popupAlign?: string;
    onActivate?: Function;
    onDeactivate?: Function;
    /**
     * If true, put the menu the tab order so that it is accessible by tabbing.
     * Defaults to true.
     */
    inTabOrder?: boolean;
    /**
     * If true, include empty menu with no items in tab order.
     * If false, add tabIndex only if menu has items.
     * Use with inTabOrder = true.
     * Defaults to true.
     */
    emptyMenuInTabOrder?: boolean;
}
export class MenuOwner<TOptions extends MenuOwnerOptions> extends Menu<TOptions> {
    private _focusElement;
    private _activating;
    private _canBlur;
    private _immediateBlur;
    private _focusing;
    _subMenuVisible: boolean;
    _align: any;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * Sets showIcon option.
     *
     * @param showIcon New state for the showIcon option.
     */
    setShowIcon(showIcon: boolean): void;
    initialize(): void;
    _decorate(): void;
    /**
     * @return
     */
    getMenuItemAlignment(): string;
    /**
     * @param extraOptions
     */
    getMenuItemOptions(item: any, extraOptions?: any): any;
    /**
     * @param options
     * @return
     */
    escape(options?: any): boolean;
    escaped(options?: any): void;
    isActive(): boolean;
    activate(tryFocus?: boolean): void;
    private _hide;
    private _blur;
    private _updateTabIndex;
    private _onKeyDown;
    private _onFocus;
    /**
     * Returns true if the given element's focus is controlled by this MenuOwner.
     * Returns false when the given element is inside a MenuItem marked unfocusable.
     * @param element
     */
    private _isOwned;
    private _onChildFocus;
    private _onChildBlur;
    private _clearBlurTimeout;
    _onParentScroll(e?: any): void;
    private _onResize;
    private _onContextMenu;
    /**
     * Attempt to open the submenu on the focused item
     * @param e
     * @return
     */
    showSubMenuOnFocusedItem(): boolean;
}
/**
 * @publicapi
 */
export interface MenuBarOptions extends MenuOwnerOptions {
    /**
     * Orientation of the menubar (horizontal or vertical)
     * @defaultvalue "horizontal"
     */
    orientation?: string;
}
export class MenuBarO<TOptions extends MenuBarOptions> extends MenuOwner<TOptions> {
    static enhancementTypeName: string;
    private _orientation;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    getMenuItemAlignment(): string;
    /**
     * @param options
     * @return
     */
    selectUp(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectDown(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectLeft(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectRight(options?: any): boolean;
    /**
     * Tries to activate the menubar associated with the element matched by the selector.
     * @param selector Selector to match the element.
     * @returns Menu activated or not.
     */
    static tryActivate(selector: string): boolean;
    /**
     * Tries to activate and open the menubar associated with the element matched by the selector.
     * @param selector Selector to match the element.
     * @returns Menu shown or not.
     */
    static tryShowSubMenu(selector: string): boolean;
    /**
     * Sets focus to the control
     */
    focus(): void;
    private static _getMenuBar;
}
export class MenuBar extends MenuBarO<MenuBarOptions> {
}
export interface ToolbarOptions extends MenuBarOptions {
}
/**
 * Toolbar widget wrapped around the menubar.
 * https://www.w3.org/TR/wai-aria-practices/#toolbar
 */
export class Toolbar extends MenuBar {
    constructor(options: ToolbarOptions);
    _getMenuItemType(): any;
}
export interface PopupMenuOptions extends MenuOwnerOptions {
    hidden?: boolean;
    onPopupEscaped?: Function;
    onHide?: Function;
    /**
     * If the menu should take focus when it appears. Defaults to true.
     */
    setFocus?: boolean;
}
export class PopupMenuO<TOptions extends PopupMenuOptions> extends MenuOwner<TOptions> {
    static enhancementTypeName: string;
    private _floating;
    private _escapeFocusReceiver;
    private _popupPinElement;
    private _onHide;
    _hidden: boolean;
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    _getMenuItemType(): any;
    _decorate(): void;
    popup(focusElement: any, pinElement: any): void;
    private _showPopupMenu;
    protected _updateItemsWithContributions(items: any, contributedMenuItems: IContributedMenuItem[]): void;
    protected _updateCombinedSource(items: any): void;
    /**
     * @param options
     * @return
     */
    selectUp(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectDown(options?: any): boolean;
    /**
     * Selects the first item of the child menu.
     * Override of Menu.selectFirstItem()
     */
    selectFirstItem(): boolean;
    /**
     * @param options
     * @return
     */
    selectLeft(options?: any): boolean;
    /**
     * @param options
     * @return
     */
    selectRight(options?: any): boolean;
    escaped(): void;
    _hidePopup(): void;
}
export class PopupMenu extends PopupMenuO<PopupMenuOptions> {
}
/**
 * The command id.
 */
export interface ICommand {
    /**
     * Optional disabled state.  True makes it visible in the menu but not selectable or clickable.
     */
    id: string;
    /**
     * Optional hidden state.  True hides it from the menu.
     */
    disabled?: boolean;
    /**
     * Optional toggled state.  True shows the item as toggled.
     */
    hidden?: boolean;
    toggled?: boolean;
}
/**
 * Sort the menu items by rank, pushing those without a rank to the bottom of the list.
 */
/**
 * Sort the menu items by rank, pushing those without a rank to the bottom of the list.
 */
export function sortMenuItems(items: any): any;
}
declare module "VSS/Controls/Navigation" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
/// <amd-dependency path="VSS/LoaderPlugins/Css!PivotView" />
import Controls = require("VSS/Controls");
import Menus = require("VSS/Controls/Menus");
import Notifications = require("VSS/Controls/Notifications");
/**
 * Creates a high-level view object for a given page which captures page/hash navigations,
 * handles setting page title, etc.
 */
export class NavigationView extends Controls.BaseControl {
    static ACTION_CONTRIBUTION: string;
    private _chromelessMode;
    private _leftPaneVisible;
    private _historyNavigated;
    /**
     * Creates an instance of the object for the given page
     *
     * @param options
     *     attachNavigate: If true, listen for page/hash navigations
     *
     */
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    /**
     * Function invoked when a page/hash navigation has occurred
     *
     * @param state Hash object containing the hash-url parameters
     */
    onNavigate(state: any): void;
    /**
     * Get the element that holds the title
     */
    _getViewTitle(): JQuery;
    /**
     *     Sets the (text) title of the page
     *
     * @param title
     *     Title of the page
     *
     * @param tooltip
     *     Optional tooltip for the page's title element
     *
     */
    setViewTitle(title?: string, tooltip?: string): void;
    /**
     *     Sets the raw-html title element for the page
     *
     * @param title
     *     Text title of the page to be used as the document title
     *
     * @param titleContent
     *     Raw HTML to inject into the title element (will not be escaped)
     *
     */
    setViewTitleContent(title: string, titleContent: string): void;
    /**
     *     Sets the document's title
     *
     * @param title
     *     Title of the page (text)
     *
     */
    setWindowTitle(title: string): void;
    /**
     * Shows or hides the Left (tree) section of the explorer page
     *
     * @param visible If true, show the left side of the explorer page. False to hide it.
     */
    setLeftHubPaneVisibility(visible: boolean): void;
    /**
     *     Set full-screen mode. If true, hide the chrome (hubs, etc.) around the main hub content, hide the splitter, etc.
     *
     * @param fullScreenMode True to enter full screen mode. False to exit full screen mode.
     */
    setFullScreenMode(fullScreenMode: boolean, showLeftPaneInFullScreenMode?: boolean): void;
    /**
     * Obsolete. This no-ops.
     */
    _setTitleMode(isHosted: boolean): void;
    /**
     * Protected API: returns the desired title format string for use by SetWindowTitle()
     */
    _getPageTitleString(): string;
    private _attachNavigate;
    _onNavigate(state: any): void;
    private _onHistoryNavigate;
    protected _dispose(): void;
}
/**
 * A high-level singleton wrapper class for a Tri-Split page, providing lightweight
 * functionality such as retrieving the left/right/center hub content, left/right
 * panes, setting the view title, etc.
 *
 * This class is designed to enhance the hub view of a Tri-Split page, and depends
 * on the structure defined in the HubPageExplorerTriSplitPivot.master page.
 */
export class TriSplitNavigationView extends NavigationView {
    private static _instance;
    private _leftPane;
    private _rightPane;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    /**
     * Retrieve the singleton instance of the class for the current page.
     */
    static getInstance(): TriSplitNavigationView;
    /**
     * Retrieve the left pane element within the current backlog view
     */
    getLeftPane(): JQuery;
    /**
     * Retrieve the right pane element within the current backlog view.
     * NOTE: This retrieves the right pane of the left splitter, which has the center
     * hub content as well as the right hub content (e.g. the product backlog mapping pane).
     */
    getRightPane(): JQuery;
}
export interface IPivotFilterItem {
    id?: string;
    text?: string;
    title?: string;
    selected?: boolean;
    encoded?: boolean;
    value?: any;
}
export interface IPivotFilterOptions extends Controls.EnhancementOptions {
    name?: string;
    text?: string;
    encoded?: boolean;
    behavior?: string;
    items?: IPivotFilterItem[];
    align?: any;
    useBowtieStyle?: any;
}
export class PivotFilter extends Controls.Control<IPivotFilterOptions> {
    static enhancementTypeName: string;
    private static _behaviors;
    /**
     * Registers a filter behavior for the pivot filter
     *
     * @param behaviorType Type of the registered behavior
     */
    static registerBehavior(behaviorType: any): void;
    /**
     * Creates a behavior using the specified names. First found behavior is used
     *
     * @param names Names of the behaviors to probe
     * @param options Options of the behavior
     * @return
     */
    static createBehavior(names: any[], options?: any): any;
    private _behavior;
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    initialize(): void;
    /**
     * Gets all selected items of the pivot filter
     *
     * @return items
     */
    getSelectedItems(): IPivotFilterItem[];
    /**
     * Gets the currently selected item
     *
     * @return item
     */
    getSelectedItem(): IPivotFilterItem;
    /**
     * Gets the item of the specified value
     *
     * @param value Value of the item (String or Number)
     * @return item
     */
    getItem(value: any): IPivotFilterItem;
    /**
     * Gets all of the items
     * @return the items
     */
    getItems(): IPivotFilterItem[];
    /**
     * Gets the specified item selected
     *
     * @param item Item to select
     * @param fireChange Determines whether the control shoudl fire the change event
     */
    setSelectedItem(item: IPivotFilterItem, fireChange?: boolean): void;
    /**
     * Updates the pivot filter using the specified items
     *
     * @param items New set of items for the pivot filter
     */
    updateItems(items: IPivotFilterItem[], options?: any): void;
    /**
     * Initializes behavior of this pivot filter using specified behavior names
     */
    private _initBehavior;
    /**
     * This method is called when the control is created in the client using createIn.
     * DOM needs to be built by the control itself
     */
    _createElement(): void;
    private _buildDom;
    private _attachEvents;
    private _onFilterChanged;
}
export interface IPivotViewItem extends IPivotFilterItem {
    link?: string;
    hidden?: boolean;
    disabled?: boolean;
    contributed?: boolean;
}
export interface IPivotViewOptions extends Controls.EnhancementOptions {
    items?: IPivotViewItem[];
    contributionId?: string;
    generateContributionLink?: (contributionId: string) => string;
    getEnabledState?: (contributionId: string) => boolean;
    getContributionContext?: () => any;
}
export class PivotView extends Controls.Control<IPivotViewOptions> {
    static enhancementTypeName: string;
    private _extensionContainer;
    private _contributionContext;
    private _itemIdToSelect;
    private _contributionsInitialized;
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    /**
     * @param selector
     * @return the array of items
     */
    getItems(selector?: any): IPivotViewItem[];
    initialize(): void;
    /**
     * Sets the DOM (jQuery) container that tab extensions will be loaded in. Should probably be a div.
     * @param {JQuery} container
     */
    setExtensionContainer(container: JQuery): void;
    showExtensionTab(contributionId: string, configuration?: any): void;
    setContributionContext(context: any): void;
    private _getTabFromContribution;
    /**
     * If there is a contribution ID associated with this PivotView, load all the contributed pivot items.
     * use forceRefresh for for refreshing contributions, by default this ensures we get contributions only once
     */
    refreshContributedItems(forceRefresh?: boolean): IPromise<void>;
    /**
     * Sets the focus on the selected pivot.
     */
    focusSelectedPivot(): void;
    /**
     * @param keepTabFocus: True to keep currently focused pivot view tab after update
     */
    updateItems(keepTabFocus?: boolean): void;
    /**
     * Set a particular view's link to a new link.
     *
     * @param id The view whose link needs an update.
     * @param link The new link for the specified view.
     */
    setViewLink(id: string, link: string): void;
    getSelectedView(): IPivotViewItem;
    /**
     * Set a particular view to be enabled or disabled.
     *
     * @param id The view whose state needs an update.
     * @param isEnabled Weather to enable the view or not
     */
    setViewEnabled(id: any, isEnabled: any): void;
    private _makeThennable;
    getView(id: any, selectedTabId?: any): any;
    setSelectedView(view: any): void;
    onChanged(view: any): void;
    _createElement(): void;
    private _buildDom;
    private _populateItems;
    private _attachEvents;
    private _onClick;
    private _onFocus;
    private _onKeydown;
}
export class NavigationViewTab extends Controls.BaseControl {
    /**
     * Creates a control which is used to populate a navigation tab's content section
     */
    constructor(options?: any);
    /**
     * Called whenever navigation occurs with this tab as the selected tab
     *
     * @param rawState The raw/unprocessed hash/url state parameters (string key/value pairs)
     * @param parsedState Resolved state objects parsed by the view
     */
    onNavigate(rawState: any, parsedState: any): void;
    /**
     * Called whenever this tab is active and a navigation occurs that is switching to another tab
     */
    onNavigateAway(): void;
}
export class TabbedNavigationView extends NavigationView {
    private _hubContent;
    private _tabsControl;
    private _tabsMap;
    private _tabOptionsMap;
    private _tabs;
    private _currentTab;
    private _currentTabId;
    private _errorTab;
    private _infoTab;
    private _$infoContent;
    private _currentRawState;
    private _currentParsedState;
    private _currentNavigationContextId;
    private _lastParsedNavigationContextId;
    private _showingError;
    private _showingInfo;
    private _skipTabHideOnAsyncNavigate;
    /**
     * Creates a high-level view object for a given page that has different tabs which are
     * displayed based on the current hash/navigation.
     *
     * @param options
     *     tabs: (Object) Mapping of action id to a NavigationViewTab containing the contents of the tab
     *     hubContentSelector: (String) jQuery selector for the hub content div
     *     pivotTabsSelector: (String) jQuery selector for the hub tabs div
     *     hubSplitterSelector: (String) jQuery selector for the hub splitter control
     *
     */
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    /**
     * Update the given tabs in the tabbed navigation view.
     * @param tabs Mapping of tabIds to tabControls
     */
    updateTabs(tabs: {
        [key: string]: NavigationViewTab;
    }): void;
    getTab(tabId: string): NavigationViewTab;
    showError(error: any): void;
    showErrorContent(title: any, $contentHtml: any, messageType: any, expand: any): void;
    showInformationTab(title: string, description: string): void;
    appendInformationContent(caption: string, collapsed: boolean): Notifications.InformationAreaControl;
    appendSectionTitle(content: string): void;
    appendSectionSummary(content: string): void;
    appendElement(element: JQuery): void;
    /**
     * Refresh the current tab (causes setState to be called on the currently visible tab)
     */
    refreshCurrentTab(): void;
    /**
     * Get the action/tab id for the current state
     *
     * @return Tab id, specified in the _a parameter
     */
    getCurrentAction(): string;
    /**
     * Get the current (parsed) state objects for the current navigation state
     *
     * @return State Object that was parsed by the view
     */
    getState(): any;
    /**
     * Set the current (parsed) state objects for the current navigation state
     */
    setState(parsedState: any): void;
    /**
     * Get a state hash with null entries for each hash key that exists in the current
     * url hash. This state can be extended and passed to VSS.Host.history.addHistoryPoint
     * so that existing hash parameters are NOT included in the new url.
     *
     * @return
     */
    getEmptyState(): any;
    /**
     * Get the raw (unparsed) state objects for the current navigation state (key/value pairs from the hash/url)
     *
     * @return Object with string values from the url hash portion
     */
    getRawState(): any;
    /**
     * Parse the state info and fetch any artificacts necessary to render the tab/view. Invoke the 'callback'
     * method with the new state info object when the state information has been successfully parsed.
     *
     * @param action The action parameter (_a) in the url hash
     * @param rawState The raw state info from the hash url for the new navigation
     * @param callback
     *    Callback that should be called when the state was successfully parsed. The callback takes 2 parameters: the tab id (typically
     *    the action), and the parsed state info object.
     *
     *    callback(tabId, parsedStateInfo);
     *
     *
     */
    parseStateInfo(action: string, rawState: any, callback: IResultCallback): void;
    /**
     * Get the visibility state of the specified tab based on the current tab/navigation state. True to show this tab. False to hide it.
     *
     * @param tabId The Id to get the visiblility state for
     * @param currentTabId Id of the currently selected tab
     * @param rawState The raw/unprocessed hash/url state parameters (string key/value pairs)
     * @param parsedState Resolved state objects parsed by the view
     * @return True to show the tab. False to hide it.
     */
    getTabVisibility(tabId: any, currentTabId: string, rawState: any, parsedState: any): boolean;
    /**
     * Get the updated tab label for the specified tab based on the current tab/navigation state. null/undefined to keep the existing label.
     *
     * @param tabId The Id to get the tab label for
     * @param currentTabId Id of the currently selected tab
     * @param rawState The raw/unprocessed hash/url state parameters (string key/value pairs)
     * @param parsedState Resolved state objects parsed by the view
     */
    getTabLabel(tabId: any, currentTabId: string, rawState: any, parsedState: any): void;
    /**
     * Shows or hides the Hub pivot section (navigation tab strip + filters)
     *
     * @param visible If true, show the hub pivot (tabs/filters). If false, hide them
     */
    setHubPivotVisibility(visible: boolean): void;
    private _getErrorTab;
    private _getInfoTab;
    _onNavigate(state: any): void;
    _redirectNavigation(action: string, state: any, replaceHistory?: boolean): void;
    private _onParseStateInfoSuccess;
    private _updateTabsControl;
    private _showTab;
    private _getTab;
    private _createTab;
}
export interface NavigationLinkOptions {
    state?: any;
    getUrl?: (state: any) => string;
    target?: string;
    text?: string;
    title?: string;
    $content: JQuery;
    initialState?: any;
}
export class NavigationLink extends Controls.BaseControl {
    private _navigateHandler;
    private _navigationLinkOptions;
    initializeOptions(options?: any): void;
    constructor(options: NavigationLinkOptions);
    initialize(): void;
    dispose(): void;
    private onNavigate;
    private updateLink;
    getLocation(state: any): any;
}
export module FullScreenHelper {
    var FULLSCREEN_HASH_PARAMETER: string;
    /**
     * Initialize the full screen helper. Sets up event handlers.
     *
     * @param menuBar A toggle button for full screen mode will be added to the menu bar (if it does not already exist).
     */
    function initialize(menuBar: Menus.MenuBar, options?: any): void;
    /**
     * Gets a value indicating whether full screen mode is active.
     */
    function getFullScreen(): boolean;
    /**
     * Set full screen value. Update full screen view and button.
     * Update url with full screen tag if addHistoryPoint is true.
     *
     * @param value  The full screen value to set to.
     * @param addHistoryPoint  If true, update url with full screen tag.
     * @param showLeftLane  If true, the left tab in split panes will be shown during full screen mode.
     * @param suppressNavigate  If true, the setting of full screen will not cause a navigation event, and instead will simply set to fullscreen without updating navigation tabs, etc.
     * @param replaceHistoryPoint If true, update the url with the full screen tag w/o adding to the back history.  addHistoryPoint and replaceHistoryPoint are exclusive operations.
     * @param supressWindowResizeEvent If true, don't trigger the window resize event after setting the new mode.
     */
    function setFullScreen(value: boolean, addHistoryPoint?: boolean, showLeftLane?: boolean, suppressNavigate?: boolean, replaceHistoryPoint?: boolean, supressWindowResizeEvent?: boolean): void;
    /**
     * Get state object for the current full screen mode state.
     *
     * @param value Optional value to set for fullscreen mode.
     * If undefined will use current setting.
     */
    function getUrlData(value?: boolean): any;
    /**
     * Gets full screen icon.
     */
    function getFullScreenIcon(): string;
    /**
     * Gets full screen tooltip.
     */
    function getFullScreenTooltip(): string;
    /**
     * Attaches a fullscreen customer intelligence change event handler.
     * This event handler will be triggered for publishing full screen customer intelligence.
     *
     * @param handler Event handler callback.
     */
    function attachFullScreenCI(handler: IEventHandler): void;
    /**
     * Removes fullscreen customer intelligence change handler from the event handler list.
     *
     * @param handler Event handler callback.
     */
    function detachFullScreenCI(handler: IEventHandler): void;
    /**
     * Attaches a fullscreen customer intelligence change event handler.
     * This event handler will be triggered for publishing full screen customer intelligence.
     *
     * @param handler Event handler callback.
     */
    function attachFullScreenUrlUpdateEvent(handler: IEventHandler): void;
    /**
     * Removes fullscreen customer intelligence change handler from the event handler list.
     *
     * @param handler Event handler callback.
     */
    function detachFullScreenUrlUpdateEvent(handler: IEventHandler): void;
}
}
declare module "VSS/Controls/Notifications" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
export enum MessageAreaType {
    None = 0,
    Info = 1,
    Warning = 2,
    Error = 3
}
export interface IMessageAreaControlOptions {
    message?: any;
    type?: MessageAreaType;
    closeable?: boolean;
    expanded?: boolean;
    hidden?: boolean;
    showHeader?: boolean;
    showDetailsLink?: boolean;
    showIcon?: boolean;
    noHeaderNoLinkJustIcon?: boolean;
    fillVertical?: boolean;
}
export class MessageAreaControlO<TOptions extends IMessageAreaControlOptions> extends Controls.Control<TOptions> {
    static EVENT_CLOSE_ICON_CLICKED: string;
    static EVENT_DISPLAY_COMPLETE: string;
    static EVENT_DISPLAY_CLEARED: string;
    static ERROR_DETAILS_TOGGLED: string;
    private _errorHeader;
    private _errorContent;
    private _messageType;
    private _showErrorLink;
    private _iconDiv;
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    initialize(): void;
    /**
     * Set the message
     *
     * @param message Message string (plain text), jQuery (html) or
     *     message = {
     *         type: MessageAreaType,
     *         header: String for plain text or jQuery for html,
     *         content: String for plain text or jQuery for html,
     *         click: function
     *     }
     *
     * @param messageType Type of message
     */
    setMessage(message: any, messageType?: MessageAreaType): void;
    /**
     * Set the error message
     *
     * @param message Message string (plain text), jQuery (html) or
     *     message = {
     *         type: MessageAreaType,
     *         header: String for plain text or jQuery for html,
     *         content: String for plain text or jQuery for html,
     *         click: function
     *     }
     *
     * @param clickCallback Click callback function
     */
    setError(message: any, clickCallback?: Function): void;
    /**
     * Gets the current message type.
     */
    getMessageType(): MessageAreaType;
    /**
     * Clear the shown message
     */
    clear(): void;
    /**
     * Set the display message
     *
     * @param message
     *     message = {
     *         type: MessageAreaType,
     *         header: String,
     *         content: html String OR jQuery,
     *         click: function
     *     }
     *
     */
    private _setDisplayMessage;
    private _onCloseIconClicked;
    private _setMessageTypeIcon;
    private _toggle;
    setErrorDetailsVisibility(show: any): void;
    /**
     * Clear the shown message
     *
     * @param raiseDisplayCompleteEvent Indicates if the display complete event should be raised.
     */
    private _clear;
    private _raiseDisplayComplete;
}
export class MessageAreaControl extends MessageAreaControlO<IMessageAreaControlOptions> {
}
export interface IInformationAreaControlOptions {
    caption?: string;
    expandedIconClass?: string;
    collapsedIconClass?: string;
}
export class InformationAreaControlO<TOptions extends IInformationAreaControlOptions> extends Controls.Control<TOptions> {
    private _$collapseIndicator;
    private _$content;
    private _$caption;
    private _collapsed;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    appendDetailHeaderContent($headerContent: JQuery): void;
    appendDetailContent($detailContent: JQuery): void;
    appendCodeContent($codeContent: JQuery): void;
    appendDetailHeaderHtml(headerHtml: string): void;
    appendDetailHtml(detailHtml: string): void;
    appendCodeHtml(codeHtml: string): void;
    _updateCollapsedState(collapsed: boolean): void;
}
export class InformationAreaControl extends InformationAreaControlO<IInformationAreaControlOptions> {
}
/**
 * This class affords showing a toast-style notification which fades in,
 * appears for a certain amount of time and then fades out.
 */
export class ToastNotification extends Controls.BaseControl {
    private _messageArea;
    private _fadeInTime;
    private _fadeOutTime;
    private _toastTime;
    private _toasting;
    private _delayedFunction;
    constructor(options?: any);
    initialize(): void;
    initializeOptions(options?: any): void;
    private _processOptions;
    private _getOptions;
    private _getDefaultOptions;
    /**
     * Pop up a toast with the supplied message
     *
     * @param message This can be a string or JQuery object
     * @param messageType The type of message area you want displayed. Defaults to Info.
     */
    toast(message: any, messageType?: MessageAreaType): void;
    /**
     * If toasting ensure we cancel all in-progress toasting activities
     */
    private _ensureNoActiveToast;
}
}
declare module "VSS/Controls/Panels" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
export interface ICollapsiblePanelOptions extends Controls.EnhancementOptions {
    collapsed?: boolean;
    headerText?: string;
    headerContent?: string | JQuery;
    /**
     * A positive number to set the aria-level of the header to. Default is 2. Negative values will
     * cause the role="heading" attribute to be omitted. Does not work with headerContent or
     * appendHeader(), in these cases users will have to place role="heading" in their HTML content
     * as appropriate.
     */
    headingLevel?: number;
    expandCss?: string;
    headerCss?: string;
    contentCss?: string;
    hoverCss?: string;
    iconCss?: string;
    collapseCss?: string;
    iconCollapseCss?: string;
    iconExpandCss?: string;
    onToggleCallback?: Function;
    customToggleIcon?: JQuery;
    /**
     * Set headerNotFocusable to true if you need multiple focusable element in headers,
     * screen reader does not work well with nested focusable element.
     */
    headerNotFocusable?: boolean;
}
export class CollapsiblePanel extends Controls.Control<ICollapsiblePanelOptions> {
    static EVENT_CONTENT_EXPANDED: string;
    static EVENT_CONTENT_COLLAPSED: string;
    static enhancementTypeName: string;
    private static _defaultToggleIconOverrideClass;
    private _dynamicContents;
    private _header;
    private _content;
    private _$toggleIcon;
    private _isDisabled;
    /**
     * @param options
     */
    initializeOptions(options?: ICollapsiblePanelOptions): void;
    private _swapDefaultToggleIconForCustom;
    private _createControl;
    _createIn(container: JQuery): void;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    /**
     * Appends the specified plain text to the header section of the CollapsiblePanel
     *
     * @param header Content to append to the header section
     * @return
     */
    replaceHeaderTextIfPresent(headerText: string): JQuery;
    /**
     * Appends the specified plain text to the header section of the CollapsiblePanel
     *
     * @param headerText Content to append to the header section
     * @return
     */
    appendHeaderText(headerText: string): CollapsiblePanel;
    /**
     * Appends the specified HTML, DOM element or jQuery object to the
     * header section of the CollapsiblePanel
     *
     * @param element Content to append to the header section (JQuery object or HTML string)
     * @return
     */
    appendHeader(element: string | JQuery): CollapsiblePanel;
    /**
     * Prepends the specified HTML, DOM element or jQuery object to the
     * header section of the CollapsiblePanel
     *
     * @param element Content to prepend to the header section (JQuery object or HTML string)
     * @return
     */
    prependHeader(element: string | JQuery): CollapsiblePanel;
    /**
     * Appends the specified content to the display content of the control
     *
     * @param content This might be a jQuery selector or function.
     * If a function is provided, that function will be executed whenever collapse icon is clicked.
     * The function should return a content
     * @return
     */
    appendContent(element: string | JQuery | Function): CollapsiblePanel;
    isExpanded(): boolean;
    expand(): void;
    collapse(): void;
    toggleExpandedState(): boolean;
    setDisabled(isDisabled: boolean): void;
    isCollapsiblePanelDisabled(): Boolean;
}
/**
 * @publicapi
 */
export interface IAjaxPanelOptions {
    /**
     * Url to load the content from.
     */
    url?: string;
    /**
     * Url request paremeters.
     */
    urlParams?: any;
    /**
     * Callback executed if the load succeeds.
     */
    success?: Function;
    /**
     * Callback executed if the load fails.
     */
    error?: Function;
    /**
     * Determines whether status indicator is displayed or not.
     * @defaultvalue true.
     */
    showStatusIndicator?: boolean;
    cache?: boolean;
    replaceContent?: boolean;
}
/**
 * @publicapi
 */
export class AjaxPanelO<TOptions extends IAjaxPanelOptions> extends Controls.Control<TOptions> {
    static enhancementTypeName: string;
    private _cancelable;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    _dispose(): void;
    /**
     * Begins loading the content using the specified arguments.
     *
     * @param url Url to load the content from.
     * @param params Url request paremeters.
     * @param callback Callback executed if the load succeeds.
     * @param errorcallback Callback executed if the load fails.
     * @publicapi
     */
    beginLoad(url: string, params?: any, callback?: Function, errorcallback?: Function): void;
    onLoadCompleted(content: string): void;
    onLoadError(error: any, handled: boolean): void;
    showError(error: any): void;
    private _cancelPendingLoad;
}
export class AjaxPanel extends AjaxPanelO<IAjaxPanelOptions> {
}
}
declare module "VSS/Controls/PerfBar" {
export {};
}
declare module "VSS/Controls/PopupContent" {
import Controls = require("VSS/Controls");
import Utils_UI = require("VSS/Utils/UI");
export interface IPopupContentControlOptions extends Controls.EnhancementOptions {
    /**
     * Text to display. HTML content will be escaped.
     */
    text?: string | ((this: PopupContentControlO<IPopupContentControlOptions>) => string);
    /**
     * HTML content to display. Use text property for plain text instead of this.
     */
    html?: JQuery | ((this: PopupContentControlO<IPopupContentControlOptions>) => JQuery);
    /**
     * By default popup is shown on click of its drop element. If this option is set to true, the
     * popup will instead be shown on hover or focus of the drop element.
     */
    openCloseOnHover?: boolean;
    /**
     * The number of milliseconds to wait before displaying the tooltip on hover or focus.
     */
    openDelay?: number;
    /**
     * If openCloseOnHover is true, popup will be shown on focus as well as hover unlesss this is set to false.
     */
    showOnFocus?: boolean;
    /**
     * Only show the popup when this element's content overflows its visible area.
     */
    onlyShowWhenOverflows?: HTMLElement | JQuery;
    /**
     * If true, set the aria-describedby attribute on the parent.
     */
    setAriaDescribedBy?: boolean;
    /**
     * where to align the element (horizontal-vertical)
     */
    elementAlign?: string;
    /**
     * where to align the element against base element (horizontal-vertical)
     */
    baseAlign?: string;
    /**
     * behavior when the element overflows the window (horizontal-vertical)
     */
    overflow?: string;
    /**
     * how much extra left offset (if any) should be given to the target element versus the reference element.
     */
    leftOffsetPixels?: number;
    /**
     * how much extra top offset (if any) should be given to the target element versus the reference element.
     */
    topOffsetPixels?: number;
    /**
     * if set, use this instead of leftOffsetPixels when shown on mouse over
     */
    mouseLeftOffsetPixels?: number;
    /**
     * if set, use this instead of topOffsetPixels when shown on mouse over
     */
    mouseTopOffsetPixels?: number;
    supportScroll?: boolean;
    /**
     * Put the tooltip in this container. (doesn't have to be a menu)
     */
    menuContainer?: JQuery;
    /**
     * If false, position the popup on hover based on the drop element’s location, not the mouse position
     */
    useMousePosition?: boolean;
    /**
     * Whether the hover target must be _$dropElement strictly, if false then children that are inside of the _$dropElement will cause tooltipping
     */
    useStrictTarget?: boolean;
    /**
     * When a mouseover event is received, call this function. If it returns false, ignore the event.
     */
    mouseEventFilter?: (e: JQueryEventObject) => boolean;
}
export interface IPositionOptions {
    useMousePosition: boolean;
}
export class PopupContentControlO<TOptions extends IPopupContentControlOptions> extends Controls.Control<TOptions> {
    private _$dropElement;
    protected _$contentContainer: JQuery;
    private _contentSet;
    protected _visible: boolean;
    private _hasFocus;
    /** don't respond to focus events until this time */
    private _blockFocusUntil;
    private _hasMouse;
    private _enabled;
    private _documentEventDelegate;
    private _onForceHideDropPopupDelegate;
    private _handlers;
    private _delayedShow;
    private _delayedHide;
    protected _mousePosition: Utils_UI.Positioning.ILocation;
    private _lastPositionContext;
    initialize(): void;
    onForceHideDropPopup(e?: JQueryEventObject): void;
    /**
     * Set the text to display. HTML will be escaped.
     * @param content
     */
    setTextContent(content: string): void;
    /**
     * Set the rich content to display.
     * @param content
     */
    setHtmlContent(content: JQuery): void;
    /**
     * Set the content to display (in HTML)
     *
     * This method displays raw HTML. Do not use to display user-provided content without properly
     * escaping. Prefer to use setTextContent(), which escapes HTML content, or setHtmlContent(),
     * which does not.
     */
    private _setContent;
    private _initializeContent;
    private _setAriaDescribedBy;
    resetContent(): void;
    show(): void;
    toggle(): void;
    _enhance($dropElement: any): void;
    private _decorate;
    /**
     * Add an event listener on the drop element.
     *
     * Doing it this way is faster than through JQuery and still makes it convenient to clean up event listeners.
     * @param event
     * @param handler
     */
    private _listen;
    /**
     * Remove an event listener on the drop element.
     * @param event
     */
    private _stopListening;
    private _onInteract;
    private _onFocus;
    private _onBlur;
    private _onMouseMove;
    onMouseOver(e: JQueryEventObject): void;
    private _onMouseOut;
    showDelayed(): void;
    /**
     * Show the popup, after a delay if the openDelay option is set.
     */
    private _showDelayed;
    private _handleDocumentMouseDown;
    /**
     * Set the position of the popup.
     */
    _setPosition(): void;
    protected _setPositionInternal(options: IPositionOptions): void;
    protected _reposition(): void;
    _getDropElement(): JQuery;
    protected _show(options: IPositionOptions): void;
    hide(): void;
    enable(): void;
    disable(): void;
    _dispose(): void;
}
export class PopupContentControl extends PopupContentControlO<any> {
}
export interface IRichContentTooltipOptions extends IPopupContentControlOptions {
    /**
     * If explicitly set to false, show popup on click, not hover.
     */
    openCloseOnHover?: boolean;
    /**
     * If explicitly set to false, don't show the little arrow at the top of the tooltip pointing to its parent.
     */
    popupTag?: boolean;
    /**
     * If true, adjust width of the tooltip to better fit content.
     */
    autoWidth?: boolean;
}
export class RichContentTooltipO<TOptions extends IRichContentTooltipOptions> extends PopupContentControlO<TOptions> {
    private static _shownTooltip;
    private _$popupTag;
    /**
     * Hide the shown tooltip
     */
    static hide(): void;
    initializeOptions(options?: any): void;
    initialize(): void;
    _getPopupTooltipElement(): JQuery;
    protected _show(options: IPositionOptions): void;
    hide(): void;
    protected _setPositionInternal(options: IPositionOptions): void;
    /**
     * Add a tooltip to the target with common default settings.
     *
     * @param text content to place in the tooltip, either plain text or a JQuery object
     * @param target
     * @param options
     */
    static add(content: string | JQuery, target: HTMLElement | JQuery, options?: IRichContentTooltipOptions): RichContentTooltip;
    /**
     * Add a tooltip to the target with common default settings. Only display the tooltip if the
     * content in target is overflowing.
     *
     * @param content text to place in the tooltip (html in the text will be escaped)
     * @param target
     * @param options
     */
    static addIfOverflow(content: string | JQuery, target: HTMLElement | JQuery, options?: IRichContentTooltipOptions): RichContentTooltip;
}
export class RichContentTooltip extends RichContentTooltipO<any> {
}
}
declare module "VSS/Controls/RichEditor" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
export interface RichEditorAttachmentRequestData {
    fileName: string;
    binaryData: any;
}
export interface RichEditorAttachmentOperationResult {
    attachments: RichEditorAttachmentResult[];
}
export interface RichEditorAttachmentResult {
    Url: string;
}
export interface RichEditorAttachmentHandler {
    (attachment: RichEditorAttachmentRequestData): JQueryPromise<RichEditorAttachmentOperationResult>;
}
export type IRichEditorCommandHandler = (commandInfo: any, editor: RichEditor) => void;
export interface IRichEditorCommand {
    name: string;
    command: string;
    execute: IRichEditorCommandHandler;
}
export interface IRichEditorCommandGroup {
    groupName: string;
    commands: IRichEditorCommand[];
}
export enum RichEditorExternalLinkMode {
    CtrlClick = 0,
    SingleClick = 1
}
export interface IRichEditorOptions extends Controls.EnhancementOptions {
    id?: string;
    buttonGroups?: string[];
    customCommandGroups?: IRichEditorCommandGroup[];
    change?: Function;
    enabled?: boolean;
    waterMark?: string;
    altKeyShortcuts?: number[];
    ctrlKeyShortcuts?: number[];
    fireOnEveryChange?: boolean;
    linkClickHandler?: Function;
    noToolbar?: boolean;
    blankPageUrl?: string;
    pageHtml?: string;
    internal: boolean;
    /**
     * Locale - set as lang attribute on the rich editor
     */
    locale?: string;
    /**
     * Value for aria-label to apply to the richeditor
     */
    ariaLabel?: string;
    /**
     * Value for help text for accessibility
     */
    helpText?: string;
    /**
     * Function callback when the richeditor gains focus
     */
    focusIn?: Function;
    /**
     * Function callback when richeditor loses focus
     */
    focusOut?: Function;
    /**
     * Allows a single click on an image to open the image.
     */
    enableSingleClickImageOpen?: boolean;
    /**
     * Determines how to open external links. Defaults to CtrlClick
     */
    externalLinkMode?: RichEditorExternalLinkMode;
}
/**
 * @exemptedapi
 */
export class RichEditor extends Controls.Control<IRichEditorOptions> {
    static enhancementTypeName: string;
    static BOLD_COMMAND: string;
    static ITALIC_COMMAND: string;
    static UNDERLINE_COMMAND: string;
    static INSERT_UNORDERED_LIST_COMMAND: string;
    static INSERT_ORDEREDLIST_COMMAND: string;
    static INDENT_COMMAND: string;
    static OUTDENT_COMMAND: string;
    static CREATE_LINK_COMMAND: string;
    static REMOVE_FORMATTING_COMMAND: string;
    static UNLINK_COMMAND: string;
    static INSERT_IMAGE_COMMAND: string;
    static RESTORE_COMMAND: string;
    static MAXIMIZE_COMMAND: string;
    static IMAGE_AUTOFIT_SCALE_FACTOR: number;
    static WATERMARK_CSS_CLASS: string;
    static ISEMPTY_MINIMAL_CONTENT_LENGTH: number;
    private _iframe;
    private _window;
    private _textArea;
    private _isReady;
    private _readyList;
    private _editable;
    private _toolbar;
    private _urlToolTip;
    private _hasFocus;
    private _explicitFocus;
    private _keyDownInDocument;
    private _customCommandHandlersMap;
    private _currentValue;
    private _textAreaId;
    private _hasWaterMark;
    private _uploadAttachmentHandler;
    /**
     * Creates a new rich editor with the provided options
     */
    constructor(options: IRichEditorOptions);
    /**
     * @param options
     */
    initializeOptions(options?: IRichEditorOptions): void;
    hasFocus(): boolean;
    _createIn(container: any): void;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    ready(fn: any): void;
    isReady(): boolean;
    setEnabled(value: boolean): void;
    getValue(): string;
    /**
     * Checks whether rich editor is visually empty.
     *
     * Since the control uses contentEditable on real HTML, the actual DOM has many formatting and content left when it is visually empty.
     * This function provides a "best effort" check on whether it is visually empty by:
     * 1. Not empty if content length is over the minimal threshold. See RichEditor.ISEMPTY_MINIMAL_CONTENT_LENGTH.
     * 2. If content length is less than the minimal threshold, we remove the formatting before checking whether it matches any "empty" case.
     */
    isEmpty(value: string): boolean;
    setValue(value: any): void;
    /**
     * Inserts an image tag pointing to the specified url at the current caret position if possible.
     * If the current caret position cannot be determined, the image tag is inserted at the editor root node.
     *
     * @param url The url containing an image in which to link to the document.
     */
    insertImage(url: string): void;
    focus(): void;
    static getOffsetForLastElementSelection(lastElement: Element): number;
    selectText(collapseToEnd?: boolean): void;
    bindOnCopy(handler: any): void;
    getWindow(): Window;
    /**
     * Force enables the toolbar
     */
    enableToolbar(): void;
    /**
     * Force disables the toolbar
     */
    disableToolbar(): void;
    /**
     * Enables and shows the rich editor toolbar
     */
    private _enableToolbar;
    /**
     * Disables and hides the rich editor toolbar.
     */
    private _disableToolbar;
    private _resizeImageOnLoadComplete;
    setInvalid(isInvalid: boolean, styleTextArea?: boolean): void;
    setUploadAttachmentHandler(handler: RichEditorAttachmentHandler): void;
    getTextAreaId(): string;
    /**
     * Checks whether the value of the control is changed or not and fires the CHANGE event if it has
     */
    checkModified(): void;
    /**
     * Gets the outerHeight of the control
     */
    getOuterHeight(includeMargin?: boolean): number;
    /**
     * Gets the height of the control
     */
    getHeight(): number;
    /**
     * Sets the height of the control
     */
    setHeight(newHeight: number): void;
    private _pasteImage;
    private _getToolbar;
    private _onFocusToolbar;
    private _onFocusOutToolbar;
    private _createToolbar;
    /**
     * Creates a toolbar button group.
     *
     * @param customGroup An object representing a toolbar button group.
     */
    private _createToolbarButtonGroup;
    private _showPanel;
    /**
     * @param opacity
     */
    private _showToolbar;
    private _hideToolbar;
    private _getUrlToolTip;
    private _createUrlToolTip;
    private _showUrlToolTip;
    private _decorate;
    private _initialize;
    private _cleanUp;
    /**
     * Attaches necessary events to catch the changes if the control is enabled
     */
    private _attachEvents;
    private _detachEvents;
    /**
     * @param e
     * @return
     */
    private _onDblClick;
    /**
     * Attempts to launch a new browser window from the specified element if the element is an 'img' tag.
     * @param element
     */
    private _openImage;
    private _onDocumentReady;
    private _trySettingWaterMark;
    private _clearWaterMark;
    /**
     * @param e
     * @return
     */
    private _onFocusIn;
    /**
     * @param e
     * @return
     */
    private _onFocusOut;
    private _onPaste;
    private _doesStringItemExist;
    private _getImageItem;
    private _getRandomFileName;
    private _onFileReadComplete;
    private _uploadAttachment;
    private _onUploadComplete;
    private _onUploadError;
    /**
     * @param e
     * @return
     */
    private _onClick;
    /**
     * @param e
     * @return
     */
    private _onMouseUp;
    /**
     * @param e
     * @return
     */
    private _onMouseDown;
    private _reTriggerKeyboardEvent;
    /**
     * Create a synthetic keyboard event. This is needed to dispatch
     * an event in IE11 since it doesn't allow re-dispatching of existing events
     * @param domEvent A dom keyboard event
     */
    private _buildSyntheticKeyboardEvent;
    /**
     * @param e
     * @return
     */
    private _onKeyDown;
    /**
     * @param e
     * @return
     */
    private _onKeyPress;
    /**
     * @param e
     * @return
     */
    private _onKeyUp;
    /**
     * @param e
     * @return
     */
    private _onInput;
    /**
     * @param e
     */
    private _onToolbarButtonClick;
    private _getNodeUnderCaret;
    /**
     * Finds the node in the ancestors with the specified tag name
     */
    private _getNodeAncestor;
    /**
     *  Gets a W3C Range or Microsoft TextRange object depending on the running browser.
     * These object types are completely incompatible, so the caller must branch
     * on platform or simply compare for equality.
     */
    private _getTextRange;
    /**
     * Checks whether clicked element is a link and launches url
     *
     * @param e
     */
    private _checkForHrefClick;
    private _launchHref;
    /**
     * launch the Url associated with a linkNode
     */
    private _processAndLaunchHref;
    private _executeCommand;
    /**
     * Creates a hyperlink in this window and selects the new link.
     *
     * @param args The new link address.
     */
    private _createHyperlink;
    private _removeFormatting;
    private _highlightRange;
    private _setEditable;
    private _processReadyList;
    private _ensureControlReadiness;
    private _normalizeValue;
}
}
declare module "VSS/Controls/Search" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
import Search = require("VSS/Search");
/**
 * @interface
 * An interface for SearchBoxControl options
 */
export interface ISearchBoxControlOptions {
    /**
    * filterTitle: Optional: Aria-label for the control input.
    */
    filterTitle?: string;
    /**
     * activateSearchHandler: Optional: Callback when the control is activated.
     */
    activateSearchHandler?: Function;
    /**
     * deactivateSearchHandler: Optional: Callback when the control is deactivated.
     */
    deactivateSearchHandler?: Function;
    /**
     * inputChangedEventHandler: Optional: When the control input changed.
     */
    inputChangedEventHandler?: Function;
    /**
     * hideWatermark: Optional: Set to true to hide watermark for the control.
     */
    hideWatermark?: boolean;
    /**
     * searchIconTooltip: Optional: Tooltip for the search icon of ToggleSearchBoxControl.
     */
    searchIconTooltip?: string;
    /**
     * Optional: Search icon, defaults to bowtie-search icon.
     */
    searchBoxIcon?: string;
    /**
     * Optional: Search box icon when it's active, default behaviour is icon unchanged.
     */
    searchBoxActiveIcon?: string;
    /**
     * Optional: Place holder/water mark text for search box.
     */
    placeholderText?: string;
    /**
     * Optional: Tab index for search box.
     */
    tabIndex?: number;
}
/**
 * A input box control for search or filter.
 */
export class SearchBoxControl extends Controls.Control<ISearchBoxControlOptions> {
    private static inputChangedEventThrottlingInterval;
    private _$searchInputTextbox;
    private _$searchIcon;
    private _active;
    private _suppressBlur;
    private _activateSearchHandler;
    private _deactivateSearchHandler;
    private _inputChangedEventHandler;
    private _value;
    private _inputChangedEventHandlerReset;
    private _tabIndex;
    private _subsequentInputChange;
    private _bowtieSearchIcon;
    constructor(options?: ISearchBoxControlOptions);
    initialize(): void;
    /**
     * Return the triming value of the input box.
     */
    getValue(): string;
    /**
     * Return the value of the input box.
     */
    private _getValue;
    /**
     * Displays the search box and hides the search button.
     */
    activateSearch(): void;
    /**
     * Removes the search box and shows the search button instead.
     */
    deactivateSearch(deactivateSearchHandler?: boolean): void;
    protected _displaySearchInputBox(isVisible: boolean): void;
    private _clearInput;
    private _createSearchInput;
    private _getSearchIconClass;
    private _searchIconClickHandler;
    private _bindInputChangedEventHandler;
    private _keyDown;
    private _keyUp;
    private _mouseDown;
    private _mouseUp;
    private _mouseOut;
    /**
     * Handle the blur which deactivates search
     */
    private _handleBlur;
    /**
     * Handle the focus which activates search
     */
    private _handleFocus;
}
export interface IToggleSearchBoxControlOptions extends ISearchBoxControlOptions {
    isDataSetComplete?: Function;
}
/**
 * A search icon control. When click, it expands to input box control for search or filter.
 */
export class ToggleSearchBoxControl extends SearchBoxControl {
    private _$searchIconContainer;
    private _isDataSetComplete;
    constructor(options?: IToggleSearchBoxControlOptions);
    initializeOptions(options?: any): void;
    initialize(): void;
    /**
     * Show the inputbox and hide the search icon.
     */
    activateSearch(): void;
    /**
     * Hide the inputbox and shows the search icon.
     */
    deactivateSearch(): void;
    private _addSearchToggleIcon;
    private _searchIconHoverIn;
    private _searchIconHoverOut;
    private _toggleSearchIcon;
    private _searchIconKeyDownHandler;
    private _searchIconkeyUpHandler;
}
export interface ITextFilterControlOptions extends ISearchBoxControlOptions {
    adapter?: Search.SearchAdapter<any>;
    comparer?: IComparer<any>;
    delimiter?: string | RegExp;
}
export class TextFilterControl extends Controls.Control<ITextFilterControlOptions> {
    static tagName: string;
    static coreCssClass: string;
    _textFilterInput: SearchBoxControl;
    _searchCore: Search.SearchCore<any>;
    private _active;
    private _suppressBlur;
    private _tabIndex;
    _searchAdapter: Search.SearchAdapter<any>;
    /**
     * Control for backlog search.
     *
     * @param options Options for the control
     */
    constructor(options?: ITextFilterControlOptions);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    isActive(): boolean;
    /**
     * Initializes the control. Creates the search box and initializes events.
     */
    initialize(): void;
    protected _createSearchStrategy(): Search.SearchStrategy<any>;
    private _createSearchInputBox;
    /**
     * Displays the search box and hides the search button
     */
    activateSearch(): void;
    /**
     * Removes the search bar and shows the search button instead
     *
     * @param suppressClear Suppress the clearing event
     */
    deactivateSearch(suppressClear?: boolean): void;
    /**
     * Creates the index in the searchCore
     */
    createIndex(): void;
    /**
     * Clears the index in the Search Core
     */
    clearIndex(): void;
    /**
     * Clears the store and performs the search if search is active.
     */
    refreshResults(): void;
    /**
     * Handle input changed event.
     */
    attachEventOnKeyUp(e?: JQueryEventObject): void;
    /**
     * Perform the search.
     */
    _performSearch(): void;
}
}
declare module "VSS/Controls/Splitter" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!Splitter" />
import Controls = require("VSS/Controls");
/**
 * @publicapi
 */
export interface ISplitterOptions {
    /**
     * Initial size of the grid in px.
     */
    initialSize?: number;
    /**
     * Specifies which side of the splitter is fixed (left or right).
     * @defaultvalue "left"
     */
    fixedSide?: string;
    /**
     * Specifies whether the split should be vertical or not.
     * @defaultvalue true
     */
    vertical?: boolean;
    /**
     * Text displayed on splitter handle when toggle button is enabled and splitter is collapsed.
     */
    collapsedLabel?: string;
    /**
     * Enables the toggle button which displays a button for expand/collapse.
     * @defaultvalue false
     */
    enableToggleButton?: boolean;
    animationSpeed?: number;
    expandState?: string;
    /**
     * Sets the minimum width of the splitter's fixed side.
     */
    minWidth?: number;
    /**
     * Sets the maximum width of the splitter's fixed side.
     */
    maxWidth?: number;
    /**
     * Optional: Tooltip show on the toggle button when the splitter is collapsed
     */
    toggleButtonCollapsedTooltip?: string;
    /**
     * Optional: Tooltip show on the toggle button when the splitter is expanded
     */
    toggleButtonExpandedTooltip?: string;
    /**
     * Optional: Toggle handler called when expand state changes
     */
    onToggle?: (isExpanded: boolean) => void;
}
/**
 * @publicapi
 */
export class SplitterO<TOptions extends ISplitterOptions> extends Controls.Control<TOptions> {
    static enhancementTypeName: string;
    private static _noSplitCssClass;
    static CORE_CSS_CLASS: string;
    static HORIZONTAL_CLASS: string;
    static VERTICAL_CLASS: string;
    static TOGGLE_BUTTON_LENGTH: number;
    static TOGGLE_BUTTON_MARGIN: number;
    static COLLAPSED_CLASS_NAME: string;
    static TOGGLE_BUTTON_ENABLED_CLASS_NAME: string;
    static TOGGLE_BUTTON_HOTKEY_ENABLED_CLASS_NAME: string;
    static AUTO_COLLAPSE_THRESHOLD: number;
    static DEFAULT_ANIMATION_SPEED: number;
    static HANDLE_BAR_CLONE_SIZE: number;
    private _screenXY;
    private _cssPosProp;
    private _cssSizeProp;
    private _leftFix;
    private _fixedSide;
    private _fillSide;
    private _deltaMultiplier;
    private _dragStart;
    private _fixedSidePixels;
    private _splitterOverlay;
    private _$handleBarClone;
    private _ignoreWindowResize;
    private _$toggleButton;
    private _$toggleButtonIcon;
    private _minWidth;
    private _maxWidth;
    private _savedFixedSidePixels;
    leftPane: JQuery;
    rightPane: JQuery;
    handleBar: JQuery;
    /**
     * Set to null or undefined if the splitter is currently not collapsed.
     * "right" if collapsed on the left side of the page.
     * "left" if collapsed on the right side of the page.
     */
    expandState: string;
    constructor(options: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @param element
     */
    _enhance(element: JQuery): void;
    initialize(): void;
    private _setupHandleBar;
    private _setInitialSize;
    /**
     * Sets the minimum width of the splitter's fixed side.
     *
     * @param minWidth minimum number of pixels the fixed side will fill.
     * @publicapi
     */
    setMinWidth(minWidth: number): void;
    /**
     * Sets the maximum width of the splitter's fixed side.
     *
     * @param maxWidth maximum number of pixels the fixed side will fill.
     * @publicapi
     */
    setMaxWidth(maxWidth: number): void;
    private _getAdjustedSize;
    /**
     * Resize the fixed side of the splitter to the specified size.
     *
     * @param newSize New fixed side size in px.
     * @param suppressFireResize Determines whether to suppress firing resize event or not.
     * @param useAnimation Determines whether to use animation during resize or not.
     * @param complete A callback function to notify that the resize operation completes.
     * @publicapi
     */
    resize(newSize: any, suppressFireResize?: boolean, useAnimation?: boolean, complete?: Function): void;
    /**
     * Expand or collapse the splitter.
     *
     * @param expanded True to expand the splitter, false to collapse it. If not provided, the expansion state toggles.
     */
    toggleExpanded(expanded?: boolean): void;
    /**
     * Expands the splitter.
     * @publicapi
     */
    expand(): void;
    /**
     * Collapses the splitter.
     * @publicapi
     */
    collapse(): void;
    /**
     * Specifies whether the splitter is expanded or not.
     *
     * @returns {boolean}
     * @publicapi
     */
    isExpanded(): boolean;
    /**
     * Expands the splitter.
     * @param suppressResize
     */
    removeExpand(suppressResize?: boolean): void;
    /**
     * Collapses the splitter.
     * @param side
     */
    protected _expandInternal(side?: string): void;
    /**
     * Gets the fixed side size in px.
     *
     * @returns {number}
     * @publicapi
     */
    getFixedSidePixels(): number;
    /**
     * Shows/hides the fixed side of the splitter.
     * @param visible whether the fixed side should be shown. Defaults to false, does NOT toggle.
     */
    toggleSplit(visible?: boolean, animate?: boolean, defaultExpandToPixels?: number): void;
    /**
     * Disables the split.
     * @publicapi
     */
    noSplit(animate?: boolean): void;
    /**
     * Enables the split.
     *
     * @param animate Determines split operation is animated or not (default false).
     * @param defaultExpandToPixels Specified value used for split amount. If not specified default value is used.
     * @publicapi
     */
    split(animate?: boolean, defaultExpandToPixels?: number): void;
    /**
     * @param newSize
     */
    toggleOrientation(vertical: any, newSize?: number): void;
    /**
     * Changes split orientation to vertical.
     * @publicapi
     */
    vertical(): void;
    /**
     * Changes split orientation to horizontal.
     * @publicapi
     */
    horizontal(): void;
    /**
     * Sets the orientation value of corresponding aria attribute.
     *
     * @param vertical Determines whether splitter in vertical position or not.
     */
    private _setAriaOrientation;
    /**
     * Sets the label that is shown when the splitter is collapsed
     *
     * @param labelText Text displayed when the splitter is collapsed (null/empty for none)
     * @publicapi
     */
    setCollapsedLabel(labelText: string): void;
    _createElement(): void;
    private _configureCssProps;
    private _attachEvents;
    /**
     * Gets the collapse/expand toggle button of this splitter control.
     */
    private _ensureToggleButton;
    /**
     * Re-position the toggle button.
     *
     * @param useAnimation true if the layout change is animated; false, otherwise.
     */
    private _layoutToggleButton;
    /**
     * Set toggle button icon class for rendering
     *
     * @param isExpanded true if to show expanded icon; false, otherwise.
     */
    private _setToggleButtonIconClass;
    /**
     * Sets the tooltip for the toggle button.
     */
    private _setToggleButtonTooltip;
    /**
     * set the handler on toggle - this should only be used when Splitter control was automatically enhanced, otherwise specify in options
     */
    setOnToggle(handler: (isExpanded: boolean) => void): void;
    /**
     * Measures the full size of the fixed side pane.
     */
    private _measureFixedSide;
    private _handleBarMouseDown;
    private _handleBarKeydown;
    /**
     * Moves the separator either left or right.
     */
    private _moveSeparator;
    /**
     * Checks if the toggle button is enabled.
     */
    private _isToggleButtonEnabled;
    /**
     * Checks if the toggle button hotkey is enabled.
     */
    private _isToggleButtonHotkeyEnabled;
    /**
     * Checks if the splitter is marked as collapsed.
     */
    private _isCollapsed;
    /**
     * Handles the keyup event for the document.
     *
     * @param e
     * @return
     */
    private _onDocumentKeyup;
    /**
     * Handles the click event for the toggle button.
     *
     * @param e
     * @return
     */
    private _onToggleButtonClick;
    /**
     * Ensures that a clone of the handlebar is available.
     */
    private _ensureHandleBarClone;
    /**
     * Removes the handlebar clone.
     */
    private _removeHandleBarClone;
    private _setupDragEvents;
    private _ensureOverlay;
    private _removeOverlay;
    private _clearDragEvents;
    /**
     * @param e
     * @return
     */
    private _documentMouseMove;
    /**
     * @param e
     * @return
     */
    private _documentMouseUp;
    private _onWindowResize;
    private _fireWindowResize;
    /**
     * Attaches the splitter to the window resize event, performing a resize immediately if specified
     * by the input parameter. This is primarily useful for attaching to the resize event after the
     * splitter has just been re-attached to the DOM and needs to see if the viewwport size has changed.
     *
     * @param resizeNow Whether or not the splitter should perform resize now.
     */
    attachResize(resizeNow?: boolean): void;
    /**
     * Detaches the splitter from the window resize event (tells it to ignore the event).
     */
    detachResize(): void;
    /**
     * Creates an option object to be used with $.animate().
     *
     * @param cssPropertyName The CSS property for the animation.
     * @param cssPropertyValue The target CSS property value for the animation.
     */
    private _createAnimationOption;
    /**
     * @param e
     * @return
     */
    private _handleBarDoubleClick;
    _dispose(): void;
    unregisterEvents(): void;
}
export class Splitter extends SplitterO<ISplitterOptions> {
}
}
declare module "VSS/Controls/StatusIndicator" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
import Utils_Core = require("VSS/Utils/Core");
export interface IStatusIndicatorOptions {
    message?: string;
    eventTarget?: any;
    imageClass?: string;
    center?: boolean;
    throttleMinTime?: number;
    statusStartEvent?: string;
    statusCompleteEvent?: string;
    statusErrorEvent?: string;
    /**
     * If true (the default), announce through the screen reader (if present) when the progress
     * indicator is loading and has completed loading.
     */
    announceProgress?: boolean;
}
export class StatusIndicatorO<TOptions extends IStatusIndicatorOptions> extends Controls.Control<TOptions> {
    static getActiveCount(): number;
    static enhancementTypeName: string;
    /** list of all StatusIndicatorO objects */
    private static _allIndicators;
    private static _announcer;
    private _statusDiv;
    private _image;
    private _throttleMinTime;
    private _delayStart;
    private _lastError;
    private _active;
    isActive(): boolean;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    _dispose(): void;
    /**
     * @param event
     */
    start(options?: IStatusIndicatorOptions): void;
    /**
     * @param delay
     */
    delayStart(delay: number): void;
    complete(): void;
    error(error: Error): void;
    setMessage(message: string): void;
    showElement(): void;
    hideElement(): void;
    private _draw;
    private _start;
    private _onClick;
    private _setImageClass;
    private _bindEvents;
    private _error;
    private _startHandler;
    private _clearTimeout;
}
export class StatusIndicator extends StatusIndicatorO<IStatusIndicatorOptions> {
}
export class LongRunningOperation {
    private _cancelable;
    private _options;
    private _$rootElement;
    private _waitControl;
    private _state;
    private _cancelled;
    /**
     * Creates a new long running operation, showing a blocking indicator in a cancellable means overtop the specified container until the operation has completed.
     *
     * @param container A DOM object that contains the control on the page in which to overlay the progress indicator.
     * @param options A collection of configuration name/value pairs.  The following are supported:
     *     Name                  Type        Value
     *     cancellable           boolean     Boolean value indicating whether the operation may be cancelled while it is running.
     *
     */
    constructor(container: any, options?: any);
    /**
     * Begins the long running operation, invoking the specified operationCallback when necessary.
     *
     * @param operationCallback An operation that may take a long time to complete.
     */
    beginOperation(operationCallback: IResultCallback): void;
    protected createWaitControl(options: IWaitControlOptions): WaitControl;
    protected getCancellableOperation(): Utils_Core.Cancelable;
    getWaitControl(): WaitControl;
    /**
     * Signals the completion of a long running operation.
     */
    endOperation(): void;
    /**
     * Gets a boolean value indicating whether the current operation has a pending cancel request.
     */
    isCancelled(): boolean;
    /**
     * Cancels the current operation.
     */
    cancelOperation(): void;
    /**
     * Initializes the long running operation.
     */
    private _initialize;
}
export enum WaitingState {
    NotStarted = 0,
    Waiting = 1,
    Ending = 2,
    Ended = 3,
    Cancelling = 4,
    Cancelled = 5
}
/**
 * @publicapi
 */
export interface IWaitControlOptions extends Controls.EnhancementOptions {
    /**
     * Target element in which an overlay and a message box is displayed. If not specified, whole window is used.
     * @defaultvalue window
     */
    target?: JQuery;
    /**
     * Text to be displayed in the message box.
     */
    message?: string;
    /**
     * Message format used if the cancellable is true. Defaut value is {message}({cancelText}).
     */
    messageFormat?: string;
    /**
     * Specifies whether this is control is cancellable or not. If yes, a cancel link is displayed in the message box.
     * @defaultvalue false
     */
    cancellable?: boolean;
    /**
     * Cancel text format used when displaying cancel text.
     * @defaultvalue "Press {0} to cancel"
     */
    cancelTextFormat?: string;
    /**
     * Callback executed when the control is cancelled.
     */
    cancelCallback?: Function;
    /**
     * Sepcifies whether to fade out the message box when the operation is cancelled or ended.
     * @defaultvalue true
     */
    fade?: boolean;
    /**
     * Specifies the amount of delay in milliseconds when the message box is displayed.
     * @defaultvalue 250
     */
    showDelay?: number;
    /**
     * Overlay color.
     */
    backgroundColor?: string;
    /**
     * Progress image to be displayed.
     */
    image?: string;
    messageElement?: JQuery;
    element?: JQuery;
    entireWindow?: boolean;
    cancelLinkId?: string;
    extraStyles?: string;
    minLifetime?: number;
    minLifeSpanBlocking?: boolean;
}
export interface WaitContext {
    instanceId?: string;
    options?: {
        wait: IWaitControlOptions;
    };
    cancellable?: Utils_Core.Cancelable;
    showTimer?: Utils_Core.DelayedFunction;
}
/**
 * @publicapi
 */
export class WaitControlO<TOptions extends IWaitControlOptions> extends Controls.Control<TOptions> {
    private static _instanceIdSeed;
    static DefaultShowDelay: number;
    static MinLifeTime: number;
    private _originalFocusElement;
    private _context;
    private _state;
    private _keyDownEventHandler;
    /**
     * Constructs a WaitControl object.
     *
     * @param options The options to initialize the control. It has the following properties:
     *   {
     *       image: hostConfig.getResourcesFile('big-progress.gif'),   // optional
     *       message: "Please wait...",                                // optional
     *       target: $('.feedbackrequest-form-container')              // optional
     *       cancellable: true                                         // optional
     *       cancelCallback: function() { // do something }            // optional and only effective when cancellable is true
     *   }
     *
     * @return A WaitControl object.
     */
    constructor(options?: TOptions);
    initializeOptions(options: TOptions): void;
    initialize(): void;
    /**
     * Starts waiting by displaying message box and overlay in the target element.
     *
     * @param cancelable A VSS.Core.Cancelable object for additional cancel state signaling.
     * @publicapi
     */
    startWait(cancellable?: Utils_Core.Cancelable): void;
    /**
     * Ends waiting by removing message box and overlay.
     * @publicapi
     */
    endWait(): void;
    /**
     * Cancels waiting by removing message box and overlay.
     * @publicapi
     */
    cancelWait(): void;
    /**
     * Sets a new message for the displayed message box.
     *
     * @param message Message to be displayed.
     * @publicapi
     */
    setMessage(message: string): void;
    /**
     * Indicates whether the operation is cancelled or not.
     *
     * @returns {boolean}
     * @publicapi
     */
    isCancelled(): boolean;
    /**
     * Determines if the current waiting session can be started.
     */
    private _canStartWait;
    /**
     * Determines if the current waiting session can be ended.
     */
    private _canEndWait;
    /**
     * Determines if the current waiting session can be cancelled.
     */
    private _canCancelWait;
    /**
     * Starts the waiting.
     */
    private _startWait;
    /**
     * Ends the waiting.
     */
    private _tryEndWait;
    /**
     * Cancels the waiting.
     */
    private _tryCancelWait;
    /**
     * Resets this wait control.
     */
    private _reset;
    protected updateWaitElements(wait: IWaitControlOptions): void;
    /**
     * Shows the wait control.
     */
    private _showWait;
    protected getWaitingState(): WaitingState;
    protected getWaitingContext(): WaitContext;
    /**
     * Resizes the waiting control.
     */
    private _resizeWait;
    /**
     * Handles the keydown event.
     *
     * @param e
     * @return
     */
    private _onKeyDown;
    /**
     * Handles the events to cancel wait.
     *
     * @param e
     * @return
     */
    private _handleCancelEvent;
    /**
     * Binds the keydown event
     *
     * @param cancelLinkId The id of the cancel hyperlink.
     */
    private _bindKeydownEvent;
    /**
     * Unbinds the keydown event
     */
    private _unbindKeydownEvent;
    /**
     * Removes the wait element.
     */
    private _removeWaitElement;
    /**
     * Removes the timers used by this controls.
     */
    private _removeShowTimer;
    /**
     * Gets the unique resize event id for the wait control.
     *
     * @return The resize event id.
     */
    private _getResizeEventId;
    /**
     * Gets the text message to show in the wait control.
     *
     * @param wait The wait options.
     */
    private _getWaitMessage;
    getWaitMessageFormatString(): string;
}
export class WaitControl extends WaitControlO<IWaitControlOptions> {
}
}
declare module "VSS/Controls/TabContent" {
/// <amd-dependency path="jQueryUI/button" />
/// <amd-dependency path="jQueryUI/droppable" />
import Controls = require("VSS/Controls");
import Dialogs = require("VSS/Controls/Dialogs");
/**
 * The tab groups with tabs for the tab control
 */
export interface ITabGroup {
    /**
     * The registered group id that uniquely identify a group
     */
    id: string;
    /**
     * The group title that displays on the tab collection
     */
    title: string;
    /**
     * The order of the tab group that shows on the tab control
     */
    order: number;
    /**
     * The tabs for the tab group
     */
    tabs: ITab<any>[];
}
/**
 * The tabs in a tab group
 */
export interface ITab<T> {
    /**
     * The registered tab id that uniquely identify a tab
     */
    id: string;
    /**
     * The tab title that displays on the tab control
     */
    title: string;
    /**
     * The order of the tab that shows within the tab group.
     */
    order: number;
    /**
     * Retrieves the ITabContent instance for the content tab
     */
    tabContent: new (options?: T) => ITabContent;
    /**
     * The options object of the tab content.
     */
    tabContentOptions?: T;
}
/**
 * The interface for user to register a tab to a tab control
 */
export interface ITabRegistration<T> {
    /**
     * The registered group id that uniquely identify a group
     */
    groupId: string;
    /**
     * The registered tab id that uniquely identify a tab. When it is not defined, a GUID will be generated to be the id.
     */
    id?: string;
    /**
     * The tab title that displays on the tab control. When it is not defined, it will append to the existing tabs in the tab group.
     */
    title: string;
    /**
     * The order of the tab that shows within the tab group.
     */
    order?: number;
    /**
     * Retrieves the ITabContent instance for the content tab
     */
    tabContent: new (options?: T) => ITabContent;
    /**
     * The option object of the tab content.  When it is not defined, an empty object will be created.
     */
    tabContentOptions?: T;
}
/**
 * The interface for user to register a tab group
 */
export interface ITabGroupRegistration {
    /**
     * The id for the targeted tab control
     */
    tabControlId: string;
    /**
     * The group id that uniquely identify a group
     */
    id: string;
    /**
     * The group title
     */
    title: string;
    /**
     * The order of the tab group that shows on the tab control. When it is not defined, it will append to the existing groups.
     */
    order?: number;
}
/**
 * The tab page content instantiate when a tab is registered to the control.
 */
export interface ITabContent {
    /**
     * This method is called when user clicks on the tab for the first time.
     */
    beginLoad?($container: JQuery): IPromise<any>;
    /**
     * Begin persisting user changes
     * Returns a promise that in turn returns a boolean flag, indicating whether the current save operation requires page refresh or not
     */
    beginSave?(): IPromise<boolean>;
    /**
     * Indicates if the control is dirty
     */
    isDirty(): boolean;
    /**
     * Accepts the event handlers for onDirtyStateChanged and onValidStateChanged events
     */
    registerStateChangedEvents?(eventHandler: Function): void;
    /**
     * Optional method. When navigation mode for tab control is set to "CUSTOMIZED",
     * the method is called to see if user is allowed to leave the tab.
     */
    onTabChanging?(): boolean;
    /**
     * Optional method. When defined, it is called when user clicks back to the tab.
     * This method will NOT be called for the first time user clicks the tab, use beginLoad($container) instead.
     */
    onTabActivated?(initialLoad: boolean): void;
    /**
     * Optional method. Called when the control is getting resized.
     */
    onResize?(): void;
    /**
    * This is the callback after content has been saved.
    */
    applyChanges?: Function;
    /**
     * Optional method. Called when the control is getting disposed.
     */
    dispose?(): void;
}
/**
* The enum for tab control saving result status
*/
export enum TabSavingStatus {
    /**
     * user input in invalid, no server saving is issued.
     */
    INVALID_USER_INPUT = 0,
    /**
     * error in server saving
     */
    SERVER_SAVING_ERROR = 1,
    /**
     * server saving succeeded
     */
    SUCCEEDED = 2,
    /**
     * dirty flag is clean, no server saving is issued.
     */
    NO_CHANGE = 3
}
/**
* The enum for tab control saving mode
*/
export enum TabControlSavingMode {
    /**
     * Content control is responsible for saving, tab control doesn't provide any saving mechanizm
     */
    NONE = 0,
    /**
     * Saving is on tab level
     */
    APPLY_ON_TAB = 1,
    /**
     * Saving is on control level, user needs to call beginSave method on tabControl
     */
    SAVE_ON_CONTROL = 2
}
/**
* The enum for tab control navigation mode
*/
export enum TabControlNavigationMode {
    /**
     * Always allow user to navigate away from current tab
     */
    ALWAYS_NAVIGATE = 0,
    /**
     * Call tabContentControl onTabChanging() to determine if user can navigate away from current tab. If onTabChanging()
     * is not defined, allow user to navigate away.
     */
    CUSTOMIZED = 1
}
/**
* The tab control option
*/
export interface ITabControlOption {
    /**
     * The tab groups and tabs for the control to render tabs.
     * When it is not defined, the control will try to get the tab groups from tab registration.
     */
    groups?: ITabGroup[];
    /**
     * The saving mode for the control.
     */
    savingMode: TabControlSavingMode;
    /**
     * The generic saving error message. Displayed when TabControlSavingMode is set to SAVE_ON_CONTROL.
     */
    errorMessage?: string;
    /**
     * Used to get the tab groups from tab registration.
     * User has to specify either groups or id, when both specified, it will use groups for tab generation.
     */
    id?: string;
    /**
     * Used to set the default tab while initializing the control.
     * If not specified, the default tab would be the first tab in the list.
     */
    defaultTabId?: string;
    /**
     * Hides the tabs titles area if true
     */
    hideTabsPane?: boolean;
}
/**
 * A control for content across multiple tabs.
 */
export class TabControl extends Controls.Control<ITabControlOption> {
    static EVENT_DIRTY_STATE_CHANGED: string;
    static EVENT_VALID_STATE_CHANGED: string;
    static EVENT_SAVING_STATE_CHANGED: string;
    private _activeTab;
    private _groups;
    private _tabPages;
    private _$tabControlOverlay;
    private _statusIndicator;
    private _$settingsMessageArea;
    private _$settingsMessageTextArea;
    private _$contentContainerElement;
    private _navigationMode;
    private _savingMode;
    private _isDirty;
    private _isSaving;
    private _$tabTitles;
    private _$tabTitleContainer;
    private _refreshOnClose;
    private _onSavedCallbackList;
    private _arrowScrollbar;
    /**
     * @param options
     */
    initializeOptions(options?: ITabControlOption): void;
    /**
     * Initialize the control
     */
    initialize(): void;
    private _addScrollSupport;
    private _getTabGroup;
    private _createMessageArea;
    /**
     * Recalculate the size and update the navigation buttons
     */
    onResize(): void;
    /**
     * Check the dirty states for the all tab pages
     * @return True if any of the tab pages is dirty
     */
    isDirty(): boolean;
    /**
     * Check the saving states for the all tab pages
     * @return True if any of the tab pages is saving
     */
    isSaving(): boolean;
    invokeSaveCallbacks(): void;
    clearOnSavedCallbackList(): void;
    getRefreshOnCloseStatus(): boolean;
    private _createTabControl;
    private _onTabChanged;
    private _onTabChanging;
    private _onTabSaved;
    private _onSavingStateChanged;
    private _onDirtyStateChanged;
    private _showError;
    private _hideError;
    /**
     * Check if there is an invalid page. Focus on the first invalid page if there is any.
     * Begin to persist user changes by iterate all the tab pages and call the beginSave() for each page if it is dirty and valid
     * @param e The event that trigger the saving
     * @return JQueryPromise for saving content. Fullfilled when all the pages are saved successfully and rejected when any one of them get rejected.
     */
    beginSave(e?: JQueryEventObject): IPromise<TabSavingStatus>;
    private _showOverlay;
    private _hideOverlay;
    dispose(): void;
}
/**
 * The tab page option
 */
export interface ITabPageOption {
    /**
     * The tab information associated with tab page
     */
    tab: ITab<any>;
    /**
     * Dom element to host the tab title
     */
    titleContainer: JQuery;
    /**
     * Dom element to host the tab content
     */
    contentContainer: JQuery;
    /**
     * callback function after tab changed
     */
    onTabChanged: Function;
    /**
     * callback function when tab changing
     */
    onTabChanging: Function;
    /**
     * callback function after tab saved
     */
    onTabSaved: Function;
    /**
     * callback function when saving state changes
     */
    onSavingStateChanged: Function;
    /**
     * callback function when dirty state changes
     */
    onDirtyStateChanged: Function;
    /**
     * navigation mode from tab control
     */
    navigationMode: TabControlNavigationMode;
    /**
     * saving mode from tab control
     */
    savingMode: TabControlSavingMode;
    /**
     * If set to true, the control will handle the server errors and the individual tabs should handle only the client-side validation errors
     */
    handleServerError?: boolean;
    /**
     * The first tab should have tabindex 0, the remaining -1.
     */
    tabIndex: 0 | -1;
}
/**
 * A base class for the all the tab content classes that implement the ITabContent.
 * You can start with other class, but make sure you implement ITabContent.
 */
export class TabContentBaseControl extends Controls.BaseControl implements ITabContent {
    private _isDirty;
    private _isValid;
    private _onDirtyStateChanged;
    constructor(options?: any);
    /**
     * Gets the dirty state for the content control
     * @return boolean
     */
    isDirty(): boolean;
    /**
     * Method that lets the container specify the delegates to be called on state change in the tab content
     * @param onDirtyStateChanged The delegate for the dirty state transition
     */
    registerStateChangedEvents(onDirtyStateChanged: Function): void;
    /**
     * Method that renders the actual control
     * @param $container The DOM element, to which the control should be added
     * @return IPromise Resolve if render successfully, reject if failed
     */
    beginLoad($container: JQuery): IPromise<any>;
    /**
     * Set the dirty state for the content control, make sure call this for any dirty state change
     * @param isDirty
     */
    fireDirtyFlagChange(isDirty: boolean): void;
    /**
     * Begin to persist user changes, make sure you overwrite this
     * @return JQueryPromise for saving content.
     */
    beginSave(): IPromise<boolean>;
    dispose(): void;
}
/**
 * Page scoped registration for tab controls, this is the place for tabControl to get tab group when group is not specified in the option.
 */
export class TabControlsRegistration {
    private static _tabControlRegistrations;
    private static _orderGap;
    private static _orderInitValue;
    /**
     * Register a group to a tabControl
     * If the groupId has been registered to the control, it will error out
     * @param groupRegistration The group that needs to be registered
     */
    static registerTabGroup(groupRegistration: ITabGroupRegistration): void;
    /**
     * Get a list of tab groups for a tab control
     * @param tabControlId
     * @return a list of tab groups
     */
    static getRegisteredTabGroups(tagControlId: string): ITabGroup[];
    /**
     * Register a tab for tab group.
     * The groupId is not registered, call registerTabGroup first
     * If id is provided, the tab will be registered with that id. If not, the tab will get a generated Guid as id.
     * If the provided id has been registered for that group, the request will error out.
     * @param registration a tab and group
     * @return id of the tab
     */
    static registerTab<T>(registration: ITabRegistration<T>): string;
    /**
     * Remove a tab by Id for a tab control
     * @param tabControlId for the targeted tab control
     * @param id for tab
     */
    static removeTab(tabControlId: string, id: string): void;
    /**
     * Remove a tab group by group Id for a tab control
     * @param tabControlId for the targeted tab control
     * @param groupId for tab group
     */
    static removeTabGroup(tabControlId: string, groupId: string): void;
    /**
     * Remove tab registrations for a tab control when tabControlId is provided
     * Remove all tab registrations if tabControlId is not present
     * @param tabControlId for the targeted tab control
     */
    static clearRegistrations(tabControlId?: string): void;
    private static _sortTabGroups;
    private static _sortTabs;
    private static _getNextGroupOrder;
    private static _getNextTabOrder;
    private static _createNewTab;
}
/**
 * The interface for each button on a TabbedDialog
 */
export interface ITabbedDialogButton {
    /**
     * The id for the button, unique within the control
     */
    id: string;
    /**
     * Display text of the button
     */
    text: string;
    /**
     * Handler for click event
     */
    click: () => void;
    /**
     * Indicates the button should be disabled until changes are made in the dialog
     */
    enableOnDirty?: boolean;
    /**
     * Indicates the button is currently disabled
     */
    disabled?: string;
}
/**
 * The TabbedDialog options
 */
export interface TabbedDialogOptions extends Dialogs.IModalDialogOptions {
    /**
     * Id for the TabControl
     */
    tabControlId: string;
    /**
     * Id of the default tab selected when the dialog opens
     */
    defaultTabId?: string;
    /**
     * List of tab groups on the dialog
     */
    groups?: ITabGroup[];
    /**
     * Optional: custom button set to override the default
     */
    customButtons?: ITabbedDialogButton[];
    /**
     * Indicates whether the dialog should prompt the user to save changes before closing
     */
    confirmUnsavedChanges?: boolean;
    /**
     * Indicates whether the dialog should display the tabs on the side. Defaults to false.
     */
    hideTabsPane?: boolean;
}
/**
 * Modal dialog which implements TabContent
 */
export class TabbedDialog extends Dialogs.ModalDialogO<TabbedDialogOptions> {
    private _control;
    private static ON_RESIZE_THROTTLE_TIME;
    private _resizeThrottleDelegate;
    private _groups;
    constructor(options?: any);
    initializeOptions(options?: any): void;
    initialize(): void;
    private _registerTabGroup;
    private _registerTab;
    private _refreshButton;
    private _getButtons;
    private _getDefaultButtons;
    /**
     * Updates button's status
     * @param button The button Id
     * @param enabled True if the button needs to be enabled
     */
    private _updateButton;
    beforeClose(e?: any, ui?: any): boolean;
    private _evaluateOnCloseStrategy;
    onOkClick(e?: JQueryEventObject): void;
    onCancelClick(e?: JQueryEventObject): void;
    dispose(): void;
}
}
declare module "VSS/Controls/TreeView" {
/// <amd-dependency path="jQueryUI/droppable" />
/// <amd-dependency path="VSS/Utils/Draggable" />
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
/// <reference types="jquery" />
/// <reference types="jqueryui" />
/// <reference types="highcharts" />
import Combos = require("VSS/Controls/Combos");
import Controls = require("VSS/Controls");
export class TreeDataSource extends Controls.BaseDataSource {
    root: any;
    constructor(options?: any);
    setSource(source: any): void;
    /**
     * @param source
     */
    prepareSource(source?: any): void;
    /**
     * Update the flat content representation from the current tree
     */
    updateItemsFromSource(): void;
    /**
     * @param all
     * @param textOnly
     * @return
     */
    getItemText(index: any, all?: any, textOnly?: any): string;
    /**
     * @param startsWith
     * @param all
     */
    getItemIndex(itemText: any, startsWith?: any, all?: any): any;
    expandNode(node: any): void;
    collapseNode(node: any): void;
    _initRoot(): void;
    private _prepareCurrentItems;
}
/**
 * @publicapi
 */
export interface ITreeOptions {
    /**
     * List of nodes used by TreeView for rendering. TreeView only accepts nodes of concrete type TreeNode. Existing node hierarchy needs to be converted to TreeNode before providing to TreeView, see samples for details.
     */
    nodes?: TreeNode[];
    /**
     * Determines whether icons of the nodes are visible or not.
     * @defaultvalue true
     */
    showIcons?: boolean;
    /**
    * Optional custom icon render, overriding node's icon
    * @defaultvalue undefined
    */
    onRenderIcon?: (node: TreeNode) => Element;
    /**
     * Determines whether clicking a node expands/collapses the node or not (if the node has children).
     * @defaultvalue false
     */
    clickToggles?: boolean;
    /**
     * Determines whether clicking a node selects the node or not.
     * @defaultvalue true
     */
    clickSelects?: boolean;
    contextMenu?: any;
    useEmptyFolderNodes?: boolean;
    defaultEmptyFolderNodeText?: string;
    styleFocusElement?: boolean;
    /**
     * Defines "droppable" options for drag and drop (see jQuery UI droppable options)
     */
    droppable?: any;
    /**
     * Defines "draggable" options for drag and drop (see jQuery UI draggable options)
     */
    draggable?: any;
    /**
     * Specifies whether to use the modern bowtie styling (bowtie styles are in preview and subject to change).
     * @defaultvalue false
     */
    useBowtieStyle?: boolean;
    /**
     * Determine use arrow keys or TAB for navigation between tree nodes, in arrow keys mode only one node will have tabIndex at one time.
     * @defaultvalue false
     */
    useArrowKeysForNavigation?: boolean;
    /**
     * Determine if always set title or only set title on overflow
     * @defaultvalue false
     */
    setTitleOnlyOnOverflow?: boolean;
    /**
    * Callback that will be called when a folder is toggled
    * @defaultvalue undefined
    */
    onItemToggle?: (node: TreeNode) => void;
}
/**
 * @publicapi
 */
export class TreeNode {
    /**
     * @param text
     * @param config
     * @param children
     * @return
     */
    static create(text: string, config?: any, children?: TreeNode[]): TreeNode;
    id: any;
    root: boolean;
    text: string;
    parent: TreeNode;
    children: TreeNode[];
    config: any;
    expanded: boolean;
    selected: boolean;
    icon: any;
    tag: any;
    noFocus: boolean;
    noContextMenu: boolean;
    noTreeIcon: boolean;
    folder: any;
    type: any;
    link: string;
    title: string;
    droppable: any;
    iterationPath: string;
    definition: any;
    linkDelegate: any;
    hasExpanded: boolean;
    owner: any;
    application: any;
    emptyFolderNodeText: string;
    isEmptyFolderChildNode: boolean;
    isSearchHit: boolean;
    /**
     * @param text
     * @param config
     * @param children
     * @param id
     */
    constructor(text: string, config?: any, children?: TreeNode[], id?: string);
    hasChildren(): boolean;
    clear(): void;
    remove(): void;
    add(node: TreeNode): void;
    /**
     *  Move this node to reside under the specified new parent.
     *
     * @param newParent The destination to reparent the source under.
     */
    moveTo(newParent: any): void;
    addRange(nodes: any): void;
    /**
     * Finds a node using the given path
     *
     * @param path Path to find
     * @param sepChar Path separator, if not given default will be used
     * @param comparer Comparer used to compare nodes in the path, if not given default will be used
     */
    findNode(path: string, sepChar?: string, comparer?: (a: string, b: string) => number): TreeNode;
    sort(recursive: any, treeNodeComparer: any): void;
    path(includeRoot: any, sepChar: any): any;
    level(noRoot: any): number;
    getContributionContext(): TreeNode;
    getHtmlId(): string;
    private _ensureNodeId;
    private _sort;
}
/**
 * @publicapi
 */
export class TreeViewO<TOptions extends ITreeOptions> extends Controls.Control<TOptions> {
    static _typeName: string;
    static NODE_DATA_NAME: string;
    static LEVEL_DATA_NAME: string;
    static EXPANDED_CLASS: string;
    static COLLAPSED_CLASS: string;
    private static NODE_VISIBLE_AND_FOCUSABLE;
    private _focusDelegate;
    private _blurDelegate;
    private _dragStartDelegate;
    private _hasFocus;
    private _draggable;
    private _droppable;
    _focusedNode: JQuery;
    private _popupMenu;
    private _nodeHasTabindex;
    private _ariaDescribedById;
    rootNode: TreeNode;
    _selectedNode: TreeNode;
    /**
     * Creates new Grid Control
     */
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    _draw(): void;
    /**
     * Gets the DOM element associated with the specified node

     * @param node Node associated with the seeked DOM element
     * @returns {JQuery}
     */
    _getNodeElement(node: TreeNode): JQuery;
    /**
     * Gets the node associated with the element
     *
     * @param $element The jQuery object wrapping the tree node's DOM element
     * @returns {TreeNode}
     */
    _getNode($element: JQuery): TreeNode;
    /**
     * Gets the currently selected node.
     *
     * @returns {TreeNode}
     * @publicapi
     */
    getSelectedNode(): TreeNode;
    /**
     * Sets the specified node as selected.
     
     * @param node Node to be selected.
     * @param suppressChangeEvent If specified true, "selectionChanged" event will not fire.
     * @publicapi
     */
    setSelectedNode(node: TreeNode, suppressChangeEvent?: boolean): void;
    focus(): void;
    _expandNodeParents(node: any, suppressChangeEvent?: boolean): void;
    _updateSelections(): void;
    _updateNode(li: JQuery, node: TreeNode, level: number): any;
    /**
     * @param level
     */
    _drawChildren(node: TreeNode, nodeElement: any, level?: number): void;
    /**
     * @return
     */
    _toggle(node: TreeNode, nodeElement: any, suppressChangeEvent?: boolean): any;
    /**
     * Ensure the tree node's expansion state is set to a particular value
     *
     * @param node The tree node
     * @param nodeElement The element associated with the node
     * @param expand The desired expand state of the node - true = expanded, false = collapsed
     * @return true = the node's expansion state was changed, false otherwise
     */
    _setNodeExpansion(node: TreeNode, nodeElement: JQuery, expand: boolean): boolean;
    /**
     * Removes the specified node from the tree.
     *
     * @param node Node to be removed.
     * @publicapi
     */
    removeNode(node: TreeNode): void;
    /**
     * Update the specified node by refreshing the child nodes if anything is added or removed.
     *
     * @param node Node to be updated.
     * @param suppressFocus suppress focusing on the node
     * @publicapi
     */
    updateNode(node: TreeNode, suppressFocus?: boolean): void;
    /**
     * @param e
     * @return
     */
    onItemClick(node: TreeNode, nodeElement: any, e?: JQueryEventObject): any;
    onShowPopupMenu(node: TreeNode, options?: any): void;
    /**
     * Indicate whether the element that has focus should be styled differently.
     * The current focus element will be updated to match the new preference
     *
     * @param enabled true, if focus element should be styled.
     */
    enableFocusStyling(enabled: boolean): void;
    _setFocusElement(element: JQuery): void;
    /**
     * Gets the node associated with the provided DOM/JQuery element.
     *
     * @param element Element to get the node for.
     * @return  {TreeNode}
     * @publicapi
     */
    getNodeFromElement(element: any): TreeNode;
    private _drawNode;
    private _drawEmptyFolderNode;
    /**
     * @param e
     * @return
     */
    private _click;
    /**
     * Set UI Focus on the node (Does not change selected node state)
     * @param node Tree node to navigate to
     */
    focusOnNode(node: TreeNode): void;
    /**
     * Handle key down events (node selection & expansion)
     *
     * @param e
     * @return
     */
    _onInputKeyDown(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    private _onToggle;
    /**
     * @param e
     * @return
     */
    private _itemClick;
    /**
     * @param e
     * @return
     */
    private _onContextMenu;
    private _showPopupMenu;
    /**
     * @param e
     * @return
     */
    private _onFocus;
    /**
     * @param e
     * @return
     */
    _onBlur(e?: JQueryEventObject): any;
    _clearFocusOnElement(): void;
    /**
     * Suppress browser default drag behavior associated with the supplied element to prevent conflicting behavior (text selection/HTML5 default DnD) with JQuery Drag Drop.
     *
     * @param e
     * @return
     */
    private _onDragStart;
    /**
     * Set the droppable
     *
     * @param droppable
     */
    setDroppable(droppable: any): void;
    private _getFirstTabbableChild;
    private _setNodeElementExpandState;
    private _restoreTabindexAndFocus;
    private _setNodeHasTabindex;
}
export class TreeView extends TreeViewO<ITreeOptions> {
}
export class ComboTreeDropPopup extends Combos.ComboListDropPopup {
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    expandNode(): boolean;
    collapseNode(): boolean;
    _createItem(index: any): JQuery;
    _onItemClick(e?: any, itemIndex?: any, $target?: any, $li?: any): boolean;
    _getSelectedNode(): any;
}
export class ComboTreeBehavior extends Combos.ComboListBehavior {
    constructor(combo: any, options?: any);
    canType(): boolean;
    /**
     * @param e
     * @return
     */
    leftKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    rightKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyUp(e?: JQueryEventObject): any;
    _createDataSource(): Controls.BaseDataSource;
}
export var ComboTreeBehaviorName: string;
export class MultiSelectTreeComboDropPopup extends Combos.ComboListDropPopup {
    /**
     * @param options
     */
    private _checkStates;
    constructor(options?: any);
    initializeOptions(options?: any): void;
    initialize(): void;
    expandNode(): boolean;
    collapseNode(): boolean;
    getCheckedItems(): string[];
    getValue(): string;
    _createItem(itemIndex: any): JQuery;
    _onItemClick(e?: any, itemIndex?: any, $target?: any, $li?: any): boolean;
    _getSelectedNode(): any;
    toggleCheckbox(selectedIndex: any): void;
    update(): void;
    private _updateCheckList;
    private _clearCheckList;
    private _fireDropPopupChange;
}
export class MultiSelectTreeComboBehavior extends Combos.ComboListBehavior {
    constructor(combo: any, options?: any);
    canType(): boolean;
    getDropOptions(): any;
    /**
     * @param e
     * @return
     */
    leftKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    rightKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyUp(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    upKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    downKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyDown(e?: JQueryEventObject): any;
    _createDataSource(): Controls.BaseDataSource;
    private _onChange;
    setSource(source: any[] | Function): void;
}
export var ComboTreeMultivalueBehaviorName: string;
export class SearchComboTreeBehavior extends Combos.ComboListBehavior {
    private hitText;
    private selectedHitIndex;
    private originalNodes;
    private lastSearchText;
    private searchDebounceTimeout;
    private debounceWaitTime;
    private textHasChanged;
    constructor(combo: any, options?: any);
    initialize(): void;
    canType(): boolean;
    getAriaAutocomplete(): string;
    /**
     * Get additional text to use to label the control for screen reader users.
     */
    getAriaDescription(): string;
    /**
     * @param e
     * @return
     */
    leftKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    rightKey(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyDown(e?: JQueryEventObject): any;
    /**
     * @param e
     * @return
     */
    keyUp(e?: JQueryEventObject): any;
    _createDataSource(): Controls.BaseDataSource;
    private mouseUp;
    private clearSearchDebounce;
    private debounceSearch;
    private isComboTextPath;
    private searchNodes;
    private _ensureOriginalNodesStored;
    private getNodesToSearch;
    private createCopyOfSubtreeWhichMatchesSearch;
    private stringContains;
    private modifyDatasourceAndDropdownWithResults;
    private expandAncestors;
    private performSearchHitProcessing;
    private copyNodeToArray;
    private copyNodeAndAncestorsToArray;
    private copyDecendantsToArray;
    private setHit;
    private acceptSelectedIndex;
}
export var SearchComboTreeBehaviorName: string;
export function flatten(node: any, items: any, all: any): void;
}
declare module "VSS/Controls/Validation" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
export interface BaseValidatorOptions {
    bindtokeystrokes?: boolean;
    invalidCssClass?: string;
    message?: string | (() => string);
    group?: string;
    allowEmptyString?: boolean;
    testEmptyString?: boolean;
}
export class BaseValidator<TOptions extends BaseValidatorOptions> extends Controls.Enhancement<TOptions> {
    static optionsPrefix: string;
    static EVENT_VALIDATE: string;
    static EVENT_VALIDATE_STATUS: string;
    instanceId: any;
    private _onValidationRequiredDelegate;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    initialize(): void;
    dispose(): void;
    getValue(): any;
    /**
     * @return
     */
    isValid(): boolean;
    getValidationGroup(): string;
    getMessage(): string | (() => string);
    onKeyUp(): void;
    onChanged(): void;
    onValidationRequired(e?: any, group?: any): void;
    validate(): void;
    private _testEmptyString;
}
export class RequiredValidator<TOptions extends BaseValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    isValid(): boolean;
}
export class RangeValidator<TOptions extends BaseValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    isValid(): boolean;
    getMessage(): string;
}
export interface RegexValidatorOptions extends BaseValidatorOptions {
    regex?: string | RegExp;
}
export class RegexValidator<TOptions extends RegexValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    isValid(): boolean;
    getMessage(): any;
}
export interface CustomValidatorOptions extends BaseValidatorOptions {
    validate?: (val: any) => boolean;
}
export class CustomValidator<TOptions extends CustomValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     *     A validator which checks the text in the input by passing it to a function,
     *     which then returns true if the input is valid, and false if it is invalid.
     *
     * @param options  Options to apply to the validator:
     *     message: A message logged by the validation summary if the input is invalid / string
     *     testEmptyString: A boolean which indicates whether or not to test the empty string / boolean
     *     validate: The function to validate the input against
     *
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    /**
     * Tests if the current input satisfies the function
     *
     * @return True if the input does satisfy, false if it does not
     */
    isValid(): boolean;
    /**
     *  Set the function the validator tests
     *
     * @param newFxn  The new function to test against
     */
    setValidate(newValidateFunction: any): void;
    /**
     *  Gets the message that would be logged in the validation summary if the input were to be invalid
     *
     * @return  The message
     */
    getMessage(): string;
}
export interface DateValidatorOptions extends BaseValidatorOptions {
    parseFormat?: string;
}
export class DateValidator<TOptions extends DateValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    isValid(): boolean;
    getMessage(): any;
}
export interface IntegerRangeValidatorOptions extends BaseValidatorOptions {
    minValue?: number;
    maxValue?: number;
}
export class IntegerRangeValidator<TOptions extends IntegerRangeValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     *     A validator that ensures only whole integers between an upper and lower limit are entered.
     *
     * @param options  Options to apply to the validator:
     *     minValue: The minimum value (inclusive)
     *     maxValue: The maximum value (inclusive)
     *
     */
    constructor(options?: TOptions);
    /**
     * OVERRIDE: Determines whether the input control bound to this validator contains valid input
     *
     * @return True if valid, false otherwise
     */
    isValid(): boolean;
    isWithinBounds(value: string, max: number, min: number): boolean;
    /**
     * OVERRIDE: Gets the error message for display purposes
     *
     * @return The error message
     */
    getMessage(): string;
    /**
     * Gets the min and max boundaries of the validator
     *
     * @return {min, max}
     */
    private _getBounds;
}
export interface MaxLengthValidatorOptions extends BaseValidatorOptions {
    maxLength?: number;
}
export class MaxLengthValidator<TOptions extends MaxLengthValidatorOptions> extends BaseValidator<TOptions> {
    static optionsPrefix: string;
    /**
     * @param options
     */
    constructor(options?: TOptions);
    /**
     * @param options
     */
    initializeOptions(options?: TOptions): void;
    /**
     * @return
     */
    isValid(): boolean;
}
export interface ValidationSummaryOptions {
    context: Node;
    group: string;
}
export class ValidationSummary extends Controls.Control<ValidationSummaryOptions> {
    private _messages;
    private _ignoreUIUpdate;
    private _fixedHeight;
    private _singleMessage;
    private _showAsWarning;
    /**
     * @param options
     */
    constructor(options?: any);
    /**
     * @param options
     */
    initializeOptions(options?: ValidationSummaryOptions): void;
    initialize(): void;
    onValidationStatus(e?: any, validator?: any, group?: any, valid?: any): void;
    validate(): void;
    private _updateUI;
}
/**
 * @param validationResult
 * @param context
 * @return
 */
export function validateGroup(group: any, validationResult?: any[], context?: any): boolean;
}
declare module "VSS/Controls/Virtualization" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!VSS.Controls" />
import Controls = require("VSS/Controls");
export class VirtualizingListView extends Controls.BaseControl {
    protected _itemsContainer: JQuery;
    private _scrollContainer;
    private _scrollSpacer;
    protected _dataSource: Controls.BaseDataSource;
    protected _firstVisible: number;
    private _selectedIndex;
    private _rowHeight;
    private _ignoreScrollEvent;
    protected _enableMouseOver: boolean;
    private _prevMousePos;
    visibleRowCount: number;
    /**
     * Y position of the pointer when the pointerDown event was fired. Set to null when the pointer is not down.
     */
    private _pointerDownY;
    /**
     * The value of this._firstVisible when the pointerDown event was fired.
     */
    private _pointerDownFirstVisible;
    /**
     * @param options
     */
    initializeOptions(options?: any): void;
    initialize(): void;
    update(): void;
    scrollItemIntoView(index: any): void;
    /**
     * @param page
     * @return
     */
    selectNext(page?: boolean): boolean;
    /**
     * @param page
     * @return
     */
    selectPrev(page?: boolean): boolean;
    getSelectedIndex(): number;
    getSelectedItem(): JQuery;
    /**
     * @param noScrollIntoView
     */
    setSelectedIndex(selectedIndex: number, noScrollIntoView?: boolean): void;
    private _setVisibleBounds;
    protected _createItem(index: number): JQuery;
    protected _drawItems(): void;
    protected _updateItemStyles(): void;
    protected _updateAriaAttributes(): void;
    private _setupScrollbar;
    private _updateScrollbar;
    private _onScroll;
    private _onMouseMove;
    private _onMouseOver;
    private _onPointerDown;
    private _onPointerLeave;
    private _onPointerMove;
    private _onMouseWheel;
    private _onClick;
    /**
     * Optional delegate. Selected index will be representative of dataSource._items
     * @param accept
     */
    private _fireSelectionChanged;
    /**
     * Optional delegate. This is fired when items in the list are updated.
     */
    private _fireItemsUpdated;
}
}
declare module "VSS/DelegatedAuthorization/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
export interface AccessTokenResult {
    accessToken: VSS_Common_Contracts.JsonWebToken;
    accessTokenError: TokenError;
    authorizationId: string;
    errorDescription: string;
    hasError: boolean;
    refreshToken: RefreshTokenGrant;
    tokenType: string;
    validTo: Date;
}
export interface Authorization {
    accessIssued: Date;
    audience: string;
    authorizationId: string;
    identityId: string;
    isAccessUsed: boolean;
    isValid: boolean;
    redirectUri: string;
    registrationId: string;
    scopes: string;
    source: string;
    validFrom: Date;
    validTo: Date;
}
export interface AuthorizationDecision {
    authorization: Authorization;
    authorizationError: AuthorizationError;
    authorizationGrant: AuthorizationGrant;
    hasError: boolean;
    isAuthorized: boolean;
}
export interface AuthorizationDescription {
    clientRegistration: Registration;
    hasError: boolean;
    initiationError: InitiationError;
    scopeDescriptions: AuthorizationScopeDescription[];
}
export interface AuthorizationDetails {
    authorization: Authorization;
    clientRegistration: Registration;
    scopeDescriptions: AuthorizationScopeDescription[];
}
export enum AuthorizationError {
    None = 0,
    ClientIdRequired = 1,
    InvalidClientId = 2,
    ResponseTypeRequired = 3,
    ResponseTypeNotSupported = 4,
    ScopeRequired = 5,
    InvalidScope = 6,
    RedirectUriRequired = 7,
    InsecureRedirectUri = 8,
    InvalidRedirectUri = 9,
    InvalidUserId = 10,
    InvalidUserType = 11,
    AccessDenied = 12
}
export interface AuthorizationGrant {
    grantType: GrantType;
}
export interface AuthorizationScopeDescription {
    description: string;
    market: string;
    title: string;
}
export enum ClientType {
    Confidential = 0,
    Public = 1,
    MediumTrust = 2,
    HighTrust = 3,
    FullTrust = 4
}
export enum GrantType {
    None = 0,
    JwtBearer = 1,
    RefreshToken = 2,
    Implicit = 3,
    ClientCredentials = 4
}
export interface HostAuthorization {
    hostId: string;
    id: string;
    isValid: boolean;
    registrationId: string;
}
export interface HostAuthorizationDecision {
    hasError: boolean;
    hostAuthorizationError: HostAuthorizationError;
    hostAuthorizationId: string;
}
export enum HostAuthorizationError {
    None = 0,
    ClientIdRequired = 1,
    AccessDenied = 2,
    FailedToAuthorizeHost = 3,
    ClientIdNotFound = 4,
    InvalidClientId = 5
}
export enum InitiationError {
    None = 0,
    ClientIdRequired = 1,
    InvalidClientId = 2,
    ResponseTypeRequired = 3,
    ResponseTypeNotSupported = 4,
    ScopeRequired = 5,
    InvalidScope = 6,
    RedirectUriRequired = 7,
    InsecureRedirectUri = 8,
    InvalidRedirectUri = 9
}
export interface RefreshTokenGrant extends AuthorizationGrant {
    jwt: VSS_Common_Contracts.JsonWebToken;
}
export interface Registration {
    clientType: ClientType;
    identityId: string;
    issuer: string;
    isValid: boolean;
    isWellKnown: boolean;
    organizationLocation: string;
    organizationName: string;
    /**
     * Raw cert data string from public key. This will be used for authenticating medium trust clients.
     */
    publicKey: string;
    redirectUris: string[];
    registrationDescription: string;
    registrationId: string;
    registrationLocation: string;
    registrationLogoSecureLocation: string;
    registrationName: string;
    registrationPrivacyStatementLocation: string;
    registrationTermsOfServiceLocation: string;
    responseTypes: string;
    scopes: string;
    secret: string;
    secretValidTo: Date;
    secretVersionId: string;
    validFrom: Date;
}
export enum ResponseType {
    None = 0,
    Assertion = 1,
    IdToken = 2,
    TenantPicker = 3,
    SignoutToken = 4,
    AppToken = 5,
    Code = 6
}
export enum TokenError {
    None = 0,
    GrantTypeRequired = 1,
    AuthorizationGrantRequired = 2,
    ClientSecretRequired = 3,
    RedirectUriRequired = 4,
    InvalidAuthorizationGrant = 5,
    InvalidAuthorizationScopes = 6,
    InvalidRefreshToken = 7,
    AuthorizationNotFound = 8,
    AuthorizationGrantExpired = 9,
    AccessAlreadyIssued = 10,
    InvalidRedirectUri = 11,
    AccessTokenNotFound = 12,
    InvalidAccessToken = 13,
    AccessTokenAlreadyRefreshed = 14,
    InvalidClientSecret = 15,
    ClientSecretExpired = 16,
    ServerError = 17,
    AccessDenied = 18,
    AccessTokenKeyRequired = 19,
    InvalidAccessTokenKey = 20,
    FailedToGetAccessToken = 21,
    InvalidClientId = 22,
    InvalidClient = 23,
    InvalidValidTo = 24,
    InvalidUserId = 25,
    FailedToIssueAccessToken = 26,
    AuthorizationGrantScopeMissing = 27,
    InvalidPublicAccessTokenKey = 28,
    InvalidPublicAccessToken = 29,
    PublicFeatureFlagNotEnabled = 30,
    SSHPolicyDisabled = 31
}
export var TypeInfo: {
    AccessTokenResult: any;
    Authorization: any;
    AuthorizationDecision: any;
    AuthorizationDescription: any;
    AuthorizationDetails: any;
    AuthorizationError: {
        enumValues: {
            "none": number;
            "clientIdRequired": number;
            "invalidClientId": number;
            "responseTypeRequired": number;
            "responseTypeNotSupported": number;
            "scopeRequired": number;
            "invalidScope": number;
            "redirectUriRequired": number;
            "insecureRedirectUri": number;
            "invalidRedirectUri": number;
            "invalidUserId": number;
            "invalidUserType": number;
            "accessDenied": number;
        };
    };
    AuthorizationGrant: any;
    ClientType: {
        enumValues: {
            "confidential": number;
            "public": number;
            "mediumTrust": number;
            "highTrust": number;
            "fullTrust": number;
        };
    };
    GrantType: {
        enumValues: {
            "none": number;
            "jwtBearer": number;
            "refreshToken": number;
            "implicit": number;
            "clientCredentials": number;
        };
    };
    HostAuthorizationDecision: any;
    HostAuthorizationError: {
        enumValues: {
            "none": number;
            "clientIdRequired": number;
            "accessDenied": number;
            "failedToAuthorizeHost": number;
            "clientIdNotFound": number;
            "invalidClientId": number;
        };
    };
    InitiationError: {
        enumValues: {
            "none": number;
            "clientIdRequired": number;
            "invalidClientId": number;
            "responseTypeRequired": number;
            "responseTypeNotSupported": number;
            "scopeRequired": number;
            "invalidScope": number;
            "redirectUriRequired": number;
            "insecureRedirectUri": number;
            "invalidRedirectUri": number;
        };
    };
    RefreshTokenGrant: any;
    Registration: any;
    ResponseType: {
        enumValues: {
            "none": number;
            "assertion": number;
            "idToken": number;
            "tenantPicker": number;
            "signoutToken": number;
            "appToken": number;
            "code": number;
        };
    };
    TokenError: {
        enumValues: {
            "none": number;
            "grantTypeRequired": number;
            "authorizationGrantRequired": number;
            "clientSecretRequired": number;
            "redirectUriRequired": number;
            "invalidAuthorizationGrant": number;
            "invalidAuthorizationScopes": number;
            "invalidRefreshToken": number;
            "authorizationNotFound": number;
            "authorizationGrantExpired": number;
            "accessAlreadyIssued": number;
            "invalidRedirectUri": number;
            "accessTokenNotFound": number;
            "invalidAccessToken": number;
            "accessTokenAlreadyRefreshed": number;
            "invalidClientSecret": number;
            "clientSecretExpired": number;
            "serverError": number;
            "accessDenied": number;
            "accessTokenKeyRequired": number;
            "invalidAccessTokenKey": number;
            "failedToGetAccessToken": number;
            "invalidClientId": number;
            "invalidClient": number;
            "invalidValidTo": number;
            "invalidUserId": number;
            "failedToIssueAccessToken": number;
            "authorizationGrantScopeMissing": number;
            "invalidPublicAccessTokenKey": number;
            "invalidPublicAccessToken": number;
            "publicFeatureFlagNotEnabled": number;
            "sSHPolicyDisabled": number;
        };
    };
};
}
declare module "VSS/DelegatedAuthorization/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/DelegatedAuthorization/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected authorizationsApiVersion: string;
    protected hostAuthorizationApiVersion: string;
    protected registrationApiVersion: string;
    protected registrationSecretApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} registrationId
     * @return IPromise<VSS_Common_Contracts.JsonWebToken>
     */
    getSecret(registrationId: string): IPromise<VSS_Common_Contracts.JsonWebToken>;
    /**
     * @param {Contracts.Registration} registration
     * @param {boolean} includeSecret
     * @return IPromise<Contracts.Registration>
     */
    updateRegistration(registration: Contracts.Registration, includeSecret?: boolean): IPromise<Contracts.Registration>;
    /**
     * @return IPromise<Contracts.Registration[]>
     */
    getRegistrations(): IPromise<Contracts.Registration[]>;
    /**
     * @param {string} registrationId
     * @param {boolean} includeSecret
     * @return IPromise<Contracts.Registration>
     */
    getRegistration(registrationId: string, includeSecret?: boolean): IPromise<Contracts.Registration>;
    /**
     * @param {string} registrationId
     * @return IPromise<void>
     */
    deleteRegistration(registrationId: string): IPromise<void>;
    /**
     * @param {Contracts.Registration} registration
     * @param {boolean} includeSecret
     * @return IPromise<Contracts.Registration>
     */
    createRegistration(registration: Contracts.Registration, includeSecret?: boolean): IPromise<Contracts.Registration>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} clientId
     * @param {string} hostId
     * @return IPromise<void>
     */
    revokeHostAuthorization(clientId: string, hostId?: string): IPromise<void>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} hostId
     * @return IPromise<Contracts.HostAuthorization[]>
     */
    getHostAuthorizations(hostId: string): IPromise<Contracts.HostAuthorization[]>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} clientId
     * @return IPromise<Contracts.HostAuthorizationDecision>
     */
    authorizeHost(clientId: string): IPromise<Contracts.HostAuthorizationDecision>;
    /**
     * @param {string} authorizationId
     * @param {string} userId
     * @return IPromise<void>
     */
    revokeAuthorization(authorizationId: string, userId?: string): IPromise<void>;
    /**
     * @param {Contracts.ResponseType} responseType
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {string} scopes
     * @param {string} userId
     * @return IPromise<Contracts.AuthorizationDescription>
     */
    initiateAuthorization(responseType: Contracts.ResponseType, clientId: string, redirectUri: string, scopes: string, userId?: string): IPromise<Contracts.AuthorizationDescription>;
    /**
     * @param {string} userId
     * @return IPromise<Contracts.AuthorizationDetails[]>
     */
    getAuthorizations(userId?: string): IPromise<Contracts.AuthorizationDetails[]>;
    /**
     * @param {Contracts.ResponseType} responseType
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {string} scopes
     * @param {string} userId
     * @return IPromise<Contracts.AuthorizationDecision>
     */
    authorize(responseType: Contracts.ResponseType, clientId: string, redirectUri: string, scopes: string, userId?: string): IPromise<Contracts.AuthorizationDecision>;
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class DelegatedAuthorizationHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class DelegatedAuthorizationHttpClient extends DelegatedAuthorizationHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return DelegatedAuthorizationHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): DelegatedAuthorizationHttpClient4_1;
}
declare module "VSS/DeviceTypeService" {
import Service = require("VSS/Service");
/**
 * This is a client side wrapper for server side data provider contribution, device-type-data.
 */
export class DeviceTypeService extends Service.VssService {
    /**
     * Return true if the current device is mobile. Return false otherwise.
     */
    isMobileDevice(): boolean;
    /**
     * Return true if the current device is tablet. Return false otherwise.
     */
    isTabletDevice(): boolean;
    /**
     * Return true if the current device is mobile and not tablet. Return false otherwise.
     */
    isMobile(): boolean;
}
}
declare module "VSS/Diag" {
export var perfCollector: PerfTracePointCollector;
export var logLevel: number;
export function getDebugMode(): boolean;
export function setDebugMode(debugModeEnabled: boolean): void;
export enum StampEvent {
    SinglePoint = 0,
    Enter = 1,
    Leave = 2
}
export function timeStamp(label: string, event: StampEvent): void;
export class Measurement {
    private label;
    /**
     * Begin new measurement
     *
     * @param label Name of the measurement
     * @param callback Callback to end measurement
     */
    static start(label: string, callback: (measurement: Measurement) => void): void;
    constructor(label: string);
    /**
     * Ends this measurement
     */
    finish(): void;
}
export enum LogVerbosity {
    Off = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
    Verbose = 4
}
/**
 * Log a message to the debug output windows and all other trace listeners
 *
 * @param level A log verbosity value from VSS.Diag.logVerbosity
 * @param message Message to send to all trace listeners
 */
export function log(level: number, message: string): void;
export function logError(message: string): void;
export function logWarning(message: string): void;
export function logInfo(message: string): void;
export function logVerbose(message: string): void;
/**
 * Add a listener to listen for logged messages
 *
 * @param callback A callback method that gets called whenever something is logged
 */
export function listen(callback: IResultCallback): void;
/**
 * Remove a log message listener
 *
 * @param callback Listener to remove
 */
export function unlisten(callback: IResultCallback): void;
/**
 * Updates the start/end trace points used when creating a profile.
 *
 * @param startTracePointName The trace point to begin the profile.
 * @param endTracePointName The trace point that will ned the profile.
 */
export function profile(startTracePointName: string, endTracePointName: string): void;
/**
 * Explicitly end the profile.
 */
export function profileEnd(): void;
/**
 * Logs a trace point which can be consumed by a trace point collector for performance analysis.
 *
 * @param tracePointName Name of the trace point
 * @param data (Optional) Data corresponding to the event that occurred.
 */
export function logTracePoint(tracePointName: string, data?: any): void;
/**
 * Add a collector to handle trace points
 *
 * @param collector Method(tracePointName, data) called when trace points are logged.
 */
export function addTracePointCollector(collector: Function): void;
/**
 * Remove a trace point collector
 *
 * @param collector Collector to remove
 */
export function removeTracePointCollector(collector: Function): void;
/**
 * Sets the minimum level at which logged statements get captured and reported to the browser console.
 *
 * @param level Level which gets logged to the console
 */
export function setLogLevel(level: number): void;
export interface ITracePoint {
    name: string;
    time: number;
    data: any;
}
export class PerfTracePointCollector {
    private _tracePoints;
    private _overallCounts;
    private _activeCounts;
    private _moduleInitTime;
    private _lastResetTime;
    private _lastResetIndex;
    constructor();
    register(): void;
    getOverallCount(tracePointName: string): number;
    getActiveCount(tracePointName: string): number;
    getLastTracePoint(tracePointName: string): ITracePoint;
    getLastTracePointTime(tracePointName: string): number;
    resetActiveCount(tracePointName: string): void;
    resetActiveCounts(): void;
    getModuleInitTime(): number;
    getTracePoints(activeOnly: boolean): ITracePoint[];
    getTracePointCountData(tracePointNames: string[]): string;
    dumpTracePoints(activeOnly: boolean): string;
    private _updateCount;
    private _handleTracePoint;
}
export function measurePerformance(action: Function, message: string, logLevel?: LogVerbosity): void;
/**
* Any function calls to any members of this class will be stripped out in minified version, see WebPlatform.targets file AjaxMin task call with -debug switch.
* NOTE: You must use Diag or VSS_Diag as alias for the import statment for it to work.
* e.g. import Diag = require("VSS/Diag")
* This will be useful as follows
* 1) We will not have overhead of extra function calls in release version specially in the functions that are called many-many times (e.g. event handlers/processors)
* 2) The size of minified version will not be bloated with the size of message strings and function names
* 3) While debugging will still have flexibility to see the logs depending on the Log level
*/
export class Debug {
    private static _noDebugPrompts;
    /**
     * Sets whether or not to display callers in the stack on assert failures.
     *
     * @param showCallers If true, display callers in the stack of assert failures.
     */
    static setDisplayCallers(showCallers: boolean): void;
    /**
     * Displays a message in the debugger's output window and breaks into the debugger
     *
     * @param message Message to display in the debugger's output window
     */
    static fail(message: string): void;
    /**
     * Checks for a condition, and if the condition is false, displays a message and prompts the user to break into the debuggeription
     *
     * @param condition true to continue to execute code; false to display message and break into the debugger
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assert(condition: boolean, message?: string): void;
    /**
     * Assert that the value is an object and not null.
     *
     * @param value Value to ensure is an object.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsObject(value: any, message?: string): void;
    /**
     * Assert that the value is an object and not null.
     *
     * @param value Value to ensure is an object.
     * @param paramName Name of the parameter that this value is associated with.
     * @param optional If true then the assert will accept falsy values
     */
    static assertParamIsObject(value: any, paramName: string, optional?: boolean): void;
    /**
     * Assert that the value is an array.
     *
     * @param value Value to ensure is an array.
     * @param message (Optional) The message to display. The default is an empty string
     * @param requireNotEmpty (Optional) If true the array will be checked to ensure it is not empty.
     */
    static assertIsArray(value: any, message?: string, requireNotEmpty?: boolean): void;
    /**
     * Assert that the value is an array.
     *
     * @param value Value to ensure is an array.
     * @param paramName (Optional) Name of the parameter that this value is associated with.
     * @param requireNotEmpty (Optional) If true the array will be checked to ensure it is not empty.
     */
    static assertParamIsArray(value: any, paramName?: string, requireNotEmpty?: boolean): void;
    /**
     * Assert that the value is a boolean.
     *
     * @param value Value to ensure is a boolean.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsBool(value: boolean, message?: string): void;
    /**
     * Assert that the value is a boolean.
     *
     * @param value Value to ensure is a boolean.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsBool(value: boolean, paramName: string): void;
    /**
     * Assert that the value is a number.
     *
     * @param value Value to ensure is a number.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsNumber(value: number, message?: string): void;
    /**
     * Assert that the value is a number.
     *
     * @param value Value to ensure is a number.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsNumber(value: number, paramName: string): void;
    /**
     * Assert that the value is an integer.
     *
     * @param value Value to ensure is an integer.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsInteger(value: number, message?: string): void;
    /**
     * Assert that the value is an integer.
     *
     * @param value Value to ensure is an integer.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsInteger(value: number, paramName: string): void;
    /**
     * Assert that the value is a string.
     *
     * @param value Value to ensure is a string.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsString(value: string, message?: string): void;
    /**
     * Assert that the value is a string.
     *
     * @param value Value to ensure is a string.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsString(value: string, paramName: string): void;
    /**
     * Assert that the value is a string and not empty.
     *
     * @param value Value to ensure is a string and not empty.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsStringNotEmpty(value: string, message?: string): void;
    /**
     * Assert that the value is a string and not empty.
     *
     * @param value Value to ensure is a string and not empty.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsStringNotEmpty(value: string, paramName: string): void;
    /**
     * Assert that the value is a function.
     *
     * @param value Value to ensure is a function.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsFunction(value: any, message?: string): void;
    /**
     * Assert that the value is a function.
     *
     * @param value Value to ensure is a function.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsFunction(value: any, paramName: string): void;
    /**
     * Assert that the value is a date.
     *
     * @param value Value to ensure is a date.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsDate(value: any, message?: string): void;
    /**
     * Assert that the value is a date.
     *
     * @param value Value to ensure is a date.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsDate(value: any, paramName: string): void;
    /**
     * Assert that the value is not null or undefined.
     *
     * @param value Value to ensure is not null or undefined.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsNotNull(value: any, message?: string): void;
    /**
     * Assert that the value is not null or undefined.
     *
     * @param value Value to ensure is not null or undefined.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsNotNull(value: any, paramName: string): void;
    /**
     * Assert that the value is not undefined.
     *
     * @param value Value to ensure is not undefined.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsNotUndefined(value: any, message?: string): void;
    /**
     * Assert that the value is undefined.
     *
     * @param value Value to ensure is not undefined.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsNotUndefined(value: any, paramName: string): void;
    /**
     * Assert that the value is a jQuery object.
     *
     * @param value Value to ensure is a jQuery object.
     * @param message (Optional) The message to display. The default is an empty string
     */
    static assertIsJQueryObject(value: any, message?: string): void;
    /**
     * Assert that the value is a jQuery object.
     *
     * @param value Value to ensure is a jQuery object.
     * @param paramName Name of the parameter that this value is associated with.
     */
    static assertParamIsJQueryObject(value: any, paramName: string): void;
    /**
     * Assert that the value is an instance of the expected type.
     *
     * @param value The value to test for the correct type
     * @param type Either the constructor function for a type,
     * or a string matching the return value of the typeof operator. This specified the type
     * to test for.
     * @param message The messge to display on Debug.failure.
     * @param optional Flag to determine whether null and undefined are accepted as values.
     */
    static assertIsType(value: any, type: any, message: string, optional?: boolean): void;
    /**
     * Gets the display name for a type.
     *
     * @param type The string value (from the typeof operator) or a constructor function.
     * @return
     */
    static getTypeName(type: any): string;
    /**
     * Assert that the parameter is an instance of the expected type.
     *
     * @param value The value to test for the correct type
     * @param type Either the constructor function for a type,
     * or a string matching the return value of the typeof operator. This specified the type
     * to test for.
     * @param paramName The name of the parameter.
     * @param optional Flag to determine whether null and undefined are accepted as values.
     */
    static assertParamIsType(value: any, type: any, paramName: string, optional?: boolean): void;
    static logInfo(message: string): void;
    static logVerbose(message: string): void;
}
}
declare module "VSS/Diag/Services" {
import Service = require("VSS/Service");
export interface Statistic {
    name: string;
    id: string;
    parentId?: string;
}
export interface ActivityStatistic extends Statistic {
    actionDate: string;
    status?: number;
}
export interface ActivtyStatsCollectionAllowedCallback {
    (): boolean;
}
export class ActivityStatsCollector implements Service.ILocalService {
    static ACTIVITY_COLLECTION_STATUS: string;
    static ACTIVITY_ID_STORAGE_ITEM: string;
    static CURRENT_PAGE: string;
    private _activtyIdHeader;
    private _progressPendingActions;
    private _progressPendingActionsNewId;
    private _activtyStatsCollectionAllowedCallbacks;
    /**
     * Global handler for logging activity data
     */
    constructor();
    initialize(): void;
    addActivtyStatsCollectionAllowedCallback(callback: ActivtyStatsCollectionAllowedCallback): void;
    actionStarted(name: string): number;
    actionCompleted(id: number, jqXHR: JQueryXHR): void;
    logActivity(activityId: string, page: string): void;
    getActivityStatistics(): ActivityStatistic[];
    clearStats(): void;
    collectStats(shouldCollect: boolean): void;
    getCurrentPage(): ActivityStatistic;
    setCurrentPage(currentPage: ActivityStatistic): void;
    isCollectingStats(): boolean;
    private _saveActivity;
    private _allowStatsCollection;
}
}
declare module "VSS/Error" {
import { Level } from "VSS/ClientTrace/Contracts";
/**
 * publish error to telemetry service
 */
export function publishErrorToTelemetry(error: TfsError, immediate?: boolean, level?: Level, additionalProperties?: IDictionaryStringTo<any>): void;
}
declare module "VSS/Events/Action" {
import Service = require("VSS/Service");
export interface IActionWorker {
    (actionArgs: any, next: (actionArgs: any) => any): any;
}
export class ActionService implements Service.ILocalService {
    static MaxOrder: any;
    private _actionWorkers;
    /**
     * Register a handler for an action. The handler participates in the Chain of Responsibility pattern.
     *
     * @param action The action to register
     * @param actionWorker Function(actionArgs, next), The handler to invoke for the given action when the performAction
     *     operation is called for the registered action.
     *     The function is passed the action arguments for next which it should call with the actionsArgs UNLESS
     *     it explicitly wants to be the end of the chain.
     *     e.g.
     *     registerActionWorker('some.action', function (actionArgs, next) {
     *         if (iCanHandle(actionArgs)) {
     *             return doProcessing(actionArgs);
     *         }
     *         else {
     *             return next(actionArgs);
     *         }
     *     }, 50);
     *
     * if ActionWorker functions are asynchronous they can still participate in the chain
     *
     *     registerActionWorker('some.async.action', function (actionArgs, next) {
     *         beginDoSomeStuff(function (result) {
     *             if (that.imDone(results)) {
     *                 actionArgs.onSuccess.call(this, results);
     *             }
     *             else {
     *                 next(actionArgs);
     *             }
     *         });
     *     }, 50);
     *
     * @param order The order of the action (default:100).
     *       Action workers are executed in increasing order. Order must be less than MaxOrder (inclusive)
     */
    registerActionWorker(action: string, actionWorker: IActionWorker, order?: number): void;
    /**
     * Un-Register a handler for an action.
     *
     * @param action The action to un-register
     * @param actionWorker Function(actionArgs, next), The IActionWorker that was registered.
     */
    unregisterActionWorker(action: string, actionWorker: IActionWorker): void;
    /**
     * Un-Register all handlers for an action.
     *
     * @param action The action to un-register
     */
    unregisterActionWorkers(action: string): void;
    /**
     * Invoke the registered action workers for the an action
     *
     * @param action The action identifier
     * @param actionArgs An object passed to the registered action workers.
     */
    performAction(action: string, actionArgs?: any): any;
    /**
     *  Clears all action workers
     */
    clearActionWorkers(): void;
    /**
     * Manage actions and the workers that are invoked when those actions are performed.
     * Action workers register to handle specific actions. They take whatever action they desire
     * and usually call the "next" handler in the chain (see the Chain of Responsibility pattern).
     */
    constructor();
}
export module CommonActions {
    var ACTION_WINDOW_OPEN: string;
    var ACTION_WINDOW_NAVIGATE: string;
    var ACTION_WINDOW_RELOAD: string;
    var ACTION_WINDOW_UNLOAD: string;
}
export function getService(): ActionService;
}
declare module "VSS/Events/Document" {
import Service = require("VSS/Service");
/**
 * Represents a document to a host.
 *  A host can be tha browser, an IDE (e.g. Eclipse, Visual Studio)
 */
export interface RunningDocument {
    /**
    * Method which returns true if the document is currently in a dirty-state which should block (prompt) attempts to navigate-away.
    */
    isDirty(): boolean;
    /**
    * (Optional) Callback method called before a save operation is performed on the document service
    */
    beginSave?: (successCallback: IResultCallback, errorCallback?: IErrorCallback) => void;
    /**
    * (Optional) Callback method called to get the titles of the currently dirty items.
    */
    getDirtyDocumentTitles?: (maxTitle?: number) => string[];
}
export interface RunningDocumentsTableEntry {
    document: RunningDocument;
    moniker: string;
}
export class RunningDocumentsTable implements Service.ILocalService {
    private _runningDocEntries;
    constructor();
    /**
     *   Add specified document to the running document table
     *   The document must have a method named isDirty that returns boolean
     *
     * @param moniker Name for this document type
     * @param document Object that will be called to determine state (e.g. dirty//modified)
     * @return A handle to the entry in the running document table. The handle can be used to remove the entry
     */
    add(moniker: string, document: RunningDocument): RunningDocumentsTableEntry;
    /**
     *   Remove an entry from the running document table
     *
     * @param entry The handle to the entry that will be removed. The handle is returned from the add function
     */
    remove(entry: RunningDocumentsTableEntry): void;
    /**
     *   Check if the specified document is modified.  If specified moniker is null or undefined
     *   will return true if any currently opened documents are modified
     *
     * @param moniker Name for this document type
     * @return True if the specified moniker\document is modified, false otherwise.
     *   Null or undefined moniker will return true if any opened documents are modified
     */
    isModified(moniker?: string): boolean;
    beginSave(callback: IResultCallback, errorCallback?: IErrorCallback): void;
    getUnsavedItemsMessage(): string;
    private _isAnyModified;
    private _registerUnloadEvent;
}
export interface Document {
    save(successCallback: IResultCallback, errorCallback?: IErrorCallback): void;
    getMoniker(): string;
}
/**
* Service for host environment to interact with documents in Web Access
*  A host environment can be tha browser, an IDE (e.g. Eclipse, Visual Studio)
*/
export class DocumentService implements Service.ILocalService {
    private _activeDocument;
    private _runningDocumentsTable;
    constructor();
    addDeleteListener(callBack: Function): void;
    removeDeleteListener(callBack: IEventHandler): void;
    addBuildPropertyChangedListener(callBack: IEventHandler): void;
    removeBuildPropertyChangedListener(callBack: IEventHandler): void;
    addBuildStoppedListener(callBack: IEventHandler): void;
    removeBuildStoppedListener(callBack: IEventHandler): void;
    addModifiedChangedListener(callBack: IEventHandler): void;
    removeModifiedChangedListener(callBack: IEventHandler): void;
    isModified(args?: string): boolean;
    save(successCallback: IResultCallback, errorCallback?: IErrorCallback): void;
    getActiveDocument(): Document;
    setActiveDocument(activeDocument: Document): void;
}
export function getService(): DocumentService;
export function getRunningDocumentsTable(): RunningDocumentsTable;
}
declare module "VSS/Events/Handlers" {
/**
* Represents a collection of named events that event listeners can attach to
*/
export class NamedEventCollection<TSender, TEventArgs> {
    private _namedHandlers;
    /**
    * Adds an event handler to the list of handlers for the given event
    *
    * @param eventName the name of the event to subscribe to
    * @param handler Event handler method to register
    */
    subscribe(eventName: string, handler: IFunctionPPR<TSender, TEventArgs, void>): void;
    /**
    * Removes an event handler from the list of handlers for the given event
    *
    * @param eventName The name of the event to unsubscribe to
    * @param handler Event handler method to remove
    */
    unsubscribe(eventName: string, handler: IFunctionPPR<TSender, TEventArgs, void>): void;
    /**
    * Invoke the handlers that have subscribed to this event
    *
    * @param eventName Name of the event whose handlers to invoke
    * @param sender The source that is triggering the event
    * @param eventArgs Event-specific arguments
    * @param handlerResultFilter Optional callback method to be able to break out of the handler invocation loop based on the return value of a handler. The filter should return true to break out of the loop.
    */
    invokeHandlers(eventName: string, sender?: TSender, eventArgs?: TEventArgs, handlerResultFilter?: (result: any) => boolean): void;
    /**
     * Unsubscribes all event handlers
     */
    unsubscribeAll(): void;
    /**
     * Returns true if there is at least one subscriber in this event collection.
     */
    hasSubscribers(): boolean;
    private _getOrCreateHandlerList;
}
/**
* Represents a specific event that event listeners can attach to
*/
export class Event<TSender, TEventArgs> {
    private _handlers;
    /**
    * The list of handlers for this event
    */
    getHandlers(): EventHandlerList<TSender, TEventArgs>;
    /**
    * Invoke the handlers that have subscribed to this event
    *
    * @param sender The source that is triggering the event
    * @param eventArgs Event-specific arguments
    * @param handlerResultFilter Optional callback method to be able to break out of the handler invocation loop based on the return value of a handler. The filter should return true to break out of the loop.
    */
    invokeHandlers(sender: TSender, eventArgs: TEventArgs, handlerResultFilter?: (result: any) => boolean): void;
}
/**
* A list of event handlers
*/
export class EventHandlerList<TSender, TEventArgs> {
    private _handlers;
    /**
    * Creates a new event handler list
    *
    * @param handlers Optional initial list of handlers
    */
    constructor(handlers?: IFunctionPPR<TSender, TEventArgs, any>[]);
    /**
    * Adds an event handler to the list
    *
    * @param handler Event handler method to register
    */
    subscribe(handler: IFunctionPPR<TSender, TEventArgs, any>): void;
    /**
    * Removes an event handler from the list
    *
    * @param handler Event handler method to remove
    */
    unsubscribe(handler: IFunctionPPR<TSender, TEventArgs, any>): void;
    /**
    * Get the underlying list of handlers
    */
    getHandlers(): IFunctionPPR<TSender, TEventArgs, any>[];
    /**
    * Invoke the subscribed event handlers
    *
    * @param sender The source that is triggering the event
    * @param eventArgs Event-specific arguments
    * @param handlerResultFilter Optional callback method to be able to break out of the handler invocation loop based on the return value of a handler. The filter should return true to break out of the loop.
    */
    invokeHandlers(sender?: TSender, eventArgs?: TEventArgs, handlerResultFilter?: (result: any) => boolean): void;
}
/**
* Command Event Arguments data structure that can be used for "command" events
*/
export class CommandEventArgs {
    private _commandName;
    private _commandArgument;
    private _commandSource;
    constructor(commandName: string, commandArgument?: any, commandSource?: any);
    /**
    * Get the name of the command
    */
    get_commandName(): string;
    /**
    * Get arguments to the command
    */
    get_commandArgument(): any;
    /**
    * Get the source that triggered the event
    */
    get_commandSource(): any;
}
}
declare module "VSS/Events/Page" {
export module CommonPageEvents {
    var PageInteractive: string;
    var InitialScriptsLoaded: string;
}
export interface IPageEventService {
    /**
     * Enables to subscribe a page event.
     * Specify '*' as eventName to subscribe all events.
     *
     * @param eventName Name of the page event to subscribe.
     * @param callback Callback to invoke when the event is fired.
     */
    subscribe(eventName: string, callback: IPageEventCallback): void;
    /**
     * Enables to unsubscribe from a page event.
     * Specify '*' as eventName to unsubscribe from all events.
     *
     * @param eventName Name of the page event to unsubscribe.
     * @param callback Callback to invoke when the event is fired.
     */
    unsubscribe(eventName: string, callback: IPageEventCallback): void;
    /**
     * Fires a page event.
     *
     * @param eventName Name of the page event to fire.
     * @param eventArgs Optional event arguments.
     */
    fire(eventName: string, eventArgs?: any): void;
    /**
     * Resets the specified event like it is not fired yet.
     */
    reset(eventName: string): void;
    /**
     * Clears all the subscriptions.
     */
    clear(): void;
}
export interface IPageEvent {
    /**
     * Name of the page event.
     */
    name: string;
    /**
     * Event arguments specified when the page event is fired.
     */
    args: any;
}
/**
 * Defines a page event callback.
 */
export interface IPageEventCallback {
    (event: IPageEvent): void;
}
/**
 * Gets the singleton instance of the page event service.
 */
export function getService(): IPageEventService;
}
declare module "VSS/Events/Services" {
import { ILocalService } from "VSS/Service";
export class EventService implements ILocalService {
    private _events;
    private _scopedEvents;
    fire(eventName: string, sender?: any, eventArgs?: any, scope?: string): boolean;
    /**
     * Attatch a handler to an event.
     *
     * @param eventName The event name.
     * @param handler The handler to attach.
     * @param scope The scope of the event.
     */
    attachEvent(eventName: string, handler: IEventHandler, scope?: string): void;
    /**
     * Detatch a handler from an event.
     *
     * @param eventName The event name.
     * @param handler The handler to detach.
     * @param scope The scope of the event.
     */
    detachEvent(eventName: string, handler: IEventHandler, scope?: string): void;
    disposeScope(scope: string): void;
    /**
     * Invoke the specified event passing the specified arguments.
     *
     * @param eventName The event to invoke.
     * @param sender The sender of the event.
     * @param args The arguments to pass through to the specified event.
     * @param scope The scope of the event.
     */
    private _fireEvent;
    private _getNamedEvents;
}
export function getService(): EventService;
}
declare module "VSS/ExtensionManagement/Contracts" {
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_Gallery_Contracts = require("VSS/Gallery/Contracts");
export interface AcquisitionOperation {
    /**
     * State of the the AcquisitionOperation for the current user
     */
    operationState: AcquisitionOperationState;
    /**
     * AcquisitionOperationType: install, request, buy, etc...
     */
    operationType: AcquisitionOperationType;
    /**
     * Optional reason to justify current state. Typically used with Disallow state.
     */
    reason: string;
}
export enum AcquisitionOperationState {
    /**
     * Not allowed to use this AcquisitionOperation
     */
    Disallow = 0,
    /**
     * Allowed to use this AcquisitionOperation
     */
    Allow = 1,
    /**
     * Operation has already been completed and is no longer available
     */
    Completed = 3
}
export enum AcquisitionOperationType {
    /**
     * Not yet used
     */
    Get = 0,
    /**
     * Install this extension into the host provided
     */
    Install = 1,
    /**
     * Buy licenses for this extension and install into the host provided
     */
    Buy = 2,
    /**
     * Not yet used
     */
    Try = 3,
    /**
     * Not yet used
     */
    Request = 4,
    /**
     * No action found
     */
    None = 5
}
/**
 * Market item acquisition options (install, buy, etc) for an installation target.
 */
export interface AcquisitionOptions {
    /**
     * Default Operation for the ItemId in this target
     */
    defaultOperation: AcquisitionOperation;
    /**
     * The item id that this options refer to
     */
    itemId: string;
    /**
     * Operations allowed for the ItemId in this target
     */
    operations: AcquisitionOperation[];
    /**
     * The target that this options refer to
     */
    target: string;
}
/**
 * An individual contribution made by an extension
 */
export interface Contribution extends ContributionBase {
    /**
     * List of constraints (filters) that should be applied to the availability of this contribution
     */
    constraints: ContributionConstraint[];
    /**
     * Includes is a set of contributions that should have this contribution included in their targets list.
     */
    includes: string[];
    /**
     * Properties/attributes of this contribution
     */
    properties: any;
    /**
     * The ids of the contribution(s) that this contribution targets. (parent contributions)
     */
    targets: string[];
    /**
     * Id of the Contribution Type
     */
    type: string;
}
/**
 * Base class shared by contributions and contribution types
 */
export interface ContributionBase {
    /**
     * Description of the contribution/type
     */
    description: string;
    /**
     * Fully qualified identifier of the contribution/type
     */
    id: string;
    /**
     * VisibleTo can be used to restrict whom can reference a given contribution/type. This value should be a list of publishers or extensions access is restricted too.  Examples: "ms" - Means only the "ms" publisher can reference this. "ms.vss-web" - Means only the "vss-web" extension from the "ms" publisher can reference this.
     */
    visibleTo: string[];
}
/**
 * Specifies a constraint that can be used to dynamically include/exclude a given contribution
 */
export interface ContributionConstraint {
    /**
     * An optional property that can be specified to group constraints together. All constraints within a group are AND'd together (all must be evaluate to True in order for the contribution to be included). Different groups of constraints are OR'd (only one group needs to evaluate to True for the contribution to be included).
     */
    group: number;
    /**
     * If true, negate the result of the filter (include the contribution if the applied filter returns false instead of true)
     */
    inverse: boolean;
    /**
     * Name of the IContributionFilter class
     */
    name: string;
    /**
     * Properties that are fed to the contribution filter class
     */
    properties: any;
}
/**
 * Description about a property of a contribution type
 */
export interface ContributionPropertyDescription {
    /**
     * Description of the property
     */
    description: string;
    /**
     * Name of the property
     */
    name: string;
    /**
     * True if this property is required
     */
    required: boolean;
    /**
     * The type of value used for this property
     */
    type: ContributionPropertyType;
}
export enum ContributionPropertyType {
    /**
     * Contribution type is unknown (value may be anything)
     */
    Unknown = 0,
    /**
     * Value is a string
     */
    String = 1,
    /**
     * Value is a Uri
     */
    Uri = 2,
    /**
     * Value is a GUID
     */
    Guid = 4,
    /**
     * Value is True or False
     */
    Boolean = 8,
    /**
     * Value is an integer
     */
    Integer = 16,
    /**
     * Value is a double
     */
    Double = 32,
    /**
     * Value is a DateTime object
     */
    DateTime = 64,
    /**
     * Value is a generic Dictionary/JObject/property bag
     */
    Dictionary = 128,
    /**
     * Value is an array
     */
    Array = 256,
    /**
     * Value is an arbitrary/custom object
     */
    Object = 512
}
/**
 * A contribution type, given by a json schema
 */
export interface ContributionType extends ContributionBase {
    /**
     * Controls whether or not contributions of this type have the type indexed for queries. This allows clients to find all extensions that have a contribution of this type.  NOTE: Only TrustedPartners are allowed to specify indexed contribution types.
     */
    indexed: boolean;
    /**
     * Friendly name of the contribution/type
     */
    name: string;
    /**
     * Describes the allowed properties for this contribution type
     */
    properties: {
        [key: string]: ContributionPropertyDescription;
    };
}
/**
 * Contextual information that data providers can examine when populating their data
 */
export interface DataProviderContext {
    /**
     * Generic property bag that contains context-specific properties that data providers can use when populating their data dictionary
     */
    properties: {
        [key: string]: any;
    };
}
/**
 * A query that can be issued for data provider data
 */
export interface DataProviderQuery {
    /**
     * Contextual information to pass to the data providers
     */
    context: DataProviderContext;
    /**
     * The contribution ids of the data providers to resolve
     */
    contributionIds: string[];
}
/**
 * Result structure from calls to GetDataProviderData
 */
export interface DataProviderResult {
    /**
     * Property bag of data keyed off of the data provider contribution id
     */
    data: {
        [key: string]: any;
    };
    /**
     * List of data providers resolved in the data-provider query
     */
    resolvedProviders: ResolvedDataProvider[];
}
/**
 * Represents the state of an extension request
 */
export interface ExtensionAuditAction {
}
/**
 * Audit log for an extension
 */
export interface ExtensionAuditLog {
    /**
     * Collection of audit log entries
     */
    entries: ExtensionAuditLogEntry[];
    /**
     * Extension that the change was made for
     */
    extensionName: string;
    /**
     * Publisher that the extension is part of
     */
    publisherName: string;
}
/**
 * An audit log entry for an extension
 */
export interface ExtensionAuditLogEntry {
    /**
     * Change that was made to extension
     */
    auditAction: string;
    /**
     * Date at which the change was made
     */
    auditDate: Date;
    /**
     * Extra information about the change
     */
    comment: string;
    /**
     * Represents the user who made the change
     */
    updatedBy: VSS_Common_Contracts.IdentityRef;
}
/**
 * Represents a single collection for extension data documents
 */
export interface ExtensionDataCollection {
    /**
     * The name of the collection
     */
    collectionName: string;
    /**
     * A list of documents belonging to the collection
     */
    documents: any[];
    /**
     * The type of the collection's scope, such as Default or User
     */
    scopeType: string;
    /**
     * The value of the collection's scope, such as Current or Me
     */
    scopeValue: string;
}
/**
 * Represents a query to receive a set of extension data collections
 */
export interface ExtensionDataCollectionQuery {
    /**
     * A list of collections to query
     */
    collections: ExtensionDataCollection[];
}
/**
 * Base class for an event callback for an extension
 */
export interface ExtensionEventCallback {
    /**
     * The uri of the endpoint that is hit when an event occurs
     */
    uri: string;
}
/**
 * Collection of event callbacks - endpoints called when particular extension events occur.
 */
export interface ExtensionEventCallbackCollection {
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension disable has occurred.
     */
    postDisable: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension enable has occurred.
     */
    postEnable: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install has completed.
     */
    postInstall: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension uninstall has occurred.
     */
    postUninstall: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension update has occurred.
     */
    postUpdate: ExtensionEventCallback;
    /**
     * Optional.  Defines an endpoint that gets called via a POST reqeust to notify that an extension install is about to occur.  Response indicates whether to proceed or abort.
     */
    preInstall: ExtensionEventCallback;
    /**
     * For multi-version extensions, defines an endpoint that gets called via an OPTIONS request to determine the particular version of the extension to be used
     */
    versionCheck: ExtensionEventCallback;
}
export enum ExtensionFlags {
    /**
     * A built-in extension is installed for all VSTS accounts by default
     */
    BuiltIn = 1,
    /**
     * The extension comes from a fully-trusted publisher
     */
    Trusted = 2
}
/**
 * Base class for extension properties which are shared by the extension manifest and the extension model
 */
export interface ExtensionManifest {
    /**
     * Uri used as base for other relative uri's defined in extension
     */
    baseUri: string;
    /**
     * List of contributions made by this extension
     */
    contributions: Contribution[];
    /**
     * List of contribution types defined by this extension
     */
    contributionTypes: ContributionType[];
    /**
     * List of explicit demands required by this extension
     */
    demands: string[];
    /**
     * Collection of endpoints that get called when particular extension events occur
     */
    eventCallbacks: ExtensionEventCallbackCollection;
    /**
     * Language Culture Name set by the Gallery
     */
    language: string;
    /**
     * Version of the extension manifest format/content
     */
    manifestVersion: number;
    /**
     * List of all oauth scopes required by this extension
     */
    scopes: string[];
    /**
     * The ServiceInstanceType(Guid) of the VSTS service that must be available to an account in order for the extension to be installed
     */
    serviceInstanceType: string;
}
/**
 * A request for an extension (to be installed or have a license assigned)
 */
export interface ExtensionRequest {
    /**
     * Required message supplied if the request is rejected
     */
    rejectMessage: string;
    /**
     * Date at which the request was made
     */
    requestDate: Date;
    /**
     * Represents the user who made the request
     */
    requestedBy: VSS_Common_Contracts.IdentityRef;
    /**
     * Optional message supplied by the requester justifying the request
     */
    requestMessage: string;
    /**
     * Represents the state of the request
     */
    requestState: ExtensionRequestState;
    /**
     * Date at which the request was resolved
     */
    resolveDate: Date;
    /**
     * Represents the user who resolved the request
     */
    resolvedBy: VSS_Common_Contracts.IdentityRef;
}
export enum ExtensionRequestState {
    /**
     * The request has been opened, but not yet responded to
     */
    Open = 0,
    /**
     * The request was accepted (extension installed or license assigned)
     */
    Accepted = 1,
    /**
     * The request was rejected (extension not installed or license not assigned)
     */
    Rejected = 2
}
/**
 * The state of an extension
 */
export interface ExtensionState extends InstalledExtensionState {
    extensionName: string;
    /**
     * The time at which the version was last checked
     */
    lastVersionCheck: Date;
    publisherName: string;
    version: string;
}
export enum ExtensionStateFlags {
    /**
     * No flags set
     */
    None = 0,
    /**
     * Extension is disabled
     */
    Disabled = 1,
    /**
     * Extension is a built in
     */
    BuiltIn = 2,
    /**
     * Extension has multiple versions
     */
    MultiVersion = 4,
    /**
     * Extension is not installed.  This is for builtin extensions only and can not otherwise be set.
     */
    UnInstalled = 8,
    /**
     * Error performing version check
     */
    VersionCheckError = 16,
    /**
     * Trusted extensions are ones that are given special capabilities. These tend to come from Microsoft and can't be published by the general public.  Note: BuiltIn extensions are always trusted.
     */
    Trusted = 32,
    /**
     * Extension is currently in an error state
     */
    Error = 64,
    /**
     * Extension scopes have changed and the extension requires re-authorization
     */
    NeedsReauthorization = 128
}
/**
 * Represents a VSTS extension along with its installation state
 */
export interface InstalledExtension extends ExtensionManifest {
    /**
     * The friendly extension id for this extension - unique for a given publisher.
     */
    extensionId: string;
    /**
     * The display name of the extension.
     */
    extensionName: string;
    /**
     * This is the set of files available from the extension.
     */
    files: VSS_Gallery_Contracts.ExtensionFile[];
    /**
     * Extension flags relevant to contribution consumers
     */
    flags: ExtensionFlags;
    /**
     * Information about this particular installation of the extension
     */
    installState: InstalledExtensionState;
    /**
     * This represents the date/time the extensions was last updated in the gallery. This doesnt mean this version was updated the value represents changes to any and all versions of the extension.
     */
    lastPublished: Date;
    /**
     * Unique id of the publisher of this extension
     */
    publisherId: string;
    /**
     * The display name of the publisher
     */
    publisherName: string;
    /**
     * Unique id for this extension (the same id is used for all versions of a single extension)
     */
    registrationId: string;
    /**
     * Version of this extension
     */
    version: string;
}
export interface InstalledExtensionQuery {
    assetTypes: string[];
    monikers: VSS_Gallery_Contracts.ExtensionIdentifier[];
}
/**
 * The state of an installed extension
 */
export interface InstalledExtensionState {
    /**
     * States of an installed extension
     */
    flags: ExtensionStateFlags;
    /**
     * The time at which this installation was last updated
     */
    lastUpdated: Date;
}
/**
 * A request for an extension (to be installed or have a license assigned)
 */
export interface RequestedExtension {
    /**
     * THe unique name of the extensions
     */
    extensionName: string;
    /**
     * A list of each request for the extension
     */
    extensionRequests: ExtensionRequest[];
    /**
     * DisplayName of the publisher that owns the extension being published.
     */
    publisherDisplayName: string;
    /**
     * Represents the Publisher of the requested extension
     */
    publisherName: string;
    /**
     * The total number of requests for an extension
     */
    requestCount: number;
}
/**
 * Entry for a specific data provider's resulting data
 */
export interface ResolvedDataProvider {
    /**
     * The total time the data provider took to resolve its data (in milliseconds)
     */
    duration: number;
    error: string;
    id: string;
}
export interface Scope {
    description: string;
    title: string;
    value: string;
}
/**
 * Information about the extension
 */
export interface SupportedExtension {
    /**
     * Unique Identifier for this extension
     */
    extension: string;
    /**
     * Unique Identifier for this publisher
     */
    publisher: string;
    /**
     * Supported version for this extension
     */
    version: string;
}
export var TypeInfo: {
    AcquisitionOperation: any;
    AcquisitionOperationState: {
        enumValues: {
            "disallow": number;
            "allow": number;
            "completed": number;
        };
    };
    AcquisitionOperationType: {
        enumValues: {
            "get": number;
            "install": number;
            "buy": number;
            "try": number;
            "request": number;
            "none": number;
        };
    };
    AcquisitionOptions: any;
    ContributionPropertyDescription: any;
    ContributionPropertyType: {
        enumValues: {
            "unknown": number;
            "string": number;
            "uri": number;
            "guid": number;
            "boolean": number;
            "integer": number;
            "double": number;
            "dateTime": number;
            "dictionary": number;
            "array": number;
            "object": number;
        };
    };
    ContributionType: any;
    ExtensionAuditLog: any;
    ExtensionAuditLogEntry: any;
    ExtensionFlags: {
        enumValues: {
            "builtIn": number;
            "trusted": number;
        };
    };
    ExtensionManifest: any;
    ExtensionRequest: any;
    ExtensionRequestState: {
        enumValues: {
            "open": number;
            "accepted": number;
            "rejected": number;
        };
    };
    ExtensionState: any;
    ExtensionStateFlags: {
        enumValues: {
            "none": number;
            "disabled": number;
            "builtIn": number;
            "multiVersion": number;
            "unInstalled": number;
            "versionCheckError": number;
            "trusted": number;
            "error": number;
            "needsReauthorization": number;
        };
    };
    InstalledExtension: any;
    InstalledExtensionState: any;
    RequestedExtension: any;
};
}
declare module "VSS/ExtensionManagement/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   extensionmanagement\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Contributions/Contracts");
import VSS_Gallery_Contracts = require("VSS/Gallery/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected installedExtensionsApiVersion: string;
    protected requestedExtensionsApiVersion: string;
    protected requestedExtensionsApiVersion_216b978f: string;
    protected requestedExtensionsApiVersion_aa93e1f3: string;
    protected requestedExtensionsApiVersion_ba93e1f3: string;
    protected tokenApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @return IPromise<string>
     */
    getToken(): IPromise<string>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} requestMessage
     * @return IPromise<Contracts.RequestedExtension>
     */
    requestExtension(publisherName: string, extensionName: string, requestMessage: string): IPromise<Contracts.RequestedExtension>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @return IPromise<void>
     */
    deleteRequest(publisherName: string, extensionName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} rejectMessage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {Contracts.ExtensionRequestState} state
     * @return IPromise<number>
     */
    resolveAllRequests(rejectMessage: string, publisherName: string, extensionName: string, state: Contracts.ExtensionRequestState): IPromise<number>;
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.RequestedExtension[]>
     */
    getRequests(): IPromise<Contracts.RequestedExtension[]>;
    /**
     * [Preview API]
     *
     * @param {string} rejectMessage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} requesterId
     * @param {Contracts.ExtensionRequestState} state
     * @return IPromise<number>
     */
    resolveRequest(rejectMessage: string, publisherName: string, extensionName: string, requesterId: string, state: Contracts.ExtensionRequestState): IPromise<number>;
    /**
     * [Preview API] Update an installed extension. Typically this API is used to enable or disable an extension.
     *
     * @param {Contracts.InstalledExtension} extension
     * @return IPromise<Contracts.InstalledExtension>
     */
    updateInstalledExtension(extension: Contracts.InstalledExtension): IPromise<Contracts.InstalledExtension>;
    /**
     * [Preview API] List the installed extensions in the account / project collection.
     *
     * @param {boolean} includeDisabledExtensions - If true (the default), include disabled extensions in the results.
     * @param {boolean} includeErrors - If true, include installed extensions with errors.
     * @param {string[]} assetTypes
     * @param {boolean} includeInstallationIssues
     * @return IPromise<Contracts.InstalledExtension[]>
     */
    getInstalledExtensions(includeDisabledExtensions?: boolean, includeErrors?: boolean, assetTypes?: string[], includeInstallationIssues?: boolean): IPromise<Contracts.InstalledExtension[]>;
}
export class CommonMethods2_1To5 extends CommonMethods2To5 {
    protected dataApiVersion: string;
    protected extensionStatesApiVersion: string;
    protected installedExtensionQueryApiVersion: string;
    protected installedExtensionsByNameApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Uninstall the specified extension from the account / project collection.
     *
     * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
     * @param {string} extensionName - Name of the extension. Example: "ops-tools".
     * @param {string} reason
     * @param {string} reasonCode
     * @return IPromise<void>
     */
    uninstallExtensionByName(publisherName: string, extensionName: string, reason?: string, reasonCode?: string): IPromise<void>;
    /**
     * [Preview API] Install the specified extension into the account / project collection.
     *
     * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
     * @param {string} extensionName - Name of the extension. Example: "ops-tools".
     * @param {string} version
     * @return IPromise<Contracts.InstalledExtension>
     */
    installExtensionByName(publisherName: string, extensionName: string, version?: string): IPromise<Contracts.InstalledExtension>;
    /**
     * [Preview API] Get an installed extension by its publisher and extension name.
     *
     * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
     * @param {string} extensionName - Name of the extension. Example: "ops-tools".
     * @param {string[]} assetTypes
     * @return IPromise<Contracts.InstalledExtension>
     */
    getInstalledExtensionByName(publisherName: string, extensionName: string, assetTypes?: string[]): IPromise<Contracts.InstalledExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.InstalledExtensionQuery} query
     * @return IPromise<Contracts.InstalledExtension[]>
     */
    queryExtensions(query: Contracts.InstalledExtensionQuery): IPromise<Contracts.InstalledExtension[]>;
    /**
     * [Preview API] List state and version information for all installed extensions.
     *
     * @param {boolean} includeDisabled - If true (the default), include disabled extensions in the results.
     * @param {boolean} includeErrors - If true, include installed extensions in an error state in the results.
     * @param {boolean} includeInstallationIssues
     * @return IPromise<Contracts.ExtensionState[]>
     */
    getStates(includeDisabled?: boolean, includeErrors?: boolean, includeInstallationIssues?: boolean): IPromise<Contracts.ExtensionState[]>;
    /**
     * [Preview API]
     *
     * @param {any} doc
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} scopeType
     * @param {string} scopeValue
     * @param {string} collectionName
     * @return IPromise<any>
     */
    updateDocumentByName(doc: any, publisherName: string, extensionName: string, scopeType: string, scopeValue: string, collectionName: string): IPromise<any>;
    /**
     * [Preview API]
     *
     * @param {any} doc
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} scopeType
     * @param {string} scopeValue
     * @param {string} collectionName
     * @return IPromise<any>
     */
    setDocumentByName(doc: any, publisherName: string, extensionName: string, scopeType: string, scopeValue: string, collectionName: string): IPromise<any>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} scopeType
     * @param {string} scopeValue
     * @param {string} collectionName
     * @return IPromise<any[]>
     */
    getDocumentsByName(publisherName: string, extensionName: string, scopeType: string, scopeValue: string, collectionName: string): IPromise<any[]>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} scopeType
     * @param {string} scopeValue
     * @param {string} collectionName
     * @param {string} documentId
     * @return IPromise<any>
     */
    getDocumentByName(publisherName: string, extensionName: string, scopeType: string, scopeValue: string, collectionName: string, documentId: string): IPromise<any>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} scopeType
     * @param {string} scopeValue
     * @param {string} collectionName
     * @param {string} documentId
     * @return IPromise<void>
     */
    deleteDocumentByName(publisherName: string, extensionName: string, scopeType: string, scopeValue: string, collectionName: string, documentId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {any} doc
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} scopeType
     * @param {string} scopeValue
     * @param {string} collectionName
     * @return IPromise<any>
     */
    createDocumentByName(doc: any, publisherName: string, extensionName: string, scopeType: string, scopeValue: string, collectionName: string): IPromise<any>;
}
export class CommonMethods2_2To5 extends CommonMethods2_1To5 {
    protected extensionDataCollectionQueryApiVersion: string;
    protected policiesApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} userId
     * @return IPromise<VSS_Gallery_Contracts.UserExtensionPolicy>
     */
    getPolicies(userId: string): IPromise<VSS_Gallery_Contracts.UserExtensionPolicy>;
    /**
     * [Preview API] Query for one or more data collections for the specified extension.  Note: the token used for authorization must have been issued on behalf of the specified extension.
     *
     * @param {Contracts.ExtensionDataCollectionQuery} collectionQuery
     * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
     * @param {string} extensionName - Name of the extension. Example: "ops-tools".
     * @return IPromise<Contracts.ExtensionDataCollection[]>
     */
    queryCollectionsByName(collectionQuery: Contracts.ExtensionDataCollectionQuery, publisherName: string, extensionName: string): IPromise<Contracts.ExtensionDataCollection[]>;
}
export class CommonMethods3To5 extends CommonMethods2_2To5 {
    protected acquisitionOptionsApiVersion: string;
    protected acquisitionRequestsApiVersion: string;
    protected authorizationsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} registrationId
     * @return IPromise<Contracts.ExtensionAuthorization>
     */
    registerAuthorization(publisherName: string, extensionName: string, registrationId: string): IPromise<Contracts.ExtensionAuthorization>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionAcquisitionRequest} acquisitionRequest
     * @return IPromise<Contracts.ExtensionAcquisitionRequest>
     */
    requestAcquisition(acquisitionRequest: Contracts.ExtensionAcquisitionRequest): IPromise<Contracts.ExtensionAcquisitionRequest>;
    /**
     * [Preview API]
     *
     * @param {string} itemId
     * @param {boolean} testCommerce
     * @param {boolean} isFreeOrTrialInstall
     * @param {boolean} isAccountOwner
     * @param {boolean} isLinked
     * @param {boolean} isConnectedServer
     * @param {boolean} isBuyOperationValid
     * @return IPromise<Contracts.AcquisitionOptions>
     */
    getAcquisitionOptions(itemId: string, testCommerce?: boolean, isFreeOrTrialInstall?: boolean, isAccountOwner?: boolean, isLinked?: boolean, isConnectedServer?: boolean, isBuyOperationValid?: boolean): IPromise<Contracts.AcquisitionOptions>;
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient5 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient4_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient4 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient3_2 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient3_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient2_3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient2_2 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient2_1 extends CommonMethods2_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class ExtensionManagementHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class ExtensionManagementHttpClient extends ExtensionManagementHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return ExtensionManagementHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): ExtensionManagementHttpClient4_1;
}
declare module "VSS/FeatureAvailability/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export interface FeatureFlag {
    description: string;
    effectiveState: string;
    explicitState: string;
    name: string;
    uri: string;
}
/**
 * This is passed to the FeatureFlagController to edit the status of a feature flag
 */
export interface FeatureFlagPatch {
    state: string;
}
}
declare module "VSS/FeatureAvailability/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/FeatureAvailability/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected featureFlagsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Change the state of an individual feature flag for a name
     *
     * @param {Contracts.FeatureFlagPatch} state - State that should be set
     * @param {string} name - The name of the feature to change
     * @param {string} userEmail
     * @param {boolean} checkFeatureExists - Checks if the feature exists before setting the state
     * @param {boolean} setAtApplicationLevelAlso
     * @return IPromise<Contracts.FeatureFlag>
     */
    updateFeatureFlag(state: Contracts.FeatureFlagPatch, name: string, userEmail?: string, checkFeatureExists?: boolean, setAtApplicationLevelAlso?: boolean): IPromise<Contracts.FeatureFlag>;
    /**
     * [Preview API] Retrieve information on a single feature flag and its current states for a user
     *
     * @param {string} name - The name of the feature to retrieve
     * @param {string} userId - The id of the user to check
     * @param {boolean} checkFeatureExists - Check if feature exists
     * @return IPromise<Contracts.FeatureFlag>
     */
    getFeatureFlagByNameAndUserId(name: string, userId: string, checkFeatureExists?: boolean): IPromise<Contracts.FeatureFlag>;
    /**
     * [Preview API] Retrieve information on a single feature flag and its current states for a user
     *
     * @param {string} name - The name of the feature to retrieve
     * @param {string} userEmail - The email of the user to check
     * @param {boolean} checkFeatureExists - Check if feature exists
     * @return IPromise<Contracts.FeatureFlag>
     */
    getFeatureFlagByNameAndUserEmail(name: string, userEmail: string, checkFeatureExists?: boolean): IPromise<Contracts.FeatureFlag>;
    /**
     * [Preview API] Retrieve information on a single feature flag and its current states
     *
     * @param {string} name - The name of the feature to retrieve
     * @param {boolean} checkFeatureExists - Check if feature exists
     * @return IPromise<Contracts.FeatureFlag>
     */
    getFeatureFlagByName(name: string, checkFeatureExists?: boolean): IPromise<Contracts.FeatureFlag>;
    /**
     * [Preview API] Retrieve a listing of all feature flags and their current states for a user
     *
     * @param {string} userEmail - The email of the user to check
     * @return IPromise<Contracts.FeatureFlag[]>
     */
    getAllFeatureFlags(userEmail?: string): IPromise<Contracts.FeatureFlag[]>;
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureAvailabilityHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class FeatureAvailabilityHttpClient extends FeatureAvailabilityHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return FeatureAvailabilityHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): FeatureAvailabilityHttpClient4_1;
}
declare module "VSS/FeatureAvailability/Services" {
import Service = require("VSS/Service");
/**
* Service to manage feature availability data
*/
export class FeatureAvailabilityService extends Service.VssService {
    private _featureStatesCache;
    constructor();
    /**
     * Uses the default service to perform a local-only check to determine if the feature is enabled.
     * This requires the feature to be present on the the page scope feature-availability-data island.
     *
     * @param featureName Feature name
     * @param defaultValue Value to return if the feature is not present in page context data.
     */
    static isFeatureEnabled(featureName: string, defaultValue?: boolean): boolean;
    /**
     * Returns whether or not a feature is enabled.
     *
     * @param featureName Feature name
     * @param callback
     * Success callback, taking one parameter (boolean) - the feature availability state
     *
     * @param errorCallback Error callback
     */
    beginIsFeatureEnabled(featureName: string, callback: IResultCallback, errorCallback?: IErrorCallback): void;
    /**
     * Performs a local-only check to determine if the feature is enabled. This requires the feature to be present on the the page scope feature-availability-data island.
     *
     * @param featureName Feature name
     * @param defaultValue Value to return if the feature is not present in page context data.
     */
    isFeatureEnabledLocal(featureName: string, defaultValue?: boolean): boolean;
    /**
     * Returns the cache state for the supplied feature after ensuring the data island has been read.
     */
    private _readLocalState;
}
}
declare module "VSS/FeatureManagement/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   extensionmanagement\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
/**
 * A feature that can be enabled or disabled
 */
export interface ContributedFeature {
    /**
     * Named links describing the feature
     */
    _links: any;
    /**
     * If true, the feature is enabled unless overridden at some scope
     */
    defaultState: boolean;
    /**
     * Rules for setting the default value if not specified by any setting/scope. Evaluated in order until a rule returns an Enabled or Disabled state (not Undefined)
     */
    defaultValueRules: ContributedFeatureValueRule[];
    /**
     * The description of the feature
     */
    description: string;
    /**
     * Extra properties for the feature
     */
    featureProperties: {
        [key: string]: any;
    };
    /**
     * Handler for listening to setter calls on feature value. These listeners are only invoked after a successful set has occured
     */
    featureStateChangedListeners: ContributedFeatureListener[];
    /**
     * The full contribution id of the feature
     */
    id: string;
    /**
     * If this is set to true, then the id for this feature will be added to the list of claims for the request.
     */
    includeAsClaim: boolean;
    /**
     * The friendly name of the feature
     */
    name: string;
    /**
     * Suggested order to display feature in.
     */
    order: number;
    /**
     * Rules for overriding a feature value. These rules are run before explicit user/host state values are checked. They are evaluated in order until a rule returns an Enabled or Disabled state (not Undefined)
     */
    overrideRules: ContributedFeatureValueRule[];
    /**
     * The scopes/levels at which settings can set the enabled/disabled state of this feature
     */
    scopes: ContributedFeatureSettingScope[];
    /**
     * The service instance id of the service that owns this feature
     */
    serviceInstanceType: string;
    /**
     * Tags associated with the feature.
     */
    tags: string[];
}
/**
 * The current state of a feature within a given scope
 */
export enum ContributedFeatureEnabledValue {
    /**
     * The state of the feature is not set for the specified scope
     */
    Undefined = -1,
    /**
     * The feature is disabled at the specified scope
     */
    Disabled = 0,
    /**
     * The feature is enabled at the specified scope
     */
    Enabled = 1
}
export interface ContributedFeatureHandlerSettings {
    /**
     * Name of the handler to run
     */
    name: string;
    /**
     * Properties to feed to the handler
     */
    properties: {
        [key: string]: any;
    };
}
/**
 * An identifier and properties used to pass into a handler for a listener or plugin
 */
export interface ContributedFeatureListener extends ContributedFeatureHandlerSettings {
}
/**
 * The scope to which a feature setting applies
 */
export interface ContributedFeatureSettingScope {
    /**
     * The name of the settings scope to use when reading/writing the setting
     */
    settingScope: string;
    /**
     * Whether this is a user-scope or this is a host-wide (all users) setting
     */
    userScoped: boolean;
}
/**
 * A contributed feature/state pair
 */
export interface ContributedFeatureState {
    /**
     * The full contribution id of the feature
     */
    featureId: string;
    /**
     * True if the effective state was set by an override rule (indicating that the state cannot be managed by the end user)
     */
    overridden: boolean;
    /**
     * Reason that the state was set (by a plugin/rule).
     */
    reason: string;
    /**
     * The scope at which this state applies
     */
    scope: ContributedFeatureSettingScope;
    /**
     * The current state of this feature
     */
    state: ContributedFeatureEnabledValue;
}
/**
 * A query for the effective contributed feature states for a list of feature ids
 */
export interface ContributedFeatureStateQuery {
    /**
     * The list of feature ids to query
     */
    featureIds: string[];
    /**
     * The query result containing the current feature states for each of the queried feature ids
     */
    featureStates: {
        [key: string]: ContributedFeatureState;
    };
    /**
     * A dictionary of scope values (project name, etc.) to use in the query (if querying across scopes)
     */
    scopeValues: {
        [key: string]: string;
    };
}
/**
 * A rule for dynamically getting the enabled/disabled state of a feature
 */
export interface ContributedFeatureValueRule extends ContributedFeatureHandlerSettings {
}
export var TypeInfo: {
    ContributedFeatureEnabledValue: {
        enumValues: {
            "undefined": number;
            "disabled": number;
            "enabled": number;
        };
    };
    ContributedFeatureState: any;
    ContributedFeatureStateQuery: any;
};
}
declare module "VSS/FeatureManagement/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   extensionmanagement\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/FeatureManagement/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3To5 extends VSS_WebApi.VssHttpClient {
    protected featuresApiVersion: string;
    protected featureStatesApiVersion: string;
    protected featureStatesApiVersion_98911314: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Set the state of a feature at a specific scope
     *
     * @param {Contracts.ContributedFeatureState} feature - Posted feature state object. Should specify the effective value.
     * @param {string} featureId - Contribution id of the feature
     * @param {string} userScope - User-Scope at which to set the value. Should be "me" for the current user or "host" for all users.
     * @param {string} scopeName - Scope at which to get the feature setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @param {string} reason - Reason for changing the state
     * @param {string} reasonCode - Short reason code
     * @return IPromise<Contracts.ContributedFeatureState>
     */
    setFeatureStateForScope(feature: Contracts.ContributedFeatureState, featureId: string, userScope: string, scopeName: string, scopeValue: string, reason?: string, reasonCode?: string): IPromise<Contracts.ContributedFeatureState>;
    /**
     * [Preview API] Get the state of the specified feature for the given named scope
     *
     * @param {string} featureId - Contribution id of the feature
     * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
     * @param {string} scopeName - Scope at which to get the feature setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @return IPromise<Contracts.ContributedFeatureState>
     */
    getFeatureStateForScope(featureId: string, userScope: string, scopeName: string, scopeValue: string): IPromise<Contracts.ContributedFeatureState>;
    /**
     * [Preview API] Set the state of a feature
     *
     * @param {Contracts.ContributedFeatureState} feature - Posted feature state object. Should specify the effective value.
     * @param {string} featureId - Contribution id of the feature
     * @param {string} userScope - User-Scope at which to set the value. Should be "me" for the current user or "host" for all users.
     * @param {string} reason - Reason for changing the state
     * @param {string} reasonCode - Short reason code
     * @return IPromise<Contracts.ContributedFeatureState>
     */
    setFeatureState(feature: Contracts.ContributedFeatureState, featureId: string, userScope: string, reason?: string, reasonCode?: string): IPromise<Contracts.ContributedFeatureState>;
    /**
     * [Preview API] Get the state of the specified feature for the given user/all-users scope
     *
     * @param {string} featureId - Contribution id of the feature
     * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
     * @return IPromise<Contracts.ContributedFeatureState>
     */
    getFeatureState(featureId: string, userScope: string): IPromise<Contracts.ContributedFeatureState>;
    /**
     * [Preview API] Get a list of all defined features
     *
     * @param {string} targetContributionId - Optional target contribution. If null/empty, return all features. If specified include the features that target the specified contribution.
     * @return IPromise<Contracts.ContributedFeature[]>
     */
    getFeatures(targetContributionId?: string): IPromise<Contracts.ContributedFeature[]>;
    /**
     * [Preview API] Get a specific feature by its id
     *
     * @param {string} featureId - The contribution id of the feature
     * @return IPromise<Contracts.ContributedFeature>
     */
    getFeature(featureId: string): IPromise<Contracts.ContributedFeature>;
}
export class CommonMethods3_1To5 extends CommonMethods3To5 {
    protected featureStatesQueryApiVersion: string;
    protected featureStatesQueryApiVersion_2b4486ad: string;
    protected featureStatesQueryApiVersion_3f810f28: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Get the states of the specified features for the specific named scope
     *
     * @param {Contracts.ContributedFeatureStateQuery} query - Query describing the features to query.
     * @param {string} userScope
     * @param {string} scopeName
     * @param {string} scopeValue
     * @return IPromise<Contracts.ContributedFeatureStateQuery>
     */
    queryFeatureStatesForNamedScope(query: Contracts.ContributedFeatureStateQuery, userScope: string, scopeName: string, scopeValue: string): IPromise<Contracts.ContributedFeatureStateQuery>;
    /**
     * [Preview API] Get the states of the specified features for the default scope
     *
     * @param {Contracts.ContributedFeatureStateQuery} query - Query describing the features to query.
     * @param {string} userScope
     * @return IPromise<Contracts.ContributedFeatureStateQuery>
     */
    queryFeatureStatesForDefaultScope(query: Contracts.ContributedFeatureStateQuery, userScope: string): IPromise<Contracts.ContributedFeatureStateQuery>;
    /**
     * [Preview API] Get the effective state for a list of feature ids
     *
     * @param {Contracts.ContributedFeatureStateQuery} query - Features to query along with current scope values
     * @return IPromise<Contracts.ContributedFeatureStateQuery>
     */
    queryFeatureStates(query: Contracts.ContributedFeatureStateQuery): IPromise<Contracts.ContributedFeatureStateQuery>;
}
/**
 * @exemptedapi
 */
export class FeatureManagementHttpClient5 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureManagementHttpClient4_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureManagementHttpClient4 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureManagementHttpClient3_2 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureManagementHttpClient3_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FeatureManagementHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class FeatureManagementHttpClient extends FeatureManagementHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return FeatureManagementHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): FeatureManagementHttpClient4_1;
}
declare module "VSS/FeatureManagement/Services" {
import Service = require("VSS/Service");
/**
* Service to manage feature availability data
*/
export class FeatureManagementService extends Service.VssService {
    /**
     * Returns whether or not a feature is enabled. Checks features sent through JSON island data via IClientFeatureProviderService.AddFeatureState
     *
     * @param featureName Feature name
     */
    isFeatureEnabled(featureId: string): boolean;
}
}
declare module "VSS/FileContainer/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
/**
 * Status of a container item.
 */
export enum ContainerItemStatus {
    /**
     * Item is created.
     */
    Created = 1,
    /**
     * Item is a file pending for upload.
     */
    PendingUpload = 2
}
/**
 * Type of a container item.
 */
export enum ContainerItemType {
    /**
     * Any item type.
     */
    Any = 0,
    /**
     * Item is a folder which can have child items.
     */
    Folder = 1,
    /**
     * Item is a file which is stored in the file service.
     */
    File = 2
}
/**
 * Options a container can have.
 */
export enum ContainerOptions {
    /**
     * No option.
     */
    None = 0
}
/**
 * Represents a container that encapsulates a hierarchical file system.
 */
export interface FileContainer {
    /**
     * Uri of the artifact associated with the container.
     */
    artifactUri: string;
    /**
     * Download Url for the content of this item.
     */
    contentLocation: string;
    /**
     * Owner.
     */
    createdBy: string;
    /**
     * Creation date.
     */
    dateCreated: Date;
    /**
     * Description.
     */
    description: string;
    /**
     * Id.
     */
    id: number;
    /**
     * Location of the item resource.
     */
    itemLocation: string;
    /**
     * ItemStore Locator for this container.
     */
    locatorPath: string;
    /**
     * Name.
     */
    name: string;
    /**
     * Options the container can have.
     */
    options: ContainerOptions;
    /**
     * Project Id.
     */
    scopeIdentifier: string;
    /**
     * Security token of the artifact associated with the container.
     */
    securityToken: string;
    /**
     * Identifier of the optional encryption key.
     */
    signingKeyId: string;
    /**
     * Total size of the files in bytes.
     */
    size: number;
}
/**
 * Represents an item in a container.
 */
export interface FileContainerItem {
    /**
     * Container Id.
     */
    containerId: number;
    contentId: number[];
    /**
     * Download Url for the content of this item.
     */
    contentLocation: string;
    /**
     * Creator.
     */
    createdBy: string;
    /**
     * Creation date.
     */
    dateCreated: Date;
    /**
     * Last modified date.
     */
    dateLastModified: Date;
    /**
     * Encoding of the file. Zero if not a file.
     */
    fileEncoding: number;
    /**
     * Hash value of the file. Null if not a file.
     */
    fileHash: number[];
    /**
     * Id of the file content.
     */
    fileId: number;
    /**
     * Length of the file. Zero if not of a file.
     */
    fileLength: number;
    /**
     * Type of the file. Zero if not a file.
     */
    fileType: number;
    /**
     * Location of the item resource.
     */
    itemLocation: string;
    /**
     * Type of the item: Folder, File or String.
     */
    itemType: ContainerItemType;
    /**
     * Modifier.
     */
    lastModifiedBy: string;
    /**
     * Unique path that identifies the item.
     */
    path: string;
    /**
     * Project Id.
     */
    scopeIdentifier: string;
    /**
     * Status of the item: Created or Pending Upload.
     */
    status: ContainerItemStatus;
    ticket: string;
}
export var TypeInfo: {
    ContainerItemStatus: {
        enumValues: {
            "created": number;
            "pendingUpload": number;
        };
    };
    ContainerItemType: {
        enumValues: {
            "any": number;
            "folder": number;
            "file": number;
        };
    };
    ContainerOptions: {
        enumValues: {
            "none": number;
        };
    };
    FileContainer: any;
    FileContainerItem: any;
};
}
declare module "VSS/FileContainer/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/FileContainer/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected containersApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {number} containerId
     * @param {string} scope
     * @param {string} itemPath
     * @param {boolean} metadata
     * @param {string} format
     * @param {string} downloadFileName
     * @param {boolean} includeDownloadTickets
     * @param {boolean} isShallow
     * @return IPromise<Contracts.FileContainerItem[]>
     */
    getItems(containerId: number, scope?: string, itemPath?: string, metadata?: boolean, format?: string, downloadFileName?: string, includeDownloadTickets?: boolean, isShallow?: boolean): IPromise<Contracts.FileContainerItem[]>;
    /**
     * [Preview API] Gets containers filtered by a comma separated list of artifact uris within the same scope, if not specified returns all containers
     *
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @param {string} artifactUris
     * @return IPromise<Contracts.FileContainer[]>
     */
    getContainers(scope?: string, artifactUris?: string): IPromise<Contracts.FileContainer[]>;
    /**
     * [Preview API] Deletes the specified items in a container.
     *
     * @param {number} containerId - Container Id.
     * @param {string} itemPath - Path to delete.
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @return IPromise<void>
     */
    deleteItem(containerId: number, itemPath: string, scope?: string): IPromise<void>;
    /**
     * [Preview API] Creates the specified items in in the referenced container.
     *
     * @param {VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.FileContainerItem[]>} items
     * @param {number} containerId
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @return IPromise<Contracts.FileContainerItem[]>
     */
    createItems(items: VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.FileContainerItem[]>, containerId: number, scope?: string): IPromise<Contracts.FileContainerItem[]>;
    /**
     * [Preview API] Creates the specified item in the container referenced container.
     *
     * @param {string} content - Content to upload
     * @param {number} containerId
     * @param {string} itemPath
     * @param {string} scope - A guid representing the scope of the container. This is often the project id.
     * @return IPromise<Contracts.FileContainerItem>
     */
    createItem(content: string, containerId: number, itemPath: string, scope?: string): IPromise<Contracts.FileContainerItem>;
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class FileContainerHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class FileContainerHttpClient extends FileContainerHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return FileContainerHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): FileContainerHttpClient4_1;
}
declare module "VSS/FileContainer/Services" {
import FileContainer_Contracts = require("VSS/FileContainer/Contracts");
import Service = require("VSS/Service");
export interface FileContainerPathInfo {
    containerId: number;
    path: string;
}
/**
* Service to manage file container data
*/
export class FileContainerService extends Service.VssService {
    private _httpClient;
    /**
     * Returns a list of file container items
     *
     * @param containerId The id of the container
     * @param scope The scope of the items
     * @param itemPath The path of the item within the container
     */
    beginGetItems(containerId: number, scope: string, itemPath: string): IPromise<FileContainer_Contracts.FileContainerItem[]>;
    /**
     * Returns the file container info
     *
     * @param fileContainerPath The path of the container. For example, "#/12/drop".
     */
    parseContainerPath(fileContainerPath: string): FileContainerPathInfo;
}
}
declare module "VSS/Flux/Action" {
export class Action<T> {
    /**
     * A mutex to ensure that only one action in a given scope is executing at any time.
     * This prevents cascading actions.
     */
    private static executingScopes;
    private _listeners;
    private _scope;
    /**
     * Create a new action
     * @param scope The scope that this action should execute in. Actions with the same scope cannot be invoked within each other
     */
    constructor(scope?: string);
    invoke(payload: T): void;
    /**
     * Add listener to the action
     * @param listener Listener to add
     * @param context Optional context to bind to listener
     * @returns Listener that was added, might be different from the passed in listener if context is given
     */
    addListener(listener: (payload: T) => void, context?: any): (payload: T) => void;
    /**
     * Remove listener from the action
     * @param listener Listener to remove
     */
    removeListener(listener: (payload: T) => void): void;
}
}
declare module "VSS/Flux/AsyncLoadedComponent" {
import * as React from "react";
/** Given the imported modules (in the order given in the modules array), return the type of the component to create */
export type ModuleComponentSelector<TProps> = (...modules: any[]) => React.ComponentClass<TProps> | React.StatelessComponent<TProps>;
/**
 * Create a method returning a delay loaded component instance
 * @param modules Paths of modules to load
 * @param moduleComponentSelector Selector function, given the imported modules to return the type/constructor method to create
 *                                the desired component.
 * @param componentWhileLoading Optional function to return a component to display while loading
 * @param onLoadStart Optional callback function that will be called once the component async load starts
 * @param onLoadEnd Optional callback function that will be called once the component async load ends
 */
export function getAsyncLoadedComponent<TProps = {}>(modules: string[], moduleComponentSelector: ModuleComponentSelector<TProps>, componentWhileLoading?: () => JSX.Element, onLoadStart?: () => void, onLoadEnd?: () => void): (props: TProps) => JSX.Element;
}
declare module "VSS/Flux/Component" {
import React = require("react");
import Store_Base = require("VSS/Flux/Store");
export interface Props extends React.Props<any> {
    cssClass?: string;
}
export interface State {
}
export class Component<TProps extends Props, TState extends State = {}> extends React.Component<TProps, TState> {
    private _changeDelegate;
    constructor(props?: TProps, context?: any);
    protected getKey(name: string): string;
    protected getState(): TState;
    protected onChange(): void;
    protected getStore(): Store_Base.Store;
    componentDidMount(): void;
    componentWillUnmount(): void;
}
}
declare module "VSS/Flux/Diag" {
/**
 * Apply to an ActionsHub to register it with the perf panel actions monitor
 * @param originalConstructor ActionsHub that contains public Action<T> properties
 */
export const registerDiagActions: <T>(originalConstructor: new (...args: any[]) => T) => new (...args: any[]) => T;
}
declare module "VSS/Flux/PlatformComponent" {
import Component_Base = require("VSS/Flux/Component");
import Controls = require("VSS/Controls");
export interface Props<TOptions extends Controls.EnhancementOptions> extends Component_Base.Props {
    /**
     * Platform control options.
     */
    options?: TOptions;
    /**
     *  Tag name of the component.
     */
    tagName?: string;
    /**
     * Specifies whether the component should trigger render when the component is updated.
     * @defaultvalue false
     */
    shouldUpdate?: boolean;
}
export interface State extends Component_Base.State {
}
/**
 * This a base component which wraps an existing legacy platform control like grid, treeview, splitter.
 */
export class Component<TControl extends Controls.BaseControl, TProps extends Props<any>, TState extends State> extends Component_Base.Component<TProps, TState> {
    protected _control: TControl;
    render(): JSX.Element;
    protected onRef(element: HTMLElement): void;
    /**
     * Gets the name of the tag for the React element.
     *
     * @returns Tag name.
     */
    protected getTagName(): string;
    /**
     * Determines whether render method should be executed or not.
     * @param nextProps New properties.
     * @param nextState New state.
     */
    shouldComponentUpdate(nextProps: TProps, nextState: TState): boolean;
    /**
     * Called before the component is unloaded.
     */
    componentWillUnmount(): void;
    /**
     * Components will override this method, generate the platform control and return it.
     *
     * @param element JQuery element.
     * @returns TControl
     */
    protected createControl(element: JQuery): TControl;
}
}
declare module "VSS/Flux/Store" {
import { Action } from "VSS/Flux/Action";
export interface IStore {
    addChangedListener(handler: IEventHandler): void;
    removeChangedListener(handler: IEventHandler): void;
    addListener(eventName: string, handler: IEventHandler): void;
    removeListener(eventName: string, handler: IEventHandler): void;
}
export class Store implements IStore {
    private _changedHandlers;
    private _namedEventCollection;
    addChangedListener(handler: IEventHandler): void;
    removeChangedListener(handler: IEventHandler): void;
    protected emitChanged(): void;
    protected emit(eventName: string, sender: any, data?: any): void;
    addListener(eventName: string, handler: IEventHandler): void;
    removeListener(eventName: string, handler: IEventHandler): void;
}
export class DefaultStore<T> extends Store {
    protected _value: T;
    constructor();
    protected getAction(): Action<T>;
    protected onChange(payload: T): void;
    getValue(): T;
}
export class RemoteStore extends Store {
    protected _error: any;
    protected _loading: boolean;
    constructor();
    isLoading(): boolean;
    hasError(): boolean;
    getError(): any;
    protected onError(error: any): void;
}
}
declare module "VSS/Gallery/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   gallery\client\webapi\clientgeneratorconfigs\genclient.json
 */
/**
 * How the acquisition is assigned
 */
export enum AcquisitionAssignmentType {
    None = 0,
    /**
     * Just assign for me
     */
    Me = 1,
    /**
     * Assign for all users in the account
     */
    All = 2
}
export interface AcquisitionOperation {
    /**
     * State of the the AcquisitionOperation for the current user
     */
    operationState: AcquisitionOperationState;
    /**
     * AcquisitionOperationType: install, request, buy, etc...
     */
    operationType: AcquisitionOperationType;
    /**
     * Optional reason to justify current state. Typically used with Disallow state.
     */
    reason: string;
}
export enum AcquisitionOperationState {
    /**
     * Not allowed to use this AcquisitionOperation
     */
    Disallow = 0,
    /**
     * Allowed to use this AcquisitionOperation
     */
    Allow = 1,
    /**
     * Operation has already been completed and is no longer available
     */
    Completed = 3
}
/**
 * Set of different types of operations that can be requested.
 */
export enum AcquisitionOperationType {
    /**
     * Not yet used
     */
    Get = 0,
    /**
     * Install this extension into the host provided
     */
    Install = 1,
    /**
     * Buy licenses for this extension and install into the host provided
     */
    Buy = 2,
    /**
     * Try this extension
     */
    Try = 3,
    /**
     * Request this extension for installation
     */
    Request = 4,
    /**
     * No action found
     */
    None = 5,
    /**
     * Request admins for purchasing extension
     */
    PurchaseRequest = 6
}
/**
 * Market item acquisition options (install, buy, etc) for an installation target.
 */
export interface AcquisitionOptions {
    /**
     * Default Operation for the ItemId in this target
     */
    defaultOperation: AcquisitionOperation;
    /**
     * The item id that this options refer to
     */
    itemId: string;
    /**
     * Operations allowed for the ItemId in this target
     */
    operations: AcquisitionOperation[];
    /**
     * The target that this options refer to
     */
    target: string;
}
export interface Answers {
    /**
     * Gets or sets the vs marketplace extension name
     */
    vSMarketplaceExtensionName: string;
    /**
     * Gets or sets the vs marketplace publsiher name
     */
    vSMarketplacePublisherName: string;
}
export interface AssetDetails {
    /**
     * Gets or sets the Answers, which contains vs marketplace extension name and publisher name
     */
    answers: Answers;
    /**
     * Gets or sets the VS publisher Id
     */
    publisherNaturalIdentifier: string;
}
export interface AzurePublisher {
    azurePublisherId: string;
    publisherName: string;
}
export interface AzureRestApiRequestModel {
    /**
     * Gets or sets the Asset details
     */
    assetDetails: AssetDetails;
    /**
     * Gets or sets the asset id
     */
    assetId: string;
    /**
     * Gets or sets the asset version
     */
    assetVersion: number;
    /**
     * Gets or sets the customer support email
     */
    customerSupportEmail: string;
    /**
     * Gets or sets the integration contact email
     */
    integrationContactEmail: string;
    /**
     * Gets or sets the asset version
     */
    operation: string;
    /**
     * Gets or sets the plan identifier if any.
     */
    planId: string;
    /**
     * Gets or sets the publisher id
     */
    publisherId: string;
    /**
     * Gets or sets the resource type
     */
    type: string;
}
export interface AzureRestApiResponseModel extends AzureRestApiRequestModel {
    /**
     * Gets or sets the Asset operation status
     */
    operationStatus: RestApiResponseStatusModel;
}
/**
 * This is the set of categories in response to the get category query
 */
export interface CategoriesResult {
    categories: ExtensionCategory[];
}
/**
 * Definition of one title of a category
 */
export interface CategoryLanguageTitle {
    /**
     * The language for which the title is applicable
     */
    lang: string;
    /**
     * The language culture id of the lang parameter
     */
    lcid: number;
    /**
     * Actual title to be shown on the UI
     */
    title: string;
}
/**
 * The structure of a Concern Rather than defining a separate data structure having same fields as QnAItem, we are inheriting from the QnAItem.
 */
export interface Concern extends QnAItem {
    /**
     * Category of the concern
     */
    category: ConcernCategory;
}
export enum ConcernCategory {
    General = 1,
    Abusive = 2,
    Spam = 4
}
/**
 * Stores Last Contact Date
 */
export interface CustomerLastContact {
    /**
     * account for which customer was last contacted
     */
    account: string;
    /**
     * Date on which the custoemr was last contacted
     */
    lastContactDate: Date;
}
export enum DraftPatchOperation {
    Publish = 1,
    Cancel = 2
}
export enum DraftStateType {
    Unpublished = 1,
    Published = 2,
    Cancelled = 3,
    Error = 4
}
export interface EventCounts {
    /**
     * Average rating on the day for extension
     */
    averageRating: number;
    /**
     * Number of times the extension was bought in hosted scenario (applies only to VSTS extensions)
     */
    buyCount: number;
    /**
     * Number of times the extension was bought in connected scenario (applies only to VSTS extensions)
     */
    connectedBuyCount: number;
    /**
     * Number of times the extension was installed in connected scenario (applies only to VSTS extensions)
     */
    connectedInstallCount: number;
    /**
     * Number of times the extension was installed
     */
    installCount: number;
    /**
     * Number of times the extension was installed as a trial (applies only to VSTS extensions)
     */
    tryCount: number;
    /**
     * Number of times the extension was uninstalled (applies only to VSTS extensions)
     */
    uninstallCount: number;
    /**
     * Number of times the extension was downloaded (applies to VSTS extensions and VSCode marketplace click installs)
     */
    webDownloadCount: number;
    /**
     * Number of detail page views
     */
    webPageViews: number;
}
/**
 * Contract for handling the extension acquisition process
 */
export interface ExtensionAcquisitionRequest {
    /**
     * How the item is being assigned
     */
    assignmentType: AcquisitionAssignmentType;
    /**
     * The id of the subscription used for purchase
     */
    billingId: string;
    /**
     * The marketplace id (publisherName.extensionName) for the item
     */
    itemId: string;
    /**
     * The type of operation, such as install, request, purchase
     */
    operationType: AcquisitionOperationType;
    /**
     * Additional properties which can be added to the request.
     */
    properties: any;
    /**
     * How many licenses should be purchased
     */
    quantity: number;
    /**
     * A list of target guids where the item should be acquired (installed, requested, etc.), such as account id
     */
    targets: string[];
}
export interface ExtensionBadge {
    description: string;
    imgUri: string;
    link: string;
}
export interface ExtensionCategory {
    /**
     * The name of the products with which this category is associated to.
     */
    associatedProducts: string[];
    categoryId: number;
    /**
     * This is the internal name for a category
     */
    categoryName: string;
    /**
     * This parameter is obsolete. Refer to LanguageTitles for langauge specific titles
     */
    language: string;
    /**
     * The list of all the titles of this category in various languages
     */
    languageTitles: CategoryLanguageTitle[];
    /**
     * This is the internal name of the parent if this is associated with a parent
     */
    parentCategoryName: string;
}
export interface ExtensionDailyStat {
    /**
     * Stores the event counts
     */
    counts: EventCounts;
    /**
     * Generic key/value pair to store extended statistics. Used for sending paid extension stats like Upgrade, Downgrade, Cancel trend etc.
     */
    extendedStats: {
        [key: string]: any;
    };
    /**
     * Timestamp of this data point
     */
    statisticDate: Date;
    /**
     * Version of the extension
     */
    version: string;
}
export interface ExtensionDailyStats {
    /**
     * List of extension statistics data points
     */
    dailyStats: ExtensionDailyStat[];
    /**
     * Id of the extension, this will never be sent back to the client. For internal use only.
     */
    extensionId: string;
    /**
     * Name of the extension
     */
    extensionName: string;
    /**
     * Name of the publisher
     */
    publisherName: string;
    /**
     * Count of stats
     */
    statCount: number;
}
export enum ExtensionDeploymentTechnology {
    Exe = 1,
    Msi = 2,
    Vsix = 3,
    ReferralLink = 4
}
export interface ExtensionDraft {
    assets: ExtensionDraftAsset[];
    createdDate: Date;
    draftState: DraftStateType;
    extensionName: string;
    id: string;
    lastUpdated: Date;
    payload: ExtensionPayload;
    product: string;
    publisherName: string;
    validationErrors: {
        key: string;
        value: string;
    }[];
    validationWarnings: {
        key: string;
        value: string;
    }[];
}
export interface ExtensionDraftAsset extends ExtensionFile {
}
export interface ExtensionDraftPatch {
    extensionData: UnpackagedExtensionData;
    operation: DraftPatchOperation;
}
/**
 * Stores details of each event
 */
export interface ExtensionEvent {
    /**
     * Id which identifies each data point uniquely
     */
    id: number;
    properties: any;
    /**
     * Timestamp of when the event occurred
     */
    statisticDate: Date;
    /**
     * Version of the extension
     */
    version: string;
}
/**
 * Container object for all extension events. Stores all install and uninstall events related to an extension. The events container is generic so can store data of any type of event. New event types can be added without altering the contract.
 */
export interface ExtensionEvents {
    /**
     * Generic container for events data. The dictionary key denotes the type of event and the list contains properties related to that event
     */
    events: {
        [key: string]: ExtensionEvent[];
    };
    /**
     * Id of the extension, this will never be sent back to the client. This field will mainly be used when EMS calls into Gallery REST API to update install/uninstall events for various extensions in one go.
     */
    extensionId: string;
    /**
     * Name of the extension
     */
    extensionName: string;
    /**
     * Name of the publisher
     */
    publisherName: string;
}
export interface ExtensionFile {
    assetType: string;
    language: string;
    source: string;
}
/**
 * The FilterResult is the set of extensions that matched a particular query filter.
 */
export interface ExtensionFilterResult {
    /**
     * This is the set of appplications that matched the query filter supplied.
     */
    extensions: PublishedExtension[];
    /**
     * The PagingToken is returned from a request when more records exist that match the result than were requested or could be returned. A follow-up query with this paging token can be used to retrieve more results.
     */
    pagingToken: string;
    /**
     * This is the additional optional metadata for the given result. E.g. Total count of results which is useful in case of paged results
     */
    resultMetadata: ExtensionFilterResultMetadata[];
}
/**
 * ExtensionFilterResultMetadata is one set of metadata for the result e.g. Total count. There can be multiple metadata items for one metadata.
 */
export interface ExtensionFilterResultMetadata {
    /**
     * The metadata items for the category
     */
    metadataItems: MetadataItem[];
    /**
     * Defines the category of metadata items
     */
    metadataType: string;
}
/**
 * Represents the component pieces of an extensions fully qualified name, along with the fully qualified name.
 */
export interface ExtensionIdentifier {
    /**
     * The ExtensionName component part of the fully qualified ExtensionIdentifier
     */
    extensionName: string;
    /**
     * The PublisherName component part of the fully qualified ExtensionIdentifier
     */
    publisherName: string;
}
/**
 * Type of event
 */
export enum ExtensionLifecycleEventType {
    Uninstall = 1,
    Install = 2,
    Review = 3,
    Acquisition = 4,
    Sales = 5,
    Other = 999
}
/**
 * Package that will be used to create or update a published extension
 */
export interface ExtensionPackage {
    /**
     * Base 64 encoded extension package
     */
    extensionManifest: string;
}
export interface ExtensionPayload {
    description: string;
    displayName: string;
    fileName: string;
    installationTargets: InstallationTarget[];
    isSignedByMicrosoft: boolean;
    isValid: boolean;
    metadata: {
        key: string;
        value: string;
    }[];
    type: ExtensionDeploymentTechnology;
}
/**
 * Policy with a set of permissions on extension operations
 */
export interface ExtensionPolicy {
    /**
     * Permissions on 'Install' operation
     */
    install: ExtensionPolicyFlags;
    /**
     * Permission on 'Request' operation
     */
    request: ExtensionPolicyFlags;
}
/**
 * Set of flags that can be associated with a given permission over an extension
 */
export enum ExtensionPolicyFlags {
    /**
     * No permission
     */
    None = 0,
    /**
     * Permission on private extensions
     */
    Private = 1,
    /**
     * Permission on public extensions
     */
    Public = 2,
    /**
     * Premission in extensions that are in preview
     */
    Preview = 4,
    /**
     * Premission in relased extensions
     */
    Released = 8,
    /**
     * Permission in 1st party extensions
     */
    FirstParty = 16,
    /**
     * Mask that defines all permissions
     */
    All = 31
}
/**
 * An ExtensionQuery is used to search the gallery for a set of extensions that match one of many filter values.
 */
export interface ExtensionQuery {
    /**
     * When retrieving extensions with a query; frequently the caller only needs a small subset of the assets. The caller may specify a list of asset types that should be returned if the extension contains it. All other assets will not be returned.
     */
    assetTypes: string[];
    /**
     * Each filter is a unique query and will have matching set of extensions returned from the request. Each result will have the same index in the resulting array that the filter had in the incoming query.
     */
    filters: QueryFilter[];
    /**
     * The Flags are used to deterine which set of information the caller would like returned for the matched extensions.
     */
    flags: ExtensionQueryFlags;
}
/**
 * Type of extension filters that are supported in the queries.
 */
export enum ExtensionQueryFilterType {
    /**
     * The values are used as tags. All tags are treated as "OR" conditions with each other. There may be some value put on the number of matched tags from the query.
     */
    Tag = 1,
    /**
     * The Values are an ExtensionName or fragment that is used to match other extension names.
     */
    DisplayName = 2,
    /**
     * The Filter is one or more tokens that define what scope to return private extensions for.
     */
    Private = 3,
    /**
     * Retrieve a set of extensions based on their id's. The values should be the extension id's encoded as strings.
     */
    Id = 4,
    /**
     * The catgeory is unlike other filters. It is AND'd with the other filters instead of being a seperate query.
     */
    Category = 5,
    /**
     * Certain contribution types may be indexed to allow for query by type. User defined types can't be indexed at the moment.
     */
    ContributionType = 6,
    /**
     * Retrieve an set extension based on the name based identifier. This differs from the internal id (which is being deprecated).
     */
    Name = 7,
    /**
     * The InstallationTarget for an extension defines the target consumer for the extension. This may be something like VS, VSOnline, or VSCode
     */
    InstallationTarget = 8,
    /**
     * Query for featured extensions, no value is allowed when using the query type.
     */
    Featured = 9,
    /**
     * The SearchText provided by the user to search for extensions
     */
    SearchText = 10,
    /**
     * Query for extensions that are featured in their own category, The filterValue for this is name of category of extensions.
     */
    FeaturedInCategory = 11,
    /**
     * When retrieving extensions from a query, exclude the extensions which are having the given flags. The value specified for this filter should be a string representing the integer values of the flags to be excluded. In case of mulitple flags to be specified, a logical OR of the interger values should be given as value for this filter This should be at most one filter of this type. This only acts as a restrictive filter after. In case of having a particular flag in both IncludeWithFlags and ExcludeWithFlags, excludeFlags will remove the included extensions giving empty result for that flag.
     */
    ExcludeWithFlags = 12,
    /**
     * When retrieving extensions from a query, include the extensions which are having the given flags. The value specified for this filter should be a string representing the integer values of the flags to be included. In case of mulitple flags to be specified, a logical OR of the interger values should be given as value for this filter This should be at most one filter of this type. This only acts as a restrictive filter after. In case of having a particular flag in both IncludeWithFlags and ExcludeWithFlags, excludeFlags will remove the included extensions giving empty result for that flag. In case of multiple flags given in IncludeWithFlags in ORed fashion, extensions having any of the given flags will be included.
     */
    IncludeWithFlags = 13,
    /**
     * Fitler the extensions based on the LCID values applicable. Any extensions which are not having any LCID values will also be filtered. This is currenlty only supported for VS extensions.
     */
    Lcid = 14,
    /**
     * Filter to provide the version of the installation target. This filter will be used along with InstallationTarget filter. The value should be a valid version string. Currently supported only if search text is provided.
     */
    InstallationTargetVersion = 15,
    /**
     * Filter type for specifying a range of installation target version. The filter will be used along with InstallationTarget filter. The value should be a pair of well formed version values separated by hyphen(-). Currently supported only if search text is provided.
     */
    InstallationTargetVersionRange = 16,
    /**
     * Filter type for specifying metadata key and value to be used for filtering.
     */
    VsixMetadata = 17,
    /**
     * Filter to get extensions published by a publisher having supplied internal name
     */
    PublisherName = 18,
    /**
     * Filter to get extensions published by all publishers having supplied display name
     */
    PublisherDisplayName = 19,
    /**
     * When retrieving extensions from a query, include the extensions which have a publisher having the given flags. The value specified for this filter should be a string representing the integer values of the flags to be included. In case of mulitple flags to be specified, a logical OR of the interger values should be given as value for this filter There should be at most one filter of this type. This only acts as a restrictive filter after. In case of multiple flags given in IncludeWithFlags in ORed fashion, extensions having any of the given flags will be included.
     */
    IncludeWithPublisherFlags = 20,
    /**
     * Filter to get extensions shared with particular organization
     */
    OrganizationSharedWith = 21
}
/**
 * Set of flags used to determine which set of information is retrieved when reading published extensions
 */
export enum ExtensionQueryFlags {
    /**
     * None is used to retrieve only the basic extension details.
     */
    None = 0,
    /**
     * IncludeVersions will return version information for extensions returned
     */
    IncludeVersions = 1,
    /**
     * IncludeFiles will return information about which files were found within the extension that were stored independant of the manifest. When asking for files, versions will be included as well since files are returned as a property of the versions.  These files can be retrieved using the path to the file without requiring the entire manifest be downloaded.
     */
    IncludeFiles = 2,
    /**
     * Include the Categories and Tags that were added to the extension definition.
     */
    IncludeCategoryAndTags = 4,
    /**
     * Include the details about which accounts the extension has been shared with if the extension is a private extension.
     */
    IncludeSharedAccounts = 8,
    /**
     * Include properties associated with versions of the extension
     */
    IncludeVersionProperties = 16,
    /**
     * Excluding non-validated extensions will remove any extension versions that either are in the process of being validated or have failed validation.
     */
    ExcludeNonValidated = 32,
    /**
     * Include the set of installation targets the extension has requested.
     */
    IncludeInstallationTargets = 64,
    /**
     * Include the base uri for assets of this extension
     */
    IncludeAssetUri = 128,
    /**
     * Include the statistics associated with this extension
     */
    IncludeStatistics = 256,
    /**
     * When retrieving versions from a query, only include the latest version of the extensions that matched. This is useful when the caller doesn't need all the published versions. It will save a significant size in the returned payload.
     */
    IncludeLatestVersionOnly = 512,
    /**
     * This flag switches the asset uri to use GetAssetByName instead of CDN When this is used, values of base asset uri and base asset uri fallback are switched When this is used, source of asset files are pointed to Gallery service always even if CDN is available
     */
    UseFallbackAssetUri = 1024,
    /**
     * This flag is used to get all the metadata values associated with the extension. This is not applicable to VSTS or VSCode extensions and usage is only internal.
     */
    IncludeMetadata = 2048,
    /**
     * This flag is used to indicate to return very small data for extension reruired by VS IDE. This flag is only compatible when querying is done by VS IDE
     */
    IncludeMinimalPayloadForVsIde = 4096,
    /**
     * This flag is used to get Lcid values associated with the extension. This is not applicable to VSTS or VSCode extensions and usage is only internal
     */
    IncludeLcids = 8192,
    /**
     * Include the details about which organizations the extension has been shared with if the extesion is a private extension.
     */
    IncludeSharedOrganizations = 16384,
    /**
     * AllAttributes is designed to be a mask that defines all sub-elements of the extension should be returned.  NOTE: This is not actually All flags. This is now locked to the set defined since changing this enum would be a breaking change and would change the behavior of anyone using it. Try not to use this value when making calls to the service, instead be explicit about the options required.
     */
    AllAttributes = 16863
}
/**
 * This is the set of extensions that matched a supplied query through the filters given.
 */
export interface ExtensionQueryResult {
    /**
     * For each filter supplied in the query, a filter result will be returned in the query result.
     */
    results: ExtensionFilterResult[];
}
export interface ExtensionShare {
    id: string;
    isOrg: boolean;
    name: string;
    type: string;
}
export interface ExtensionStatistic {
    statisticName: string;
    value: number;
}
export enum ExtensionStatisticOperation {
    None = 0,
    Set = 1,
    Increment = 2,
    Decrement = 3,
    Delete = 4
}
export interface ExtensionStatisticUpdate {
    extensionName: string;
    operation: ExtensionStatisticOperation;
    publisherName: string;
    statistic: ExtensionStatistic;
}
/**
 * Stats aggregation type
 */
export enum ExtensionStatsAggregateType {
    Daily = 1
}
export interface ExtensionVersion {
    assetUri: string;
    badges: ExtensionBadge[];
    fallbackAssetUri: string;
    files: ExtensionFile[];
    flags: ExtensionVersionFlags;
    lastUpdated: Date;
    properties: {
        key: string;
        value: string;
    }[];
    validationResultMessage: string;
    version: string;
    versionDescription: string;
}
/**
 * Set of flags that can be associated with a given extension version. These flags apply to a specific version of the extension.
 */
export enum ExtensionVersionFlags {
    /**
     * No flags exist for this version.
     */
    None = 0,
    /**
     * The Validated flag for a version means the extension version has passed validation and can be used..
     */
    Validated = 1
}
/**
 * One condition in a QueryFilter.
 */
export interface FilterCriteria {
    filterType: number;
    /**
     * The value used in the match based on the filter type.
     */
    value: string;
}
export interface InstallationTarget {
    target: string;
    targetVersion: string;
}
/**
 * MetadataItem is one value of metadata under a given category of metadata
 */
export interface MetadataItem {
    /**
     * The count of the metadata item
     */
    count: number;
    /**
     * The name of the metadata item
     */
    name: string;
}
/**
 * Information needed for sending mail notification
 */
export interface NotificationsData {
    /**
     * Notification data needed
     */
    data: {
        [key: string]: any;
    };
    /**
     * List of users who should get the notification
     */
    identities: {
        [key: string]: any;
    };
    /**
     * Type of Mail Notification.Can be Qna , review or CustomerContact
     */
    type: NotificationTemplateType;
}
/**
 * Type of event
 */
export enum NotificationTemplateType {
    /**
     * Template type for Review Notification.
     */
    ReviewNotification = 1,
    /**
     * Template type for Qna Notification.
     */
    QnaNotification = 2,
    /**
     * Template type for Customer Contact Notification.
     */
    CustomerContactNotification = 3,
    /**
     * Template type for Publisher Member Notification.
     */
    PublisherMemberUpdateNotification = 4
}
/**
 * PagingDirection is used to define which set direction to move the returned result set based on a previous query.
 */
export enum PagingDirection {
    /**
     * Backward will return results from earlier in the resultset.
     */
    Backward = 1,
    /**
     * Forward will return results from later in the resultset.
     */
    Forward = 2
}
/**
 * This is the set of categories in response to the get category query
 */
export interface ProductCategoriesResult {
    categories: ProductCategory[];
}
/**
 * This is the interface object to be used by Root Categories and Category Tree APIs for Visual Studio Ide.
 */
export interface ProductCategory {
    children: ProductCategory[];
    /**
     * Indicator whether this is a leaf or there are children under this category
     */
    hasChildren: boolean;
    /**
     * Individual Guid of the Category
     */
    id: string;
    /**
     * Category Title in the requested language
     */
    title: string;
}
export interface PublishedExtension {
    categories: string[];
    deploymentType: ExtensionDeploymentTechnology;
    displayName: string;
    extensionId: string;
    extensionName: string;
    flags: PublishedExtensionFlags;
    installationTargets: InstallationTarget[];
    lastUpdated: Date;
    longDescription: string;
    /**
     * Date on which the extension was first uploaded.
     */
    publishedDate: Date;
    publisher: PublisherFacts;
    /**
     * Date on which the extension first went public.
     */
    releaseDate: Date;
    sharedWith: ExtensionShare[];
    shortDescription: string;
    statistics: ExtensionStatistic[];
    tags: string[];
    versions: ExtensionVersion[];
}
/**
 * Set of flags that can be associated with a given extension. These flags apply to all versions of the extension and not to a specific version.
 */
export enum PublishedExtensionFlags {
    /**
     * No flags exist for this extension.
     */
    None = 0,
    /**
     * The Disabled flag for an extension means the extension can't be changed and won't be used by consumers. The disabled flag is managed by the service and can't be supplied by the Extension Developers.
     */
    Disabled = 1,
    /**
     * BuiltIn Extension are available to all Tenants. An explicit registration is not required. This attribute is reserved and can't be supplied by Extension Developers.  BuiltIn extensions are by definition Public. There is no need to set the public flag for extensions marked BuiltIn.
     */
    BuiltIn = 2,
    /**
     * This extension has been validated by the service. The extension meets the requirements specified. This attribute is reserved and can't be supplied by the Extension Developers. Validation is a process that ensures that all contributions are well formed. They meet the requirements defined by the contribution type they are extending. Note this attribute will be updated asynchronously as the extension is validated by the developer of the contribution type. There will be restricted access to the extension while this process is performed.
     */
    Validated = 4,
    /**
     * Trusted extensions are ones that are given special capabilities. These tend to come from Microsoft and can't be published by the general public.  Note: BuiltIn extensions are always trusted.
     */
    Trusted = 8,
    /**
     * The Paid flag indicates that the commerce can be enabled for this extension. Publisher needs to setup Offer/Pricing plan in Azure. If Paid flag is set and a corresponding Offer is not available, the extension will automatically be marked as Preview. If the publisher intends to make the extension Paid in the future, it is mandatory to set the Preview flag. This is currently available only for VSTS extensions only.
     */
    Paid = 16,
    /**
     * This extension registration is public, making its visibilty open to the public. This means all tenants have the ability to install this extension. Without this flag the extension will be private and will need to be shared with the tenants that can install it.
     */
    Public = 256,
    /**
     * This extension has multiple versions active at one time and version discovery should be done usig the defined "Version Discovery" protocol to determine the version available to a specific user or tenant.  @TODO: Link to Version Discovery Protocol.
     */
    MultiVersion = 512,
    /**
     * The system flag is reserved, and cant be used by publishers.
     */
    System = 1024,
    /**
     * The Preview flag indicates that the extension is still under preview (not yet of "release" quality). These extensions may be decorated differently in the gallery and may have different policies applied to them.
     */
    Preview = 2048,
    /**
     * The Unpublished flag indicates that the extension can't be installed/downloaded. Users who have installed such an extension can continue to use the extension.
     */
    Unpublished = 4096,
    /**
     * The Trial flag indicates that the extension is in Trial version. The flag is right now being used only with respec to Visual Studio extensions.
     */
    Trial = 8192,
    /**
     * The Locked flag indicates that extension has been locked from Marketplace. Further updates/acquisitions are not allowed on the extension until this is present. This should be used along with making the extension private/unpublished.
     */
    Locked = 16384,
    /**
     * This flag is set for extensions we want to hide from Marketplace home and search pages. This will be used to override the exposure of builtIn flags.
     */
    Hidden = 32768
}
export interface Publisher extends PublisherBase {
    _links: any;
}
/**
 * Keeping base class separate since publisher DB model class and publisher contract class share these common properties
 */
export interface PublisherBase {
    displayName: string;
    emailAddress: string[];
    extensions: PublishedExtension[];
    flags: PublisherFlags;
    lastUpdated: Date;
    longDescription: string;
    publisherId: string;
    publisherName: string;
    shortDescription: string;
    state: PublisherState;
}
/**
 * High-level information about the publisher, like id's and names
 */
export interface PublisherFacts {
    displayName: string;
    flags: PublisherFlags;
    publisherId: string;
    publisherName: string;
}
/**
 * The FilterResult is the set of publishers that matched a particular query filter.
 */
export interface PublisherFilterResult {
    /**
     * This is the set of appplications that matched the query filter supplied.
     */
    publishers: Publisher[];
}
export enum PublisherFlags {
    /**
     * This should never be returned, it is used to represent a publisher who's flags havent changed during update calls.
     */
    UnChanged = 1073741824,
    /**
     * No flags exist for this publisher.
     */
    None = 0,
    /**
     * The Disabled flag for a publisher means the publisher can't be changed and won't be used by consumers, this extends to extensions owned by the publisher as well. The disabled flag is managed by the service and can't be supplied by the Extension Developers.
     */
    Disabled = 1,
    /**
     * A verified publisher is one that Microsoft has done some review of and ensured the publisher meets a set of requirements. The requirements to become a verified publisher are not listed here.  They can be found in public documentation (TBD).
     */
    Verified = 2,
    /**
     * A Certified publisher is one that is Microsoft verified and in addition meets a set of requirements for its published extensions. The requirements to become a certified publisher are not listed here.  They can be found in public documentation (TBD).
     */
    Certified = 4,
    /**
     * This is the set of flags that can't be supplied by the developer and is managed by the service itself.
     */
    ServiceFlags = 7
}
export enum PublisherPermissions {
    /**
     * This gives the bearer the rights to read Publishers and Extensions.
     */
    Read = 1,
    /**
     * This gives the bearer the rights to update, delete, and share Extensions (but not the ability to create them).
     */
    UpdateExtension = 2,
    /**
     * This gives the bearer the rights to create new Publishers at the root of the namespace.
     */
    CreatePublisher = 4,
    /**
     * This gives the bearer the rights to create new Extensions within a publisher.
     */
    PublishExtension = 8,
    /**
     * Admin gives the bearer the rights to manage restricted attributes of Publishers and Extensions.
     */
    Admin = 16,
    /**
     * TrustedPartner gives the bearer the rights to publish a extensions with restricted capabilities.
     */
    TrustedPartner = 32,
    /**
     * PrivateRead is another form of read designed to allow higher privilege accessors the ability to read private extensions.
     */
    PrivateRead = 64,
    /**
     * This gives the bearer the rights to delete any extension.
     */
    DeleteExtension = 128,
    /**
     * This gives the bearer the rights edit the publisher settings.
     */
    EditSettings = 256,
    /**
     * This gives the bearer the rights to see all permissions on the publisher.
     */
    ViewPermissions = 512,
    /**
     * This gives the bearer the rights to assign permissions on the publisher.
     */
    ManagePermissions = 1024,
    /**
     * This gives the bearer the rights to delete the publisher.
     */
    DeletePublisher = 2048
}
/**
 * An PublisherQuery is used to search the gallery for a set of publishers that match one of many filter values.
 */
export interface PublisherQuery {
    /**
     * Each filter is a unique query and will have matching set of publishers returned from the request. Each result will have the same index in the resulting array that the filter had in the incoming query.
     */
    filters: QueryFilter[];
    /**
     * The Flags are used to deterine which set of information the caller would like returned for the matched publishers.
     */
    flags: PublisherQueryFlags;
}
/**
 * Set of flags used to define the attributes requested when a publisher is returned. Some API's allow the caller to specify the level of detail needed.
 */
export enum PublisherQueryFlags {
    /**
     * None is used to retrieve only the basic publisher details.
     */
    None = 0,
    /**
     * Is used to include a list of basic extension details for all extensions published by the requested publisher.
     */
    IncludeExtensions = 1,
    /**
     * Is used to include email address of all the users who are marked as owners for the publisher
     */
    IncludeEmailAddress = 2
}
/**
 * This is the set of publishers that matched a supplied query through the filters given.
 */
export interface PublisherQueryResult {
    /**
     * For each filter supplied in the query, a filter result will be returned in the query result.
     */
    results: PublisherFilterResult[];
}
export enum PublisherState {
    /**
     * No state exists for this publisher.
     */
    None = 0,
    /**
     * This state indicates that publisher has applied for Marketplace verification (via UI) and still not been certified. This state would be reset once the publisher is verified.
     */
    VerificationPending = 1,
    /**
     * This state indicates that publisher has applied for Marketplace certification (via UI) and still not been certified. This state would be reset once the publisher is certified.
     */
    CertificationPending = 2,
    /**
     * This state indicates that publisher had applied for Marketplace certification (via UI) but his/her certification got rejected. This state would be reset if and when the publisher is certified.
     */
    CertificationRejected = 4,
    /**
     * This state indicates that publisher was certified on the Marketplace, but his/her certification got revoked. This state would never be reset, even after publisher gets re-certified. It would indicate that the publisher certification was revoked at least once.
     */
    CertificationRevoked = 8
}
/**
 * The core structure of a QnA item
 */
export interface QnAItem {
    /**
     * Time when the review was first created
     */
    createdDate: Date;
    /**
     * Unique identifier of a QnA item
     */
    id: number;
    /**
     * Get status of item
     */
    status: QnAItemStatus;
    /**
     * Text description of the QnA item
     */
    text: string;
    /**
     * Time when the review was edited/updated
     */
    updatedDate: Date;
    /**
     * User details for the item.
     */
    user: UserIdentityRef;
}
/**
 * Denotes the status of the QnA Item
 */
export enum QnAItemStatus {
    None = 0,
    /**
     * The UserEditable flag indicates whether the item is editable by the logged in user.
     */
    UserEditable = 1,
    /**
     * The PublisherCreated flag indicates whether the item has been created by extension publisher.
     */
    PublisherCreated = 2
}
/**
 * A filter used to define a set of extensions to return during a query.
 */
export interface QueryFilter {
    /**
     * The filter values define the set of values in this query. They are applied based on the QueryFilterType.
     */
    criteria: FilterCriteria[];
    /**
     * The PagingDirection is applied to a paging token if one exists. If not the direction is ignored, and Forward from the start of the resultset is used. Direction should be left out of the request unless a paging token is used to help prevent future issues.
     */
    direction: PagingDirection;
    /**
     * The page number requested by the user. If not provided 1 is assumed by default.
     */
    pageNumber: number;
    /**
     * The page size defines the number of results the caller wants for this filter. The count can't exceed the overall query size limits.
     */
    pageSize: number;
    /**
     * The paging token is a distinct type of filter and the other filter fields are ignored. The paging token represents the continuation of a previously executed query. The information about where in the result and what fields are being filtered are embeded in the token.
     */
    pagingToken: string;
    /**
     * Defines the type of sorting to be applied on the results. The page slice is cut of the sorted results only.
     */
    sortBy: number;
    /**
     * Defines the order of sorting, 1 for Ascending, 2 for Descending, else default ordering based on the SortBy value
     */
    sortOrder: number;
}
/**
 * The structure of the question / thread
 */
export interface Question extends QnAItem {
    /**
     * List of answers in for the question / thread
     */
    responses: Response[];
}
export interface QuestionsResult {
    /**
     * Flag indicating if there are more QnA threads to be shown (for paging)
     */
    hasMoreQuestions: boolean;
    /**
     * List of the QnA threads
     */
    questions: Question[];
}
export interface RatingCountPerRating {
    /**
     * Rating value
     */
    rating: number;
    /**
     * Count of total ratings
     */
    ratingCount: number;
}
/**
 * The structure of a response
 */
export interface Response extends QnAItem {
}
/**
 * The status of a REST Api response status.
 */
export enum RestApiResponseStatus {
    /**
     * The operation is completed.
     */
    Completed = 0,
    /**
     * The operation is failed.
     */
    Failed = 1,
    /**
     * The operation is in progress.
     */
    Inprogress = 2,
    /**
     * The operation is in skipped.
     */
    Skipped = 3
}
/**
 * REST Api Response
 */
export interface RestApiResponseStatusModel {
    /**
     * Gets or sets the operation details
     */
    operationDetails: any;
    /**
     * Gets or sets the operation id
     */
    operationId: string;
    /**
     * Gets or sets the completed status percentage
     */
    percentageCompleted: number;
    /**
     * Gets or sets the status
     */
    status: RestApiResponseStatus;
    /**
     * Gets or sets the status message
     */
    statusMessage: string;
}
export interface Review {
    /**
     * Admin Reply, if any, for this review
     */
    adminReply: ReviewReply;
    /**
     * Unique identifier of a review item
     */
    id: number;
    /**
     * Flag for soft deletion
     */
    isDeleted: boolean;
    isIgnored: boolean;
    /**
     * Version of the product for which review was submitted
     */
    productVersion: string;
    /**
     * Rating procided by the user
     */
    rating: number;
    /**
     * Reply, if any, for this review
     */
    reply: ReviewReply;
    /**
     * Text description of the review
     */
    text: string;
    /**
     * Title of the review
     */
    title: string;
    /**
     * Time when the review was edited/updated
     */
    updatedDate: Date;
    /**
     * Name of the user
     */
    userDisplayName: string;
    /**
     * Id of the user who submitted the review
     */
    userId: string;
}
/**
 * Type of operation
 */
export enum ReviewEventOperation {
    Create = 1,
    Update = 2,
    Delete = 3
}
/**
 * Properties associated with Review event
 */
export interface ReviewEventProperties {
    /**
     * Operation performed on Event - Create\Update
     */
    eventOperation: ReviewEventOperation;
    /**
     * Flag to see if reply is admin reply
     */
    isAdminReply: boolean;
    /**
     * Flag to record if the reviwe is ignored
     */
    isIgnored: boolean;
    /**
     * Rating at the time of event
     */
    rating: number;
    /**
     * Reply update date
     */
    replyDate: Date;
    /**
     * Publisher reply text or admin reply text
     */
    replyText: string;
    /**
     * User who responded to the review
     */
    replyUserId: string;
    /**
     * Review Event Type - Review
     */
    resourceType: ReviewResourceType;
    /**
     * Review update date
     */
    reviewDate: Date;
    /**
     * ReviewId of the review  on which the operation is performed
     */
    reviewId: number;
    /**
     * Text in Review Text
     */
    reviewText: string;
    /**
     * User display name at the time of review
     */
    userDisplayName: string;
    /**
     * User who gave review
     */
    userId: string;
}
/**
 * Options to GetReviews query
 */
export enum ReviewFilterOptions {
    /**
     * No filtering, all reviews are returned (default option)
     */
    None = 0,
    /**
     * Filter out review items with empty review text
     */
    FilterEmptyReviews = 1,
    /**
     * Filter out review items with empty usernames
     */
    FilterEmptyUserNames = 2
}
export interface ReviewPatch {
    /**
     * Denotes the patch operation type
     */
    operation: ReviewPatchOperation;
    /**
     * Use when patch operation is FlagReview
     */
    reportedConcern: UserReportedConcern;
    /**
     * Use when patch operation is EditReview
     */
    reviewItem: Review;
}
/**
 * Denotes the patch operation type
 */
export enum ReviewPatchOperation {
    /**
     * Flag a review
     */
    FlagReview = 1,
    /**
     * Update an existing review
     */
    UpdateReview = 2,
    /**
     * Submit a reply for a review
     */
    ReplyToReview = 3,
    /**
     * Submit an admin response
     */
    AdminResponseForReview = 4,
    /**
     * Delete an Admin Reply
     */
    DeleteAdminReply = 5,
    /**
     * Delete Publisher Reply
     */
    DeletePublisherReply = 6
}
export interface ReviewReply {
    /**
     * Id of the reply
     */
    id: number;
    /**
     * Flag for soft deletion
     */
    isDeleted: boolean;
    /**
     * Version of the product when the reply was submitted or updated
     */
    productVersion: string;
    /**
     * Content of the reply
     */
    replyText: string;
    /**
     * Id of the review, to which this reply belongs
     */
    reviewId: number;
    /**
     * Title of the reply
     */
    title: string;
    /**
     * Date the reply was submitted or updated
     */
    updatedDate: Date;
    /**
     * Id of the user who left the reply
     */
    userId: string;
}
/**
 * Type of event
 */
export enum ReviewResourceType {
    Review = 1,
    PublisherReply = 2,
    AdminReply = 3
}
export interface ReviewsResult {
    /**
     * Flag indicating if there are more reviews to be shown (for paging)
     */
    hasMoreReviews: boolean;
    /**
     * List of reviews
     */
    reviews: Review[];
    /**
     * Count of total review items
     */
    totalReviewCount: number;
}
export interface ReviewSummary {
    /**
     * Average Rating
     */
    averageRating: number;
    /**
     * Count of total ratings
     */
    ratingCount: number;
    /**
     * Split of count accross rating
     */
    ratingSplit: RatingCountPerRating[];
}
/**
 * Defines the sort order that can be defined for Extensions query
 */
export enum SortByType {
    /**
     * The results will be sorted by relevance in case search query is given, if no search query resutls will be provided as is
     */
    Relevance = 0,
    /**
     * The results will be sorted as per Last Updated date of the extensions with recently updated at the top
     */
    LastUpdatedDate = 1,
    /**
     * Results will be sorted Alphabetically as per the title of the extension
     */
    Title = 2,
    /**
     * Results will be sorted Alphabetically as per Publisher title
     */
    Publisher = 3,
    /**
     * Results will be sorted by Install Count
     */
    InstallCount = 4,
    /**
     * The results will be sorted as per Published date of the extensions
     */
    PublishedDate = 5,
    /**
     * The results will be sorted as per Average ratings of the extensions
     */
    AverageRating = 6,
    /**
     * The results will be sorted as per Trending Daily Score of the extensions
     */
    TrendingDaily = 7,
    /**
     * The results will be sorted as per Trending weekly Score of the extensions
     */
    TrendingWeekly = 8,
    /**
     * The results will be sorted as per Trending monthly Score of the extensions
     */
    TrendingMonthly = 9,
    /**
     * The results will be sorted as per ReleaseDate of the extensions (date on which the extension first went public)
     */
    ReleaseDate = 10,
    /**
     * The results will be sorted as per Author defined in the VSix/Metadata. If not defined, publisher name is used This is specifically needed by VS IDE, other (new and old) clients are not encouraged to use this
     */
    Author = 11,
    /**
     * The results will be sorted as per Weighted Rating of the extension.
     */
    WeightedRating = 12
}
/**
 * Defines the sort order that can be defined for Extensions query
 */
export enum SortOrderType {
    /**
     * Results will be sorted in the default order as per the sorting type defined. The default varies for each type, e.g. for Relevance, default is Descnding, for Title default is Ascending etc.
     */
    Default = 0,
    /**
     * The results will be sorted in Ascending order
     */
    Ascending = 1,
    /**
     * The results will be sorted in Descending order
     */
    Descending = 2
}
export interface UnpackagedExtensionData {
    categories: string[];
    description: string;
    displayName: string;
    draftId: string;
    extensionName: string;
    installationTargets: InstallationTarget[];
    isConvertedToMarkdown: boolean;
    pricingCategory: string;
    product: string;
    publisherName: string;
    qnAEnabled: boolean;
    referralUrl: string;
    repositoryUrl: string;
    tags: string[];
    version: string;
    vsixId: string;
}
/**
 * Represents the extension policy applied to a given user
 */
export interface UserExtensionPolicy {
    /**
     * User display name that this policy refers to
     */
    displayName: string;
    /**
     * The extension policy applied to the user
     */
    permissions: ExtensionPolicy;
    /**
     * User id that this policy refers to
     */
    userId: string;
}
/**
 * Identity reference with name and guid
 */
export interface UserIdentityRef {
    /**
     * User display name
     */
    displayName: string;
    /**
     * User VSID
     */
    id: string;
}
export interface UserReportedConcern {
    /**
     * Category of the concern
     */
    category: ConcernCategory;
    /**
     * User comment associated with the report
     */
    concernText: string;
    /**
     * Id of the review which was reported
     */
    reviewId: number;
    /**
     * Date the report was submitted
     */
    submittedDate: Date;
    /**
     * Id of the user who reported a review
     */
    userId: string;
}
export var TypeInfo: {
    AcquisitionAssignmentType: {
        enumValues: {
            "none": number;
            "me": number;
            "all": number;
        };
    };
    AcquisitionOperation: any;
    AcquisitionOperationState: {
        enumValues: {
            "disallow": number;
            "allow": number;
            "completed": number;
        };
    };
    AcquisitionOperationType: {
        enumValues: {
            "get": number;
            "install": number;
            "buy": number;
            "try": number;
            "request": number;
            "none": number;
            "purchaseRequest": number;
        };
    };
    AcquisitionOptions: any;
    AzureRestApiResponseModel: any;
    Concern: any;
    ConcernCategory: {
        enumValues: {
            "general": number;
            "abusive": number;
            "spam": number;
        };
    };
    CustomerLastContact: any;
    DraftPatchOperation: {
        enumValues: {
            "publish": number;
            "cancel": number;
        };
    };
    DraftStateType: {
        enumValues: {
            "unpublished": number;
            "published": number;
            "cancelled": number;
            "error": number;
        };
    };
    ExtensionAcquisitionRequest: any;
    ExtensionDailyStat: any;
    ExtensionDailyStats: any;
    ExtensionDeploymentTechnology: {
        enumValues: {
            "exe": number;
            "msi": number;
            "vsix": number;
            "referralLink": number;
        };
    };
    ExtensionDraft: any;
    ExtensionDraftPatch: any;
    ExtensionEvent: any;
    ExtensionEvents: any;
    ExtensionFilterResult: any;
    ExtensionLifecycleEventType: {
        enumValues: {
            "uninstall": number;
            "install": number;
            "review": number;
            "acquisition": number;
            "sales": number;
            "other": number;
        };
    };
    ExtensionPayload: any;
    ExtensionPolicy: any;
    ExtensionPolicyFlags: {
        enumValues: {
            "none": number;
            "private": number;
            "public": number;
            "preview": number;
            "released": number;
            "firstParty": number;
            "all": number;
        };
    };
    ExtensionQuery: any;
    ExtensionQueryFilterType: {
        enumValues: {
            "tag": number;
            "displayName": number;
            "private": number;
            "id": number;
            "category": number;
            "contributionType": number;
            "name": number;
            "installationTarget": number;
            "featured": number;
            "searchText": number;
            "featuredInCategory": number;
            "excludeWithFlags": number;
            "includeWithFlags": number;
            "lcid": number;
            "installationTargetVersion": number;
            "installationTargetVersionRange": number;
            "vsixMetadata": number;
            "publisherName": number;
            "publisherDisplayName": number;
            "includeWithPublisherFlags": number;
            "organizationSharedWith": number;
        };
    };
    ExtensionQueryFlags: {
        enumValues: {
            "none": number;
            "includeVersions": number;
            "includeFiles": number;
            "includeCategoryAndTags": number;
            "includeSharedAccounts": number;
            "includeVersionProperties": number;
            "excludeNonValidated": number;
            "includeInstallationTargets": number;
            "includeAssetUri": number;
            "includeStatistics": number;
            "includeLatestVersionOnly": number;
            "useFallbackAssetUri": number;
            "includeMetadata": number;
            "includeMinimalPayloadForVsIde": number;
            "includeLcids": number;
            "includeSharedOrganizations": number;
            "allAttributes": number;
        };
    };
    ExtensionQueryResult: any;
    ExtensionStatisticOperation: {
        enumValues: {
            "none": number;
            "set": number;
            "increment": number;
            "decrement": number;
            "delete": number;
        };
    };
    ExtensionStatisticUpdate: any;
    ExtensionStatsAggregateType: {
        enumValues: {
            "daily": number;
        };
    };
    ExtensionVersion: any;
    ExtensionVersionFlags: {
        enumValues: {
            "none": number;
            "validated": number;
        };
    };
    NotificationsData: any;
    NotificationTemplateType: {
        enumValues: {
            "reviewNotification": number;
            "qnaNotification": number;
            "customerContactNotification": number;
            "publisherMemberUpdateNotification": number;
        };
    };
    PagingDirection: {
        enumValues: {
            "backward": number;
            "forward": number;
        };
    };
    PublishedExtension: any;
    PublishedExtensionFlags: {
        enumValues: {
            "none": number;
            "disabled": number;
            "builtIn": number;
            "validated": number;
            "trusted": number;
            "paid": number;
            "public": number;
            "multiVersion": number;
            "system": number;
            "preview": number;
            "unpublished": number;
            "trial": number;
            "locked": number;
            "hidden": number;
        };
    };
    Publisher: any;
    PublisherBase: any;
    PublisherFacts: any;
    PublisherFilterResult: any;
    PublisherFlags: {
        enumValues: {
            "unChanged": number;
            "none": number;
            "disabled": number;
            "verified": number;
            "certified": number;
            "serviceFlags": number;
        };
    };
    PublisherPermissions: {
        enumValues: {
            "read": number;
            "updateExtension": number;
            "createPublisher": number;
            "publishExtension": number;
            "admin": number;
            "trustedPartner": number;
            "privateRead": number;
            "deleteExtension": number;
            "editSettings": number;
            "viewPermissions": number;
            "managePermissions": number;
            "deletePublisher": number;
        };
    };
    PublisherQuery: any;
    PublisherQueryFlags: {
        enumValues: {
            "none": number;
            "includeExtensions": number;
            "includeEmailAddress": number;
        };
    };
    PublisherQueryResult: any;
    PublisherState: {
        enumValues: {
            "none": number;
            "verificationPending": number;
            "certificationPending": number;
            "certificationRejected": number;
            "certificationRevoked": number;
        };
    };
    QnAItem: any;
    QnAItemStatus: {
        enumValues: {
            "none": number;
            "userEditable": number;
            "publisherCreated": number;
        };
    };
    QueryFilter: any;
    Question: any;
    QuestionsResult: any;
    Response: any;
    RestApiResponseStatus: {
        enumValues: {
            "completed": number;
            "failed": number;
            "inprogress": number;
            "skipped": number;
        };
    };
    RestApiResponseStatusModel: any;
    Review: any;
    ReviewEventOperation: {
        enumValues: {
            "create": number;
            "update": number;
            "delete": number;
        };
    };
    ReviewEventProperties: any;
    ReviewFilterOptions: {
        enumValues: {
            "none": number;
            "filterEmptyReviews": number;
            "filterEmptyUserNames": number;
        };
    };
    ReviewPatch: any;
    ReviewPatchOperation: {
        enumValues: {
            "flagReview": number;
            "updateReview": number;
            "replyToReview": number;
            "adminResponseForReview": number;
            "deleteAdminReply": number;
            "deletePublisherReply": number;
        };
    };
    ReviewReply: any;
    ReviewResourceType: {
        enumValues: {
            "review": number;
            "publisherReply": number;
            "adminReply": number;
        };
    };
    ReviewsResult: any;
    SortByType: {
        enumValues: {
            "relevance": number;
            "lastUpdatedDate": number;
            "title": number;
            "publisher": number;
            "installCount": number;
            "publishedDate": number;
            "averageRating": number;
            "trendingDaily": number;
            "trendingWeekly": number;
            "trendingMonthly": number;
            "releaseDate": number;
            "author": number;
            "weightedRating": number;
        };
    };
    SortOrderType: {
        enumValues: {
            "default": number;
            "ascending": number;
            "descending": number;
        };
    };
    UserExtensionPolicy: any;
    UserReportedConcern: any;
};
}
declare module "VSS/Gallery/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   gallery\client\webapi\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Gallery/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected accountsApiVersion: string;
    protected accountsbynameApiVersion: string;
    protected assetbynameApiVersion: string;
    protected assetsApiVersion: string;
    protected categoriesApiVersion: string;
    protected categoriesApiVersion_e0a5a71e: string;
    protected certificatesApiVersion: string;
    protected extensionqueryApiVersion: string;
    protected extensionsApiVersion: string;
    protected extensionsApiVersion_a41192c8: string;
    protected packageApiVersion: string;
    protected privateassetApiVersion: string;
    protected publisherqueryApiVersion: string;
    protected publishersApiVersion: string;
    protected signingkeyApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} keyType
     * @return IPromise<string>
     */
    getSigningKey(keyType: string): IPromise<string>;
    /**
     * [Preview API]
     *
     * @param {string} keyType
     * @param {number} expireCurrentSeconds
     * @return IPromise<void>
     */
    generateKey(keyType: string, expireCurrentSeconds?: number): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.Publisher} publisher
     * @param {string} publisherName
     * @return IPromise<Contracts.Publisher>
     */
    updatePublisher(publisher: Contracts.Publisher, publisherName: string): IPromise<Contracts.Publisher>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {number} flags
     * @return IPromise<Contracts.Publisher>
     */
    getPublisher(publisherName: string, flags?: number): IPromise<Contracts.Publisher>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @return IPromise<void>
     */
    deletePublisher(publisherName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.Publisher} publisher
     * @return IPromise<Contracts.Publisher>
     */
    createPublisher(publisher: Contracts.Publisher): IPromise<Contracts.Publisher>;
    /**
     * [Preview API]
     *
     * @param {Contracts.PublisherQuery} publisherQuery
     * @return IPromise<Contracts.PublisherQueryResult>
     */
    queryPublishers(publisherQuery: Contracts.PublisherQuery): IPromise<Contracts.PublisherQueryResult>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @param {string} assetType
     * @param {string} assetToken
     * @param {string} accountToken
     * @param {boolean} acceptDefault
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<ArrayBuffer>
     */
    getAssetWithToken(publisherName: string, extensionName: string, version: string, assetType: string, assetToken?: string, accountToken?: string, acceptDefault?: boolean, accountTokenHeader?: String): IPromise<ArrayBuffer>;
    /**
     * [Preview API] This endpoint gets hit when you download a VSTS extension from the Web UI
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @param {string} accountToken
     * @param {boolean} acceptDefault
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<ArrayBuffer>
     */
    getPackage(publisherName: string, extensionName: string, version: string, accountToken?: string, acceptDefault?: boolean, accountTokenHeader?: String): IPromise<ArrayBuffer>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {Contracts.PublishedExtensionFlags} flags
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionProperties(publisherName: string, extensionName: string, flags: Contracts.PublishedExtensionFlags): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @param {Contracts.ExtensionQueryFlags} flags
     * @param {string} accountToken
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<Contracts.PublishedExtension>
     */
    getExtension(publisherName: string, extensionName: string, version?: string, flags?: Contracts.ExtensionQueryFlags, accountToken?: string, accountTokenHeader?: String): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @return IPromise<void>
     */
    deleteExtension(publisherName: string, extensionName: string, version?: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @param {string} version
     * @param {Contracts.ExtensionQueryFlags} flags
     * @return IPromise<Contracts.PublishedExtension>
     */
    getExtensionById(extensionId: string, version?: string, flags?: Contracts.ExtensionQueryFlags): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @param {string} version
     * @return IPromise<void>
     */
    deleteExtensionById(extensionId: string, version?: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionQuery} extensionQuery
     * @param {string} accountToken
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<Contracts.ExtensionQueryResult>
     */
    queryExtensions(extensionQuery: Contracts.ExtensionQuery, accountToken?: string, accountTokenHeader?: String): IPromise<Contracts.ExtensionQueryResult>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @return IPromise<ArrayBuffer>
     */
    getCertificate(publisherName: string, extensionName: string, version?: string): IPromise<ArrayBuffer>;
    /**
     * [Preview API]
     *
     * @param {string} categoryName
     * @param {string} languages
     * @param {string} product
     * @return IPromise<Contracts.CategoriesResult>
     */
    getCategoryDetails(categoryName: string, languages?: string, product?: string): IPromise<Contracts.CategoriesResult>;
    /**
     * [Preview API]
     *
     * @param {string} languages
     * @return IPromise<string[]>
     */
    getCategories(languages?: string): IPromise<string[]>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @param {string} version
     * @param {string} assetType
     * @param {string} accountToken
     * @param {boolean} acceptDefault
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<ArrayBuffer>
     */
    getAsset(extensionId: string, version: string, assetType: string, accountToken?: string, acceptDefault?: boolean, accountTokenHeader?: String): IPromise<ArrayBuffer>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @param {string} assetType
     * @param {string} accountToken
     * @param {boolean} acceptDefault
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<ArrayBuffer>
     */
    getAssetByName(publisherName: string, extensionName: string, version: string, assetType: string, accountToken?: string, acceptDefault?: boolean, accountTokenHeader?: String): IPromise<ArrayBuffer>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} accountName
     * @return IPromise<void>
     */
    unshareExtension(publisherName: string, extensionName: string, accountName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} accountName
     * @return IPromise<void>
     */
    shareExtension(publisherName: string, extensionName: string, accountName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @param {string} accountName
     * @return IPromise<void>
     */
    unshareExtensionById(extensionId: string, accountName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @param {string} accountName
     * @return IPromise<void>
     */
    shareExtensionById(extensionId: string, accountName: string): IPromise<void>;
}
export class CommonMethods2_1To5 extends CommonMethods2To5 {
    protected acquisitionrequestsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionAcquisitionRequest} acquisitionRequest
     * @return IPromise<Contracts.ExtensionAcquisitionRequest>
     */
    requestAcquisition(acquisitionRequest: Contracts.ExtensionAcquisitionRequest): IPromise<Contracts.ExtensionAcquisitionRequest>;
}
export class CommonMethods2_2To5 extends CommonMethods2_1To5 {
    protected acquisitionoptionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} itemId
     * @param {string} installationTarget
     * @param {boolean} testCommerce
     * @param {boolean} isFreeOrTrialInstall
     * @return IPromise<Contracts.AcquisitionOptions>
     */
    getAcquisitionOptions(itemId: string, installationTarget: string, testCommerce?: boolean, isFreeOrTrialInstall?: boolean): IPromise<Contracts.AcquisitionOptions>;
}
export class CommonMethods3To5 extends CommonMethods2_2To5 {
    protected authenticatedassetApiVersion: string;
    protected azurepublisherApiVersion: string;
    protected extensionValidatorApiVersion: string;
    protected reviewsApiVersion: string;
    protected reviewsApiVersion_5b3f819f: string;
    protected securedCategoriesApiVersion: string;
    protected statisticsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionStatisticUpdate} extensionStatisticsUpdate
     * @param {string} publisherName
     * @param {string} extensionName
     * @return IPromise<void>
     */
    updateExtensionStatistics(extensionStatisticsUpdate: Contracts.ExtensionStatisticUpdate, publisherName: string, extensionName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionCategory} category
     * @return IPromise<Contracts.ExtensionCategory>
     */
    createCategory(category: Contracts.ExtensionCategory): IPromise<Contracts.ExtensionCategory>;
    /**
     * [Preview API] Updates or Flags a review
     *
     * @param {Contracts.ReviewPatch} reviewPatch - ReviewPatch object which contains the changes to be applied to the review
     * @param {string} pubName - Name of the pubilsher who published the extension
     * @param {string} extName - Name of the extension
     * @param {number} reviewId - Id of the review which needs to be updated
     * @return IPromise<Contracts.ReviewPatch>
     */
    updateReview(reviewPatch: Contracts.ReviewPatch, pubName: string, extName: string, reviewId: number): IPromise<Contracts.ReviewPatch>;
    /**
     * [Preview API] Deletes a review
     *
     * @param {string} pubName - Name of the pubilsher who published the extension
     * @param {string} extName - Name of the extension
     * @param {number} reviewId - Id of the review which needs to be updated
     * @return IPromise<void>
     */
    deleteReview(pubName: string, extName: string, reviewId: number): IPromise<void>;
    /**
     * [Preview API] Creates a new review for an extension
     *
     * @param {Contracts.Review} review - Review to be created for the extension
     * @param {string} pubName - Name of the publisher who published the extension
     * @param {string} extName - Name of the extension
     * @return IPromise<Contracts.Review>
     */
    createReview(review: Contracts.Review, pubName: string, extName: string): IPromise<Contracts.Review>;
    /**
     * [Preview API] Returns a list of reviews associated with an extension
     *
     * @param {string} publisherName - Name of the publisher who published the extension
     * @param {string} extensionName - Name of the extension
     * @param {number} count - Number of reviews to retrieve (defaults to 5)
     * @param {Contracts.ReviewFilterOptions} filterOptions - FilterOptions to filter out empty reviews etcetera, defaults to none
     * @param {Date} beforeDate - Use if you want to fetch reviews older than the specified date, defaults to null
     * @param {Date} afterDate - Use if you want to fetch reviews newer than the specified date, defaults to null
     * @return IPromise<Contracts.ReviewsResult>
     */
    getReviews(publisherName: string, extensionName: string, count?: number, filterOptions?: Contracts.ReviewFilterOptions, beforeDate?: Date, afterDate?: Date): IPromise<Contracts.ReviewsResult>;
    /**
     * [Preview API]
     *
     * @param {Contracts.AzureRestApiRequestModel} azureRestApiRequestModel
     * @return IPromise<void>
     */
    extensionValidator(azureRestApiRequestModel: Contracts.AzureRestApiRequestModel): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @return IPromise<Contracts.AzurePublisher>
     */
    queryAssociatedAzurePublisher(publisherName: string): IPromise<Contracts.AzurePublisher>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} azurePublisherId
     * @return IPromise<Contracts.AzurePublisher>
     */
    associateAzurePublisher(publisherName: string, azurePublisherId: string): IPromise<Contracts.AzurePublisher>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @param {string} assetType
     * @param {string} accountToken
     * @param {String} accountTokenHeader - Header to pass the account token
     * @return IPromise<ArrayBuffer>
     */
    getAssetAuthenticated(publisherName: string, extensionName: string, version: string, assetType: string, accountToken?: string, accountTokenHeader?: String): IPromise<ArrayBuffer>;
}
export class CommonMethods3_1To5 extends CommonMethods3To5 {
    protected categoriesApiVersion_1102bb42: string;
    protected categoriesApiVersion_31fba831: string;
    protected eventsApiVersion: string;
    protected eventsApiVersion_3d13c499: string;
    protected reportsApiVersion: string;
    protected settingsApiVersion: string;
    protected statsApiVersion: string;
    protected statsApiVersion_ae06047e: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Increments a daily statistic associated with the extension
     *
     * @param {string} publisherName - Name of the publisher
     * @param {string} extensionName - Name of the extension
     * @param {string} version - Version of the extension
     * @param {string} statType - Type of stat to increment
     * @return IPromise<void>
     */
    incrementExtensionDailyStat(publisherName: string, extensionName: string, version: string, statType: string): IPromise<void>;
    /**
     * [Preview API] This route/location id only supports HTTP POST anonymously, so that the page view daily stat can be incremented from Marketplace client. Trying to call GET on this route should result in an exception. Without this explicit implementation, calling GET on this public route invokes the above GET implementation GetExtensionDailyStats.
     *
     * @param {string} publisherName - Name of the publisher
     * @param {string} extensionName - Name of the extension
     * @param {string} version - Version of the extension
     * @return IPromise<Contracts.ExtensionDailyStats>
     */
    getExtensionDailyStatsAnonymous(publisherName: string, extensionName: string, version: string): IPromise<Contracts.ExtensionDailyStats>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {number} days
     * @param {Contracts.ExtensionStatsAggregateType} aggregate
     * @param {Date} afterDate
     * @return IPromise<Contracts.ExtensionDailyStats>
     */
    getExtensionDailyStats(publisherName: string, extensionName: string, days?: number, aggregate?: Contracts.ExtensionStatsAggregateType, afterDate?: Date): IPromise<Contracts.ExtensionDailyStats>;
    /**
     * [Preview API] Set all setting entries for the given user/all-users scope
     *
     * @param {{ [key: string] : any; }} entries - A key-value pair of all settings that need to be set
     * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
     * @return IPromise<void>
     */
    setGalleryUserSettings(entries: {
        [key: string]: any;
    }, userScope: string): IPromise<void>;
    /**
     * [Preview API] Get all setting entries for the given user/all-users scope
     *
     * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
     * @param {string} key - Optional key under which to filter all the entries
     * @return IPromise<{ [key: string] : any; }>
     */
    getGalleryUserSettings(userScope: string, key?: string): IPromise<{
        [key: string]: any;
    }>;
    /**
     * [Preview API] Returns extension reports
     *
     * @param {string} publisherName - Name of the publisher who published the extension
     * @param {string} extensionName - Name of the extension
     * @param {number} days - Last n days report. If afterDate and days are specified, days will take priority
     * @param {number} count - Number of events to be returned
     * @param {Date} afterDate - Use if you want to fetch events newer than the specified date
     * @return IPromise<any>
     */
    getExtensionReports(publisherName: string, extensionName: string, days?: number, count?: number, afterDate?: Date): IPromise<any>;
    /**
     * [Preview API] API endpoint to publish extension install/uninstall events. This is meant to be invoked by EMS only for sending us data related to install/uninstall of an extension.
     *
     * @param {Contracts.ExtensionEvents[]} extensionEvents
     * @return IPromise<void>
     */
    publishExtensionEvents(extensionEvents: Contracts.ExtensionEvents[]): IPromise<void>;
    /**
     * [Preview API] Get install/uninstall events of an extension. If both count and afterDate parameters are specified, count takes precedence.
     *
     * @param {string} publisherName - Name of the publisher
     * @param {string} extensionName - Name of the extension
     * @param {number} count - Count of events to fetch, applies to each event type.
     * @param {Date} afterDate - Fetch events that occurred on or after this date
     * @param {string} include - Filter options. Supported values: install, uninstall, review, acquisition, sales. Default is to fetch all types of events
     * @param {string} includeProperty - Event properties to include. Currently only 'lastContactDetails' is supported for uninstall events
     * @return IPromise<Contracts.ExtensionEvents>
     */
    getExtensionEvents(publisherName: string, extensionName: string, count?: number, afterDate?: Date, include?: string, includeProperty?: string): IPromise<Contracts.ExtensionEvents>;
    /**
     * [Preview API]
     *
     * @param {string} product
     * @param {number} lcid
     * @param {string} source
     * @param {string} productVersion
     * @param {string} skus
     * @param {string} subSkus
     * @return IPromise<Contracts.ProductCategoriesResult>
     */
    getRootCategories(product: string, lcid?: number, source?: string, productVersion?: string, skus?: string, subSkus?: string): IPromise<Contracts.ProductCategoriesResult>;
    /**
     * [Preview API]
     *
     * @param {string} product
     * @param {string} categoryId
     * @param {number} lcid
     * @param {string} source
     * @param {string} productVersion
     * @param {string} skus
     * @param {string} subSkus
     * @return IPromise<Contracts.ProductCategory>
     */
    getCategoryTree(product: string, categoryId: string, lcid?: number, source?: string, productVersion?: string, skus?: string, subSkus?: string): IPromise<Contracts.ProductCategory>;
}
export class CommonMethods3_2To5 extends CommonMethods3_1To5 {
    protected extensionsApiVersion: string;
    protected extensionsApiVersion_a41192c8: string;
    protected notificationsApiVersion: string;
    protected qnaApiVersion: string;
    protected qnaApiVersion_6d1d9741: string;
    protected qnaApiVersion_784910cd: string;
    protected qnaApiVersion_c010d03d: string;
    protected reviewsApiVersion_b7b44e21: string;
    protected verificationlogApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} version
     * @return IPromise<ArrayBuffer>
     */
    getVerificationLog(publisherName: string, extensionName: string, version: string): IPromise<ArrayBuffer>;
    /**
     * [Preview API] Returns a summary of the reviews
     *
     * @param {string} pubName - Name of the publisher who published the extension
     * @param {string} extName - Name of the extension
     * @param {Date} beforeDate - Use if you want to fetch summary of reviews older than the specified date, defaults to null
     * @param {Date} afterDate - Use if you want to fetch summary of reviews newer than the specified date, defaults to null
     * @return IPromise<Contracts.ReviewSummary>
     */
    getReviewsSummary(pubName: string, extName: string, beforeDate?: Date, afterDate?: Date): IPromise<Contracts.ReviewSummary>;
    /**
     * [Preview API] Updates an existing response for a given question for an extension.
     *
     * @param {Contracts.Response} response - Updated response to be set for the extension.
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @param {number} questionId - Identifier of the question for which response is to be updated for the extension.
     * @param {number} responseId - Identifier of the response which has to be updated.
     * @return IPromise<Contracts.Response>
     */
    updateResponse(response: Contracts.Response, publisherName: string, extensionName: string, questionId: number, responseId: number): IPromise<Contracts.Response>;
    /**
     * [Preview API] Deletes a response for an extension. (soft delete)
     *
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @param {number} questionId - Identifies the question whose response is to be deleted.
     * @param {number} responseId - Identifies the response to be deleted.
     * @return IPromise<void>
     */
    deleteResponse(publisherName: string, extensionName: string, questionId: number, responseId: number): IPromise<void>;
    /**
     * [Preview API] Creates a new response for a given question for an extension.
     *
     * @param {Contracts.Response} response - Response to be created for the extension.
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @param {number} questionId - Identifier of the question for which response is to be created for the extension.
     * @return IPromise<Contracts.Response>
     */
    createResponse(response: Contracts.Response, publisherName: string, extensionName: string, questionId: number): IPromise<Contracts.Response>;
    /**
     * [Preview API] Updates an existing question for an extension.
     *
     * @param {Contracts.Question} question - Updated question to be set for the extension.
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @param {number} questionId - Identifier of the question to be updated for the extension.
     * @return IPromise<Contracts.Question>
     */
    updateQuestion(question: Contracts.Question, publisherName: string, extensionName: string, questionId: number): IPromise<Contracts.Question>;
    /**
     * [Preview API] Deletes an existing question and all its associated responses for an extension. (soft delete)
     *
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @param {number} questionId - Identifier of the question to be deleted for the extension.
     * @return IPromise<void>
     */
    deleteQuestion(publisherName: string, extensionName: string, questionId: number): IPromise<void>;
    /**
     * [Preview API] Creates a new question for an extension.
     *
     * @param {Contracts.Question} question - Question to be created for the extension.
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @return IPromise<Contracts.Question>
     */
    createQuestion(question: Contracts.Question, publisherName: string, extensionName: string): IPromise<Contracts.Question>;
    /**
     * [Preview API] Flags a concern with an existing question for an extension.
     *
     * @param {Contracts.Concern} concern - User reported concern with a question for the extension.
     * @param {string} pubName - Name of the publisher who published the extension.
     * @param {string} extName - Name of the extension.
     * @param {number} questionId - Identifier of the question to be updated for the extension.
     * @return IPromise<Contracts.Concern>
     */
    reportQuestion(concern: Contracts.Concern, pubName: string, extName: string, questionId: number): IPromise<Contracts.Concern>;
    /**
     * [Preview API] Returns a list of questions with their responses associated with an extension.
     *
     * @param {string} publisherName - Name of the publisher who published the extension.
     * @param {string} extensionName - Name of the extension.
     * @param {number} count - Number of questions to retrieve (defaults to 10).
     * @param {number} page - Page number from which set of questions are to be retrieved.
     * @param {Date} afterDate - If provided, results questions are returned which were posted after this date
     * @return IPromise<Contracts.QuestionsResult>
     */
    getQuestions(publisherName: string, extensionName: string, count?: number, page?: number, afterDate?: Date): IPromise<Contracts.QuestionsResult>;
    /**
     * [Preview API] Send Notification
     *
     * @param {Contracts.NotificationsData} notificationData - Denoting the data needed to send notification
     * @return IPromise<void>
     */
    sendNotifications(notificationData: Contracts.NotificationsData): IPromise<void>;
    /**
     * [Preview API] REST endpoint to update an extension.
     *
     * @param {any} content - Content to upload
     * @param {string} publisherName - Name of the publisher
     * @param {string} extensionName - Name of the extension
     * @param {boolean} bypassScopeCheck - This parameter decides if the scope change check needs to be invoked or not
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(content: any, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {any} content - Content to upload
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(content: any, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {any} content - Content to upload
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(content: any): IPromise<Contracts.PublishedExtension>;
}
export class CommonMethods4_1To5 extends CommonMethods3_2To5 {
    protected contentverificationlogApiVersion: string;
    protected draftsApiVersion: string;
    protected draftsApiVersion_02b33873: string;
    protected draftsApiVersion_b3ab127d: string;
    protected draftsApiVersion_f1db9c47: string;
    protected publisherassetApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Update publisher asset like logo. It accepts asset file as an octet stream and file name is passed in header values.
     *
     * @param {any} content - Content to upload
     * @param {string} publisherName - Internal name of the publisher
     * @param {string} assetType - Type of asset. Default value is 'logo'.
     * @param {String} fileName - Header to pass the filename of the uploaded data
     * @return IPromise<{ [key: string] : string; }>
     */
    updatePublisherAsset(content: any, publisherName: string, assetType?: string, fileName?: String): IPromise<{
        [key: string]: string;
    }>;
    /**
     * [Preview API] Get publisher asset like logo as a stream
     *
     * @param {string} publisherName - Internal name of the publisher
     * @param {string} assetType - Type of asset. Default value is 'logo'.
     * @return IPromise<ArrayBuffer>
     */
    getPublisherAsset(publisherName: string, assetType?: string): IPromise<ArrayBuffer>;
    /**
     * [Preview API] Delete publisher asset like logo
     *
     * @param {string} publisherName - Internal name of the publisher
     * @param {string} assetType - Type of asset. Default value is 'logo'.
     * @return IPromise<void>
     */
    deletePublisherAsset(publisherName: string, assetType?: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} draftId
     * @param {string} assetType
     * @return IPromise<ArrayBuffer>
     */
    getAssetFromNewExtensionDraft(publisherName: string, draftId: string, assetType: string): IPromise<ArrayBuffer>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} draftId
     * @param {string} assetType
     * @param {string} extensionName
     * @return IPromise<ArrayBuffer>
     */
    getAssetFromEditExtensionDraft(publisherName: string, draftId: string, assetType: string, extensionName: string): IPromise<ArrayBuffer>;
    /**
     * [Preview API]
     *
     * @param {string} content - Content to upload
     * @param {string} publisherName
     * @param {string} draftId
     * @param {string} assetType
     * @return IPromise<Contracts.ExtensionDraftAsset>
     */
    addAssetForNewExtensionDraft(content: string, publisherName: string, draftId: string, assetType: string): IPromise<Contracts.ExtensionDraftAsset>;
    /**
     * [Preview API]
     *
     * @param {any} content - Content to upload
     * @param {string} publisherName
     * @param {string} draftId
     * @param {String} fileName - Header to pass the filename of the uploaded data
     * @return IPromise<Contracts.ExtensionDraft>
     */
    updatePayloadInDraftForNewExtension(content: any, publisherName: string, draftId: string, fileName?: String): IPromise<Contracts.ExtensionDraft>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionDraftPatch} draftPatch
     * @param {string} publisherName
     * @param {string} draftId
     * @return IPromise<Contracts.ExtensionDraft>
     */
    performNewExtensionDraftOperation(draftPatch: Contracts.ExtensionDraftPatch, publisherName: string, draftId: string): IPromise<Contracts.ExtensionDraft>;
    /**
     * [Preview API]
     *
     * @param {any} content - Content to upload
     * @param {string} publisherName
     * @param {String} product - Header to pass the product type of the payload file
     * @param {String} fileName - Header to pass the filename of the uploaded data
     * @return IPromise<Contracts.ExtensionDraft>
     */
    createDraftForNewExtension(content: any, publisherName: string, product: String, fileName?: String): IPromise<Contracts.ExtensionDraft>;
    /**
     * [Preview API]
     *
     * @param {string} content - Content to upload
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} draftId
     * @param {string} assetType
     * @return IPromise<Contracts.ExtensionDraftAsset>
     */
    addAssetForEditExtensionDraft(content: string, publisherName: string, extensionName: string, draftId: string, assetType: string): IPromise<Contracts.ExtensionDraftAsset>;
    /**
     * [Preview API]
     *
     * @param {any} content - Content to upload
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} draftId
     * @param {String} fileName - Header to pass the filename of the uploaded data
     * @return IPromise<Contracts.ExtensionDraft>
     */
    updatePayloadInDraftForEditExtension(content: any, publisherName: string, extensionName: string, draftId: string, fileName?: String): IPromise<Contracts.ExtensionDraft>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionDraftPatch} draftPatch
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} draftId
     * @return IPromise<Contracts.ExtensionDraft>
     */
    performEditExtensionDraftOperation(draftPatch: Contracts.ExtensionDraftPatch, publisherName: string, extensionName: string, draftId: string): IPromise<Contracts.ExtensionDraft>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @return IPromise<Contracts.ExtensionDraft>
     */
    createDraftForEditExtension(publisherName: string, extensionName: string): IPromise<Contracts.ExtensionDraft>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @return IPromise<ArrayBuffer>
     */
    getContentVerificationLog(publisherName: string, extensionName: string): IPromise<ArrayBuffer>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} hostType
     * @param {string} hostName
     * @return IPromise<void>
     */
    shareExtensionWithHost(publisherName: string, extensionName: string, hostType: string, hostName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {string} hostType
     * @param {string} hostName
     * @return IPromise<void>
     */
    unshareExtensionWithHost(publisherName: string, extensionName: string, hostType: string, hostName: string): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient4 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient3_2 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient3_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(extensionPackage: Contracts.ExtensionPackage): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionPackage: Contracts.ExtensionPackage, extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(extensionPackage: Contracts.ExtensionPackage, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {boolean} bypassScopeCheck
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(extensionPackage: Contracts.ExtensionPackage, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(extensionPackage: Contracts.ExtensionPackage): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionPackage: Contracts.ExtensionPackage, extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(extensionPackage: Contracts.ExtensionPackage, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {boolean} bypassScopeCheck
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(extensionPackage: Contracts.ExtensionPackage, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient2_3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(extensionPackage: Contracts.ExtensionPackage): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionPackage: Contracts.ExtensionPackage, extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(extensionPackage: Contracts.ExtensionPackage, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {boolean} bypassScopeCheck
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(extensionPackage: Contracts.ExtensionPackage, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient2_2 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(extensionPackage: Contracts.ExtensionPackage): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionPackage: Contracts.ExtensionPackage, extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(extensionPackage: Contracts.ExtensionPackage, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {boolean} bypassScopeCheck
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(extensionPackage: Contracts.ExtensionPackage, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient2_1 extends CommonMethods2_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(extensionPackage: Contracts.ExtensionPackage): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionPackage: Contracts.ExtensionPackage, extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(extensionPackage: Contracts.ExtensionPackage, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {boolean} bypassScopeCheck
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(extensionPackage: Contracts.ExtensionPackage, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
}
/**
 * @exemptedapi
 */
export class GalleryHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtension(extensionPackage: Contracts.ExtensionPackage): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} extensionId
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtensionById(extensionPackage: Contracts.ExtensionPackage, extensionId: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @return IPromise<Contracts.PublishedExtension>
     */
    createExtensionWithPublisher(extensionPackage: Contracts.ExtensionPackage, publisherName: string): IPromise<Contracts.PublishedExtension>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionPackage} extensionPackage
     * @param {string} publisherName
     * @param {string} extensionName
     * @param {boolean} bypassScopeCheck
     * @return IPromise<Contracts.PublishedExtension>
     */
    updateExtension(extensionPackage: Contracts.ExtensionPackage, publisherName: string, extensionName: string, bypassScopeCheck?: boolean): IPromise<Contracts.PublishedExtension>;
}
export class GalleryHttpClient extends GalleryHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return GalleryHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): GalleryHttpClient4_1;
}
declare module "VSS/Graph/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\graph.genclient.json
 */
import VSS_Identities_Contracts = require("VSS/Identities/Contracts");
export interface GraphCachePolicies {
    /**
     * Size of the cache
     */
    cacheSize: number;
}
export interface GraphDescriptorResult {
    /**
     * This field contains zero or more interesting links about the graph descriptor. These links may be invoked to obtain additional relationships or more detailed information about this graph descriptor.
     */
    _links: any;
    value: string;
}
/**
 * Represents a set of data used to communicate with a federated provider on behalf of a particular user.
 */
export interface GraphFederatedProviderData {
    /**
     * The access token that can be used to communicated with the federated provider on behalf on the target identity, if we were able to successfully acquire one, otherwise <code>null</code>, if we were not.
     */
    accessToken: string;
    /**
     * Whether or not the immediate provider (i.e. AAD) has indicated that we can call them to attempt to get an access token to communicate with the federated provider on behalf of the target identity.
     */
    canQueryAccessToken: boolean;
    /**
     * The name of the federated provider, e.g. "github.com".
     */
    providerName: string;
    /**
     * The descriptor of the graph subject to which this federated provider data corresponds.
     */
    subjectDescriptor: string;
    /**
     * The version number of this federated provider data, which corresponds to when it was last updated. Can be used to prevent returning stale provider data from the cache when the caller is aware of a newer version, such as to prevent local cache poisoning from a remote cache or store. This is the app layer equivalent of the data layer sequence ID.
     */
    version: number;
}
export interface GraphGlobalExtendedPropertyBatch {
    propertyNameFilters: string[];
    subjectDescriptors: string[];
}
export interface GraphGroup extends GraphMember {
    /**
     * A short phrase to help human readers disambiguate groups with similar names
     */
    description: string;
    isCrossProject: boolean;
    isDeleted: boolean;
    isGlobalScope: boolean;
    isRestrictedVisible: boolean;
    localScopeId: string;
    scopeId: string;
    scopeName: string;
    scopeType: string;
    securingHostId: string;
    specialType: string;
}
/**
 * Do not attempt to use this type to create a new group. This type does not contain sufficient fields to create a new group.
 */
export interface GraphGroupCreationContext {
    /**
     * Optional: If provided, we will use this identifier for the storage key of the created group
     */
    storageKey: string;
}
/**
 * Use this type to create a new group using the mail address as a reference to an existing group from an external AD or AAD backed provider. This is the subset of GraphGroup fields required for creation of a group for the AAD and AD use case.
 */
export interface GraphGroupMailAddressCreationContext extends GraphGroupCreationContext {
    /**
     * This should be the mail address or the group in the source AD or AAD provider. Example: jamal@contoso.com Team Services will communicate with the source provider to fill all other fields on creation.
     */
    mailAddress: string;
}
/**
 * Use this type to create a new group using the OriginID as a reference to an existing group from an external AD or AAD backed provider. This is the subset of GraphGroup fields required for creation of a group for the AD and AAD use case.
 */
export interface GraphGroupOriginIdCreationContext extends GraphGroupCreationContext {
    /**
     * This should be the object id or sid of the group from the source AD or AAD provider. Example: d47d025a-ce2f-4a79-8618-e8862ade30dd Team Services will communicate with the source provider to fill all other fields on creation.
     */
    originId: string;
}
/**
 * Use this type to create a new Vsts group that is not backed by an external provider.
 */
export interface GraphGroupVstsCreationContext extends GraphGroupCreationContext {
    /**
     * For internal use only in back compat scenarios.
     */
    crossProject: boolean;
    /**
     * Used by VSTS groups; if set this will be the group description, otherwise ignored
     */
    description: string;
    descriptor: string;
    /**
     * Used by VSTS groups; if set this will be the group DisplayName, otherwise ignored
     */
    displayName: string;
    /**
     * For internal use only in back compat scenarios.
     */
    restrictedVisibility: boolean;
    /**
     * For internal use only in back compat scenarios.
     */
    specialGroupType: string;
}
export interface GraphMember extends GraphSubject {
    /**
     * This represents the name of the container of origin for a graph member. (For MSA this is "Windows Live ID", for AD the name of the domain, for AAD the tenantID of the directory, for VSTS groups the ScopeId, etc)
     */
    domain: string;
    /**
     * The email address of record for a given graph member. This may be different than the principal name.
     */
    mailAddress: string;
    /**
     * This is the PrincipalName of this graph member from the source provider. The source provider may change this field over time and it is not guaranteed to be immutable for the life of the graph member by VSTS.
     */
    principalName: string;
}
export enum GraphMemberSearchFactor {
    /**
     * Domain qualified account name (domain\alias)
     */
    PrincipalName = 0,
    /**
     * Display name
     */
    DisplayName = 1,
    /**
     * Administrators group
     */
    AdministratorsGroup = 2,
    /**
     * Find the identity using the identifier (SID)
     */
    Identifier = 3,
    /**
     * Email address
     */
    MailAddress = 4,
    /**
     * A general search for an identity.
     */
    General = 5,
    /**
     * Alternate login username (Basic Auth Alias)
     */
    Alias = 6,
    /**
     * Find identity using DirectoryAlias
     */
    DirectoryAlias = 8
}
export interface GraphMembership {
    /**
     * This field contains zero or more interesting links about the graph membership. These links may be invoked to obtain additional relationships or more detailed information about this graph membership.
     */
    _links: any;
    containerDescriptor: string;
    memberDescriptor: string;
}
export interface GraphMembershipState {
    /**
     * This field contains zero or more interesting links about the graph membership state. These links may be invoked to obtain additional relationships or more detailed information about this graph membership state.
     */
    _links: any;
    active: boolean;
}
export interface GraphMembershipTraversal {
    /**
     * Reason why the subject could not be traversed completely
     */
    incompletenessReason: string;
    /**
     * When true, the subject is traversed completely
     */
    isComplete: boolean;
    /**
     * The traversed subject descriptor
     */
    subjectDescriptor: string;
    /**
     * Subject descriptor ids of the traversed members
     */
    traversedSubjectIds: string[];
    /**
     * Subject descriptors of the traversed members
     */
    traversedSubjects: string[];
}
/**
 * Who is the provider for this user and what is the identifier and domain that is used to uniquely identify the user.
 */
export interface GraphProviderInfo {
    /**
     * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
     */
    descriptor: string;
    /**
     * This represents the name of the container of origin for a graph member. (For MSA this is "Windows Live ID", for AAD the tenantID of the directory.)
     */
    domain: string;
    /**
     * The type of source provider for the origin identifier (ex: "aad", "msa")
     */
    origin: string;
    /**
     * The unique identifier from the system of origin. (For MSA this is the PUID in hex notation, for AAD this is the object id.)
     */
    originId: string;
}
export interface GraphScope extends GraphSubject {
    /**
     * The subject descriptor that references the administrators group for this scope. Only members of this group can change the contents of this scope or assign other users permissions to access this scope.
     */
    administratorDescriptor: string;
    /**
     * When true, this scope is also a securing host for one or more scopes.
     */
    isGlobal: boolean;
    /**
     * The subject descriptor for the closest account or organization in the ancestor tree of this scope.
     */
    parentDescriptor: string;
    /**
     * The type of this scope. Typically ServiceHost or TeamProject.
     */
    scopeType: VSS_Identities_Contracts.GroupScopeType;
    /**
     * The subject descriptor for the containing organization in the ancestor tree of this scope.
     */
    securingHostDescriptor: string;
}
/**
 * This type is the subset of fields that can be provided by the user to create a Vsts scope. Scope creation is currently limited to internal back-compat scenarios. End users that attempt to create a scope with this API will fail.
 */
export interface GraphScopeCreationContext {
    /**
     * Set this field to override the default description of this scope's admin group.
     */
    adminGroupDescription: string;
    /**
     * All scopes have an Administrator Group that controls access to the contents of the scope. Set this field to use a non-default group name for that administrators group.
     */
    adminGroupName: string;
    /**
     * Set this optional field if this scope is created on behalf of a user other than the user making the request. This should be the Id of the user that is not the requester.
     */
    creatorId: string;
    /**
     * The scope must be provided with a unique name within the parent scope. This means the created scope can have a parent or child with the same name, but no siblings with the same name.
     */
    name: string;
    /**
     * The type of scope being created.
     */
    scopeType: VSS_Identities_Contracts.GroupScopeType;
    /**
     * An optional ID that uniquely represents the scope within it's parent scope. If this parameter is not provided, Vsts will generate on automatically.
     */
    storageKey: string;
}
export interface GraphStorageKeyResult {
    /**
     * This field contains zero or more interesting links about the graph storage key. These links may be invoked to obtain additional relationships or more detailed information about this graph storage key.
     */
    _links: any;
    value: string;
}
export interface GraphSubject extends GraphSubjectBase {
    /**
     * [Internal Use Only] The legacy descriptor is here in case you need to access old version IMS using identity descriptor.
     */
    legacyDescriptor: string;
    /**
     * The type of source provider for the origin identifier (ex:AD, AAD, MSA)
     */
    origin: string;
    /**
     * The unique identifier from the system of origin. Typically a sid, object id or Guid. Linking and unlinking operations can cause this value to change for a user because the user is not backed by a different provider and has a different unique id in the new provider.
     */
    originId: string;
    /**
     * This field identifies the type of the graph subject (ex: Group, Scope, User).
     */
    subjectKind: string;
}
export interface GraphSubjectBase {
    /**
     * This field contains zero or more interesting links about the graph subject. These links may be invoked to obtain additional relationships or more detailed information about this graph subject.
     */
    _links: any;
    /**
     * The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
     */
    descriptor: string;
    /**
     * This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
     */
    displayName: string;
    /**
     * This url is the full route to the source resource of this graph subject.
     */
    url: string;
}
export interface GraphSubjectLookup {
    lookupKeys: GraphSubjectLookupKey[];
}
export interface GraphSubjectLookupKey {
    descriptor: string;
}
export interface GraphSystemSubject extends GraphSubject {
}
export enum GraphTraversalDirection {
    Unknown = 0,
    Down = 1,
    Up = 2
}
export interface GraphUser extends GraphMember {
    isDeletedInOrigin: boolean;
    metadataUpdateDate: Date;
    /**
     * The meta type of the user in the origin, such as "member", "guest", etc. See UserMetaType for the set of possible values.
     */
    metaType: string;
}
/**
 * Do not attempt to use this type to create a new user. Use one of the subclasses instead. This type does not contain sufficient fields to create a new user.
 */
export interface GraphUserCreationContext {
    /**
     * Optional: If provided, we will use this identifier for the storage key of the created user
     */
    storageKey: string;
}
/**
 * Use this type to create a new user using the mail address as a reference to an existing user from an external AD or AAD backed provider. This is the subset of GraphUser fields required for creation of a GraphUser for the AD and AAD use case when looking up the user by its mail address in the backing provider.
 */
export interface GraphUserMailAddressCreationContext extends GraphUserCreationContext {
    mailAddress: string;
}
/**
 * Use this type to create a new user using the OriginID as a reference to an existing user from an external AD or AAD backed provider. This is the subset of GraphUser fields required for creation of a GraphUser for the AD and AAD use case when looking up the user by its unique ID in the backing provider.
 */
export interface GraphUserOriginIdCreationContext extends GraphUserCreationContext {
    /**
     * This should be the object id or sid of the user from the source AD or AAD provider. Example: d47d025a-ce2f-4a79-8618-e8862ade30dd Team Services will communicate with the source provider to fill all other fields on creation.
     */
    originId: string;
}
/**
 * Use this type to create a new user using the principal name as a reference to an existing user from an external AD or AAD backed provider. This is the subset of GraphUser fields required for creation of a GraphUser for the AD and AAD use case when looking up the user by its principal name in the backing provider.
 */
export interface GraphUserPrincipalNameCreationContext extends GraphUserCreationContext {
    /**
     * This should be the principal name or upn of the user in the source AD or AAD provider. Example: jamal@contoso.com Team Services will communicate with the source provider to fill all other fields on creation.
     */
    principalName: string;
}
export enum IdentityShardingState {
    Undefined = 0,
    Enabled = 1,
    Disabled = 2
}
export interface PagedGraphGroups {
    /**
     * This will be non-null if there is another page of data. There will never be more than one continuation token returned by a request.
     */
    continuationToken: string[];
    /**
     * The enumerable list of groups found within a page.
     */
    graphGroups: GraphGroup[];
}
export interface PagedGraphUsers {
    /**
     * This will be non-null if there is another page of data. There will never be more than one continuation token returned by a request.
     */
    continuationToken: string[];
    /**
     * The enumerable set of users found within a page.
     */
    graphUsers: GraphUser[];
}
export var TypeInfo: {
    GraphMemberSearchFactor: {
        enumValues: {
            "principalName": number;
            "displayName": number;
            "administratorsGroup": number;
            "identifier": number;
            "mailAddress": number;
            "general": number;
            "alias": number;
            "directoryAlias": number;
        };
    };
    GraphScope: any;
    GraphScopeCreationContext: any;
    GraphTraversalDirection: {
        enumValues: {
            "unknown": number;
            "down": number;
            "up": number;
        };
    };
    GraphUser: any;
    IdentityShardingState: {
        enumValues: {
            "undefined": number;
            "enabled": number;
            "disabled": number;
        };
    };
    PagedGraphUsers: any;
};
}
declare module "VSS/Graph/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\graph.genclient.json
 */
import Contracts = require("VSS/Graph/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3_1To5 extends VSS_WebApi.VssHttpClient {
    protected descriptorsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Resolve a storage key to a descriptor
     *
     * @param {string} storageKey - Storage key of the subject (user, group, scope, etc.) to resolve
     * @return IPromise<Contracts.GraphDescriptorResult>
     */
    getDescriptor(storageKey: string): IPromise<Contracts.GraphDescriptorResult>;
}
export class CommonMethods3_2To5 extends CommonMethods3_1To5 {
    protected cachePoliciesApiVersion: string;
    protected graphGlobalExtendedPropertyBatchApiVersion: string;
    protected groupsApiVersion: string;
    protected memberLookupApiVersion: string;
    protected membersApiVersion: string;
    protected membersApiVersion_42939f1e: string;
    protected membersApiVersion_8b9ecdb2: string;
    protected membershipsApiVersion: string;
    protected membershipsBatchApiVersion: string;
    protected membershipStatesApiVersion: string;
    protected membershipTraversalsApiVersion: string;
    protected scopesApiVersion: string;
    protected shardingStateApiVersion: string;
    protected storageKeysApiVersion: string;
    protected subjectLookupApiVersion: string;
    protected subjectsApiVersion: string;
    protected usersApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Get a list of all users in a given scope.
     *
     * @param {string[]} subjectTypes - A comma separated list of user subject subtypes to reduce the retrieved results, e.g. msa’, ‘aad’, ‘svc’ (service identity), ‘imp’ (imported identity), etc.
     * @param {string} continuationToken - An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.
     * @return IPromise<Contracts.PagedGraphUsers>
     */
    listUsers(subjectTypes?: string[], continuationToken?: string): IPromise<Contracts.PagedGraphUsers>;
    /**
     * [Preview API] Get a user by its descriptor.
     *
     * @param {string} userDescriptor - The descriptor of the desired user.
     * @return IPromise<Contracts.GraphUser>
     */
    getUser(userDescriptor: string): IPromise<Contracts.GraphUser>;
    /**
     * [Preview API] Disables a user.
     *
     * @param {string} userDescriptor - The descriptor of the user to delete.
     * @return IPromise<void>
     */
    deleteUser(userDescriptor: string): IPromise<void>;
    /**
     * [Preview API] Materialize an existing AAD or MSA user into the VSTS account.
     *
     * @param {Contracts.GraphUserCreationContext} creationContext - The subset of the full graph user used to uniquely find the graph subject in an external provider.
     * @param {string[]} groupDescriptors - A comma separated list of descriptors of groups you want the graph user to join
     * @return IPromise<Contracts.GraphUser>
     */
    createUser(creationContext: Contracts.GraphUserCreationContext, groupDescriptors?: string[]): IPromise<Contracts.GraphUser>;
    /**
     * [Preview API] Resolve descriptors to users, groups or scopes (Subjects) in a batch.
     *
     * @param {Contracts.GraphSubjectLookup} subjectLookup - A list of descriptors that specifies a subset of subjects to retrieve. Each descriptor uniquely identifies the subject across all instance scopes, but only at a single point in time.
     * @return IPromise<{ [key: string] : Contracts.GraphSubject; }>
     */
    lookupSubjects(subjectLookup: Contracts.GraphSubjectLookup): IPromise<{
        [key: string]: Contracts.GraphSubject;
    }>;
    /**
     * [Preview API] Resolve a descriptor to a storage key.
     *
     * @param {string} subjectDescriptor
     * @return IPromise<Contracts.GraphStorageKeyResult>
     */
    getStorageKey(subjectDescriptor: string): IPromise<Contracts.GraphStorageKeyResult>;
    /**
     * [Preview API] Check whether a subject is active or inactive.
     *
     * @param {string} subjectDescriptor - Descriptor of the subject (user, group, scope, etc.) to check state of
     * @return IPromise<Contracts.GraphMembershipState>
     */
    getMembershipState(subjectDescriptor: string): IPromise<Contracts.GraphMembershipState>;
    /**
     * [Preview API] Get all the memberships where this descriptor is a member in the relationship.
     *
     * @param {string} subjectDescriptor - Fetch all direct memberships of this descriptor.
     * @param {Contracts.GraphTraversalDirection} direction - Defaults to Up.
     * @param {number} depth - The maximum number of edges to traverse up or down the membership tree. Currently the only supported value is '1'.
     * @return IPromise<Contracts.GraphMembership[]>
     */
    listMemberships(subjectDescriptor: string, direction?: Contracts.GraphTraversalDirection, depth?: number): IPromise<Contracts.GraphMembership[]>;
    /**
     * [Preview API] Deletes a membership between a container and subject.
     *
     * @param {string} subjectDescriptor - A descriptor to a group or user that is the child subject in the relationship.
     * @param {string} containerDescriptor - A descriptor to a group that is the container in the relationship.
     * @return IPromise<void>
     */
    removeMembership(subjectDescriptor: string, containerDescriptor: string): IPromise<void>;
    /**
     * [Preview API] Get a membership relationship between a container and subject.
     *
     * @param {string} subjectDescriptor - A descriptor to the child subject in the relationship.
     * @param {string} containerDescriptor - A descriptor to the container in the relationship.
     * @return IPromise<Contracts.GraphMembership>
     */
    getMembership(subjectDescriptor: string, containerDescriptor: string): IPromise<Contracts.GraphMembership>;
    /**
     * [Preview API] Check to see if a membership relationship between a container and subject exists.
     *
     * @param {string} subjectDescriptor - The group or user that is a child subject of the relationship.
     * @param {string} containerDescriptor - The group that is the container in the relationship.
     * @return IPromise<boolean>
     */
    checkMembershipExistence(subjectDescriptor: string, containerDescriptor: string): IPromise<boolean>;
    /**
     * [Preview API] Create a new membership between a container and subject.
     *
     * @param {string} subjectDescriptor - A descriptor to a group or user that can be the child subject in the relationship.
     * @param {string} containerDescriptor - A descriptor to a group that can be the container in the relationship.
     * @return IPromise<Contracts.GraphMembership>
     */
    addMembership(subjectDescriptor: string, containerDescriptor: string): IPromise<Contracts.GraphMembership>;
    /**
     * [Preview API] Update the properties of a VSTS group.
     *
     * @param {string} groupDescriptor - The descriptor of the group to modify.
     * @param {VSS_Common_Contracts.JsonPatchDocument} patchDocument - The JSON+Patch document containing the fields to alter.
     * @return IPromise<Contracts.GraphGroup>
     */
    updateGroup(groupDescriptor: string, patchDocument: VSS_Common_Contracts.JsonPatchDocument): IPromise<Contracts.GraphGroup>;
    /**
     * [Preview API] Gets a list of all groups in the current scope (usually organization or account).
     *
     * @param {string} scopeDescriptor - Specify a non-default scope (collection, project) to search for groups.
     * @param {string[]} subjectTypes - A comma separated list of user subject subtypes to reduce the retrieved results, e.g. Microsoft.IdentityModel.Claims.ClaimsIdentity
     * @param {string} continuationToken - An opaque data blob that allows the next page of data to resume immediately after where the previous page ended. The only reliable way to know if there is more data left is the presence of a continuation token.
     * @return IPromise<Contracts.PagedGraphGroups>
     */
    listGroups(scopeDescriptor?: string, subjectTypes?: string[], continuationToken?: string): IPromise<Contracts.PagedGraphGroups>;
    /**
     * [Preview API] Get a group by its descriptor.
     *
     * @param {string} groupDescriptor - The descriptor of the desired graph group.
     * @return IPromise<Contracts.GraphGroup>
     */
    getGroup(groupDescriptor: string): IPromise<Contracts.GraphGroup>;
    /**
     * [Preview API] Removes a VSTS group from all of its parent groups.
     *
     * @param {string} groupDescriptor - The descriptor of the group to delete.
     * @return IPromise<void>
     */
    deleteGroup(groupDescriptor: string): IPromise<void>;
    /**
     * [Preview API] Create a new VSTS group or materialize an existing AAD group.
     *
     * @param {Contracts.GraphGroupCreationContext} creationContext - The subset of the full graph group used to uniquely find the graph subject in an external provider.
     * @param {string} scopeDescriptor - A descriptor referencing the scope (collection, project) in which the group should be created. If omitted, will be created in the scope of the enclosing account or organization. Valid only for VSTS groups.
     * @param {string[]} groupDescriptors - A comma separated list of descriptors referencing groups you want the graph group to join
     * @return IPromise<Contracts.GraphGroup>
     */
    createGroup(creationContext: Contracts.GraphGroupCreationContext, scopeDescriptor?: string, groupDescriptors?: string[]): IPromise<Contracts.GraphGroup>;
}
export class CommonMethods4To5 extends CommonMethods3_2To5 {
    protected providerInfoApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} userDescriptor
     * @return IPromise<Contracts.GraphProviderInfo>
     */
    getProviderInfo(userDescriptor: string): IPromise<Contracts.GraphProviderInfo>;
}
/**
 * @exemptedapi
 */
export class GraphHttpClient5 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GraphHttpClient4_1 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GraphHttpClient4 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GraphHttpClient3_2 extends CommonMethods3_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class GraphHttpClient3_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class GraphHttpClient extends GraphHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return GraphHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): GraphHttpClient4_1;
}
declare module "VSS/HostAcquisition/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\hostacquisition.genclient.json
 */
export interface NameAvailability {
    /**
     * True if the name is available; False otherwise. See the unavailability reason for an explanation.
     */
    isAvailable: boolean;
    /**
     * Name requested.
     */
    name: string;
    /**
     * The reason why IsAvailable is False or Null
     */
    unavailabilityReason: string;
}
export interface Region {
    /**
     * Display name for the region.
     */
    displayName: string;
    /**
     * Whether the region is default or not
     */
    isDefault: boolean;
    /**
     * Name identifier for the region.
     */
    name: string;
    /**
     * Short name used in Microsoft Azure. Ex: southcentralus, westcentralus, southindia, etc.
     */
    nameInAzure: string;
}
}
declare module "VSS/HostAcquisition/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\hostacquisition.genclient.json
 */
import Contracts = require("VSS/HostAcquisition/Contracts");
import VSS_Organization_Contracts = require("VSS/Organization/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected collectionsApiVersion: string;
    protected nameAvailabilityApiVersion: string;
    protected regionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.Region[]>
     */
    getRegions(): IPromise<Contracts.Region[]>;
    /**
     * [Preview API]
     *
     * @param {string} name
     * @return IPromise<Contracts.NameAvailability>
     */
    getNameAvailability(name: string): IPromise<Contracts.NameAvailability>;
    /**
     * [Preview API] Creates a new collection of the given name in the given region
     *
     * @param {{ [key: string] : string; }} properties
     * @param {string} collectionName
     * @param {string} preferredRegion
     * @param {string} ownerDescriptor
     * @return IPromise<VSS_Organization_Contracts.Collection>
     */
    createCollection(properties: {
        [key: string]: string;
    }, collectionName: string, preferredRegion: string, ownerDescriptor?: string): IPromise<VSS_Organization_Contracts.Collection>;
}
/**
 * @exemptedapi
 */
export class HostAcquisitionHttpClient5 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class HostAcquisitionHttpClient4_1 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class HostAcquisitionHttpClient4 extends CommonMethods4To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class HostAcquisitionHttpClient extends HostAcquisitionHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return HostAcquisitionHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): HostAcquisitionHttpClient4_1;
}
declare module "VSS/Identities/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
/**
 * Container class for changed identities
 */
export interface ChangedIdentities {
    /**
     * Changed Identities
     */
    identities: Identity[];
    /**
     * More data available, set to true if pagesize is specified.
     */
    moreData: boolean;
    /**
     * Last Identity SequenceId
     */
    sequenceContext: ChangedIdentitiesContext;
}
/**
 * Context class for changed identities
 */
export interface ChangedIdentitiesContext {
    /**
     * Last Group SequenceId
     */
    groupSequenceId: number;
    /**
     * Last Identity SequenceId
     */
    identitySequenceId: number;
    /**
     * Last Group OrganizationIdentitySequenceId
     */
    organizationIdentitySequenceId: number;
    /**
     * Page size
     */
    pageSize: number;
}
export interface CreateScopeInfo {
    adminGroupDescription: string;
    adminGroupName: string;
    creatorId: string;
    parentScopeId: string;
    scopeName: string;
    scopeType: GroupScopeType;
}
export interface FrameworkIdentityInfo {
    displayName: string;
    identifier: string;
    identityType: FrameworkIdentityType;
    role: string;
}
export enum FrameworkIdentityType {
    None = 0,
    ServiceIdentity = 1,
    AggregateIdentity = 2,
    ImportedIdentity = 3
}
export interface GroupMembership {
    active: boolean;
    descriptor: IdentityDescriptor;
    id: string;
    queriedId: string;
}
export enum GroupScopeType {
    Generic = 0,
    ServiceHost = 1,
    TeamProject = 2
}
export interface Identity extends IdentityBase {
}
/**
 * Base Identity class to allow "trimmed" identity class in the GetConnectionData API Makes sure that on-the-wire representations of the derived classes are compatible with each other (e.g. Server responds with PublicIdentity object while client deserializes it as Identity object) Derived classes should not have additional [DataMember] properties
 */
export interface IdentityBase {
    /**
     * The custom display name for the identity (if any). Setting this property to an empty string will clear the existing custom display name. Setting this property to null will not affect the existing persisted value (since null values do not get sent over the wire or to the database)
     */
    customDisplayName: string;
    descriptor: IdentityDescriptor;
    id: string;
    isActive: boolean;
    isContainer: boolean;
    masterId: string;
    memberIds: string[];
    memberOf: IdentityDescriptor[];
    members: IdentityDescriptor[];
    metaTypeId: number;
    properties: any;
    /**
     * The display name for the identity as specified by the source identity provider.
     */
    providerDisplayName: string;
    resourceVersion: number;
    subjectDescriptor: string;
    uniqueUserId: number;
}
export interface IdentityBatchInfo {
    descriptors: IdentityDescriptor[];
    identityIds: string[];
    includeRestrictedVisibility: boolean;
    propertyNames: string[];
    queryMembership: QueryMembership;
    subjectDescriptors: string[];
}
/**
 * An Identity descriptor is a wrapper for the identity type (Windows SID, Passport) along with a unique identifier such as the SID or PUID.
 */
export interface IdentityDescriptor {
    /**
     * The unique identifier for this identity, not exceeding 256 chars, which will be persisted.
     */
    identifier: string;
    /**
     * Type of descriptor (for example, Windows, Passport, etc.).
     */
    identityType: string;
}
export interface IdentityScope {
    administrators: IdentityDescriptor;
    id: string;
    isActive: boolean;
    isGlobal: boolean;
    localScopeId: string;
    name: string;
    parentId: string;
    scopeType: GroupScopeType;
    securingHostId: string;
    subjectDescriptor: string;
}
/**
 * Identity information.
 */
export interface IdentitySelf {
    /**
     * The UserPrincipalName (UPN) of the account. This value comes from the source provider.
     */
    accountName: string;
    /**
     * The display name. For AAD accounts with multiple tenants this is the display name of the profile in the home tenant.
     */
    displayName: string;
    /**
     * This represents the name of the container of origin. For AAD accounts this is the tenantID of the home tenant. For MSA accounts this is the string "Windows Live ID".
     */
    domain: string;
    /**
     * This is the VSID of the home tenant profile. If the profile is signed into the home tenant or if the profile has no tenants then this Id is the same as the Id returned by the profile/profiles/me endpoint. Going forward it is recommended that you use the combined values of Origin, OriginId and Domain to uniquely identify a user rather than this Id.
     */
    id: string;
    /**
     * The type of source provider for the origin identifier. For MSA accounts this is "msa". For AAD accounts this is "aad".
     */
    origin: string;
    /**
     * The unique identifier from the system of origin. If there are multiple tenants this is the unique identifier of the account in the home tenant. (For MSA this is the PUID in hex notation, for AAD this is the object id.)
     */
    originId: string;
    /**
     * For AAD accounts this is all of the tenants that this account is a member of.
     */
    tenants: TenantInfo[];
}
export interface IdentitySnapshot {
    groups: Identity[];
    identityIds: string[];
    memberships: GroupMembership[];
    scopeId: string;
    scopes: IdentityScope[];
}
export interface IdentityUpdateData {
    id: string;
    index: number;
    updated: boolean;
}
export enum QueryMembership {
    /**
     * Query will not return any membership data
     */
    None = 0,
    /**
     * Query will return only direct membership data
     */
    Direct = 1,
    /**
     * Query will return expanded membership data
     */
    Expanded = 2,
    /**
     * Query will return expanded up membership data (parents only)
     */
    ExpandedUp = 3,
    /**
     * Query will return expanded down membership data (children only)
     */
    ExpandedDown = 4
}
export enum ReadIdentitiesOptions {
    None = 0,
    FilterIllegalMemberships = 1
}
export interface SwapIdentityInfo {
    id1: string;
    id2: string;
}
export interface TenantInfo {
    homeTenant: boolean;
    tenantId: string;
    tenantName: string;
}
export var TypeInfo: {
    CreateScopeInfo: any;
    FrameworkIdentityInfo: any;
    FrameworkIdentityType: {
        enumValues: {
            "none": number;
            "serviceIdentity": number;
            "aggregateIdentity": number;
            "importedIdentity": number;
        };
    };
    GroupScopeType: {
        enumValues: {
            "generic": number;
            "serviceHost": number;
            "teamProject": number;
        };
    };
    IdentityBatchInfo: any;
    IdentityScope: any;
    IdentitySnapshot: any;
    QueryMembership: {
        enumValues: {
            "none": number;
            "direct": number;
            "expanded": number;
            "expandedUp": number;
            "expandedDown": number;
        };
    };
    ReadIdentitiesOptions: {
        enumValues: {
            "none": number;
            "filterIllegalMemberships": number;
        };
    };
};
}
declare module "VSS/Identities/Mru/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   sps\clients\identity\clientgeneratorconfigs\genclient.json
 */
export interface JsonPatchOperationData<T> {
    op: string;
    path: string;
    value: T;
}
export interface MruIdentitiesUpdateData extends JsonPatchOperationData<string[]> {
}
}
declare module "VSS/Identities/Mru/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   sps\clients\identity\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Identities/Mru/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected mruIdentitiesApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.MruIdentitiesUpdateData} updateData
     * @param {string} identityId
     * @param {string} containerId
     * @return IPromise<void>
     */
    updateMruIdentities(updateData: Contracts.MruIdentitiesUpdateData, identityId: string, containerId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string[]} identityIds
     * @param {string} identityId
     * @param {string} containerId
     * @return IPromise<void>
     */
    setMruIdentities(identityIds: string[], identityId: string, containerId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} identityId
     * @param {string} containerId
     * @return IPromise<string[]>
     */
    getMruIdentities(identityId: string, containerId: string): IPromise<string[]>;
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentityMruHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class IdentityMruHttpClient extends IdentityMruHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return IdentityMruHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): IdentityMruHttpClient4_1;
}
declare module "VSS/Identities/Picker/Cache" {
/**
 * @exemptedapi
 */
export interface IIdentityPickerCacheException {
    message: string;
    source?: string;
    parameter?: string;
    details?: any;
}
/**
 * @exemptedapi
 */
export enum CacheableTypes {
    Unknown = 0,
    UniqueIdentifier = 1,
    Guid = 2,
    Email = 3
}
/**
 * @exemptedapi
 */
export interface ICacheConfiguration {
    expirationIntervalS: number;
}
/**
 * @exemptedapi
 */
export interface ICache<V> {
    /**
    *   This method is optimistic
    **/
    set(key: string, value: V): void;
    /**
    *  This method can return null
    **/
    get(key: string): V;
    clear(): void;
    configure(config: ICacheConfiguration): void;
}
/**
 * @exemptedapi
 */
export class HashCache<V> implements ICache<V> {
    constructor();
    /**
    *  This method can return null
    **/
    get(key: string): V;
    set(key: string, value: V): void;
    clear(): void;
    configure(config: ICacheConfiguration): void;
    private _getKeys;
    private _cache;
    private _config;
}
/**
 * @exemptedapi
 */
export interface IRequestCacheConfiguration {
    delayIntervalMS: number;
}
/**
 * @exemptedapi
 */
export interface IRequestCache<T> {
    /**
    *  This method can return null
    **/
    getPromise(request: string): IPromise<T>;
    /**
    *   This method is optimistic
    **/
    setPromise(request: string, promise: IPromise<T>): void;
    configure(config: IRequestCacheConfiguration): void;
}
/**
 * @exemptedapi
 */
export class RequestCache<T> implements IRequestCache<T> {
    constructor();
    /**
    *  This method can return null
    **/
    getPromise(request: string): IPromise<T>;
    /**
    *   This method is optimistic
    **/
    setPromise(request: string, promise: IPromise<T>): void;
    configure(config: IRequestCacheConfiguration): void;
    /**
    *   This method is not using Utils_Core.DelayedFunction on purpose.
    *   The DelayedFunction is logging tracepoints and some tests use them for identifying if there are still actions left in a pending state.
    *   We want to exempt the active cache invalidation from being waited upon by the tests.
    **/
    private _setOrResetTimer;
    private _cache;
    private _timeoutHandle;
    private _config;
    private static _defaultDelayIntervalMS;
}
/**
 * @exemptedapi
 */
export interface ITwoLayerCacheConfiguration<V> {
    getUniqueIdentifier: (value: V) => string;
}
/**
 * @exemptedapi
 */
export interface ITwoLayerCache<V> {
    addRedirector(cacheType: CacheableTypes, cache?: ICache<string>): void;
    /**
    *  This method can return null
    **/
    get(key: string, cacheTypeHint?: string): V;
    /**
    *   This method is optimistic
    **/
    set(key: string, value: V, cacheTypeHint?: string): void;
    configure(config: ITwoLayerCacheConfiguration<V>): void;
}
/**
 * @exemptedapi
 */
export class TwoLayerCache<V> implements ITwoLayerCache<V> {
    constructor(config: ITwoLayerCacheConfiguration<V>);
    configure(config: ITwoLayerCacheConfiguration<V>): void;
    addRedirector(cacheType: CacheableTypes): void;
    /**
    *  This method can return null
    **/
    get(key: string, cacheTypeHint?: string): V;
    /**
    *   This method is optimistic
    **/
    set(key: string, value: V, cacheTypeHint?: string): void;
    private _queryCache;
    private _config;
    private _redirectors;
    private _objectCache;
}
}
declare module "VSS/Identities/Picker/Common" {
/**
 * @exemptedapi
 */
export class FilterByScope {
    filterByAncestorEntityIds: string[];
    filterByEntityIds: string[];
    constructor(filterByAncestorEntityIds?: string[], filterByEntityIds?: string[]);
    static GetHashCode(filterByScope: FilterByScope): number;
    /**
    * Return true if the filterByScope is not null and the ancestorEntitityIds and entityIds arrays are empty, otherwise false.
    **/
    static isFilterByScopeEmpty(filterByScope: FilterByScope): boolean;
    private static readonly _hashSeparator;
}
/**
 * @exemptedapi
 */
export class CommonHelpers {
    static GetStringHashCode(str: string): number;
    static GetStringListHashCode(strings: string[]): number;
    static readonly _hashSeed: number;
    static readonly _stringListHashPrime: number;
    private static readonly _stringHashPrime;
}
export interface IPoint {
    x: number;
    y: number;
}
}
declare module "VSS/Identities/Picker/Constants" {
/**
 * @exemptedapi
 */
export class Telemetry {
    static Area: string;
    static Scenario_GetMru_Rtt: string;
    static Scenario_AddMru_Rtt: string;
    static Scenario_RemoveMru_Rtt: string;
    static Scenario_GetDirectory_Rtt: string;
    static Scenario_GetConnections_Rtt: string;
    static Scenario_GetUserConnections_Rtt: string;
    static Scenario_PagingQuerySplit: string;
    static Feature_DropdownControl: string;
    static Feature_SearchControl: string;
    static Feature_IdCardDialogControl: string;
    static Feature_DisplayControl: string;
    static Feature_TwoLayerCache: string;
    static Feature_RequestCache: string;
    static Feature_Select_Mru_NoPrefix: string;
    static Feature_Select_Mru_Prefix: string;
    static Feature_Select_Mru_Dir: string;
    static Feature_Select_Dir: string;
    static Feature_Click_IdCard: string;
    static Feature_Click_Remove_Mru: string;
    static Feature_ApiExceptions: string;
}
/**
 * @exemptedapi
 */
export class TelemetryProperties {
    static prefixType: string;
    static prefixLength: string;
    static userId: string;
    static accountProjectCollectionTeam: string;
    static identityTypes: string;
    static operationScopes: string;
    static maxResults: string;
    static minResults: string;
    static consumerId: string;
    static extensionId: string;
    static entityId: string;
    static exceptionData: string;
    static isMru: string;
    static isNonMaterialized: string;
    static isTwoLayerCacheHit: string;
    static isDirSearchUid: string;
}
/**
 * @exemptedapi
 */
export class PrefixType {
    static readonly SignInAddress: string;
    static readonly DomainSamAccountName: string;
    static readonly EntityId: string;
    static readonly Vsid: string;
    static readonly ScopedPrefix: string;
    static readonly StringPrefix: string;
}
/**
 * @exemptedapi
 * Please create constants ServiceName_FeatureGroupName_OptionalUseCase -> GUID in the Common Identity Picker wiki
 */
export class ConsumerId {
    static UnknownConsumer: string;
}
export class PromiseResultStatus {
    static readonly Fulfilled: string;
    static readonly Rejected: string;
}
/**
 * Map from unicode accented character to closest latin letter,
 * many unicode characters map to the same latin letter.
 */
export const diacriticsRemovalMap: any;
}
declare module "VSS/Identities/Picker/ContactCard" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import React = require("react");
import Component_Base = require("VSS/Flux/Component");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
/**
 * Definitions for ContactCardContactLine used by ContactCard.
 */
export interface ContactCardContactLineProps extends Component_Base.Props {
    /**
    * Label for line.
    */
    label?: string;
    /**
    * Content for line.
    */
    content?: string;
    /**
    * Link (if not link, left blank).
    */
    link?: string;
    /**
     * Option to pad top.
     */
    padTop?: boolean;
    /**
    * Publish telemetry on contact information click
    */
    publishTelemetry?: (cardType: string, action: string, source?: string) => void;
}
export class ContactCardContactLine extends React.Component<ContactCardContactLineProps, {}> {
    render(): JSX.Element;
}
/**
 * Definitions for ContactCard.
 */
export interface ContactCardProps extends Component_Base.Props {
    /**
     * Identity object for persona and contact information.
     */
    identity?: Identities_Picker_RestClient.IEntity;
    /**
    * Publish telemetry on card load
    */
    publishTelemetry: (cardType: string, action: string) => void;
}
export class ContactCard extends React.Component<ContactCardProps, {}> {
    render(): JSX.Element;
}
}
declare module "VSS/Identities/Picker/Controls" {
/// <amd-dependency path="jQueryUI/core" />
/// <amd-dependency path="jQueryUI/button" />
/// <amd-dependency path="jQueryUI/dialog" />
/// <reference types="jquery" />
/// <reference types="jqueryui" />
/// <reference types="highcharts" />
/// <reference types="vss-common" />
import Controls = require("VSS/Controls");
import Identities_Picker_Common = require("VSS/Identities/Picker/Common");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
import Identities_Picker_Services = require("VSS/Identities/Picker/Services");
import Identities_Picker_Cache = require("VSS/Identities/Picker/Cache");
import Service = require("VSS/Service");
import Q = require("q");
export interface IControlAlignmentOptions {
    /**
    *   the vertex of the dropdown which coincides with the baseAlign (horizontal-vertical). See UI.Positioning for details. Default is "left-top"
    **/
    elementAlign?: string;
    /**
    *   the vertex of the base element used as a reference for positioning (horizontal-vertical). See UI.Positioning for details. Default is "left-bottom"
    **/
    baseAlign?: string;
    /**
    *   an element, or a function which returns an element, to be used for determining the alignment and width of the dropdown control.
    *   Refer to the width, elementAlign, and baseAlign options. Default is the container
    **/
    positioningElement?: JQuery | (() => JQuery);
}
export interface UpdateActiveDescendantEventData {
    activeDescendantId: string;
    uniqueId: string;
}
export interface IIdentityPickerDropdownOptions extends Identities_Picker_Services.IIdentityServiceOptions, Identities_Picker_Services.IIdentityPickerExtensionOptions {
    /**
    *   restrict displayed identities in dropdown
    **/
    pageSize?: number;
    /**
    *   what action (usually in parent) should execute when an item in this dropdown is selected
    **/
    onItemSelect?: (identity: Identities_Picker_RestClient.IEntity) => any;
    /**
    *   a pre-render hook that takes in the list of identities that would otherwise have been displayed and rearranges or adds to them prior to returning the new list
    **/
    preDropdownRender?: (entityList: Identities_Picker_RestClient.IEntity[]) => Identities_Picker_RestClient.IEntity[];
    /**
    *   callback allowing to peek at the search results (after rendering). Will not get executed for MRU-only searches. The callback function should not alter the rendered list
    **/
    onDirectorySearchFinished?: (identityList: Identities_Picker_RestClient.IEntity[]) => void;
    /**
    *   DEPRECATED: the minimum length of the prefix to start searching the directories - in the absence of an MRU - default 3
    **/
    minimumPrefixSize?: number;
    /**
    *   whether to display the contact card icon for each identity in the dropdown. Default false.
    **/
    showContactCard?: boolean;
    /**
    *   whether to display the MRU with the search button or just search directories directly. Default false.
    **/
    showMru?: boolean;
    /**
    *   whether to preload (e.g. the MRU identities) on control creation.
    **/
    loadOnCreate?: boolean;
    /**
    *   the width of the dropdown control. Default is max(positioningElement width, 300px)
    **/
    width?: number;
    coreCssClass?: string;
    /**
    *   the size of the control elements (Medium - most elements are 24px, Large - 32px). Default: Large
    **/
    size?: IdentityPickerControlSize;
    /**
    *   Specify the base element, and the relative alignment of the element and base
    **/
    alignment?: IControlAlignmentOptions;
    /**
    *   what action should execute when identity dropdown is hidden
    **/
    onHide?: (event?: JQueryEventObject) => void;
    /**
    *   An element that will receive focus when the contact card for an item in the dropdown is closed
    **/
    focusElementOnContactCardClose?: JQuery;
    /**
    *   Specifies whether or not the dropdown will try to use all remaining space below the positioning element.
    *   For internal use only, this is specifically for the mobile work item form where we want to show the picker in a
    *   full screen view and the behavior may change over time.
    **/
    useRemainingSpace?: boolean;
    /**
    *   Optimizations for small screen (mobile) which renders controls with additional icons and
    *   text information suitable for small screens.
    */
    smallScreenRender?: boolean;
    /**
    *   Event callback options (making sure the events from the correct instance of the dropdown are listened to)
    **/
    eventOptions?: IIdentityPickerDropdownEventOptions;
    /**
    *   (optional) JQuery selector string which specifies a DOM element to render all JQueryUI dialogs in.
    *   Currently the only dialog which is displayed is IdCardDialog, but this should be used for any future
    *   dialogs as well, in order to work with Fabric's dialog model.
    *   If this is not specified, JQueryUI's default is to append the dialog element to the <body> element.
    **/
    dialogAppendTo?: string;
    /**
     *  (optional) When turned on, the "No identities found" dropdown message will not be displayed.
     *  Default is true
    **/
    showNoIdentitiesFound?: boolean;
}
export interface IIdentityPickerDropdownEventOptions {
    /**
    *   Unique identifier that will be sent as data in events generated by this instance to distinguish it from other instances of this control
    **/
    uniqueId: string;
}
export class IdentityPickerDropdownControl extends Controls.Control<IIdentityPickerDropdownOptions> {
    /**
    *   This is intended for usage by unit tests only
    **/
    static SHOW_DROPDOWN_EVENT_INTERNAL: string;
    static HIDE_DROPDOWN_EVENT_INTERNAL: string;
    static UPDATE_ACTIVE_DESCENDANT_ID: string;
    static DROPDOWN_BASE_CLASS: string;
    static IMAGE_MARGINS_PX: number;
    private static MIN_WIDTH;
    private static MAX_HEIGHT;
    private static DROPDOWN_BORDER_PX;
    private static IP_AUTHORIZATION_EXCEPTION_DETAILS_LINK;
    private static AVATAR_CLASS;
    private _displayedEntities;
    private _mruEntities;
    private _isSearchActive;
    private _isDirectorySearchEnabled;
    private _showOnlyMruIdentities;
    private _$suggestedPeople;
    private _$itemsContainer;
    private _$searchResultStatus;
    private _$liveStatus;
    private _selectedIndex;
    private _numItemsDisplayed;
    private _scrollTimeout;
    private _indexedEntityMap;
    private _prefix;
    private _isVisible;
    private _identityType;
    private _operationScope;
    private _preDropdownRender;
    private _onDirectorySearchFinished;
    private _controlLoaded;
    private _loadOnCreate;
    private _size;
    private _baseAlign;
    private _elementAlign;
    private _positioningElement;
    private _eventOptions;
    private _showContactCard;
    private _isDropdownVisibleInitially;
    private _entityOperationsFacade;
    private _isFiltered;
    private _isRepositioning;
    constructor(options?: IIdentityPickerDropdownOptions);
    /**
    *   For internal / unit testing use only
    **/
    initializeOptionsInternal(options?: IIdentityPickerDropdownOptions): void;
    initializeOptions(options?: IIdentityPickerDropdownOptions): void;
    initialize(): void;
    getItemsListId(): string;
    load(): IPromise<boolean>;
    /**
    * Adds the identity to the querying identity's MRU
    **/
    addIdentitiesToMru(localIds: string[]): void;
    /**
    * Returns true if the dropdown is currently being shown
    **/
    isVisible(): boolean;
    /**
    * Returns true if the prefix was used for filtering the identities in the dropdown
    **/
    isFiltered(): boolean;
    showAllMruIdentities(selectFirstByDefault?: boolean): IPromise<Identities_Picker_RestClient.IEntity[]>;
    /**
    * Get Identities
    */
    getIdentities(prefix: string, selectFirstByDefault?: boolean): IPromise<Identities_Picker_RestClient.IEntity[]>;
    /**
    * Show the dropdown
    **/
    show(): void;
    /**
    * Hide the dropdown
    **/
    hide(e?: JQueryEventObject, suppressHideEvent?: boolean): void;
    getSelectedIndex(): number;
    getSelectedItem(): Identities_Picker_RestClient.IEntity;
    handleKeyEvent(e: JQueryEventObject): boolean;
    getPrefix(): string;
    /**
    * Set the prefix but does not update the list
    **/
    updatePrefix(prefix: string): void;
    dispose(): void;
    reset(): void;
    private static getClassSelector;
    private _getEntityOperationsFacade;
    private _getUserMruEntitiesPostLoad;
    private _enableDirectorySearch;
    private _disableDirectorySearch;
    private _resetSearchStatuses;
    private _getIdentitiesPostLoad;
    private _getDirectoryEntitiesWithRender;
    private _checkIfServerException;
    private _getMessageForIpsAuthorizationException;
    private _getDirectoryEntities;
    private _getImagesForDisplayedEntities;
    private _showPostLoad;
    private _handleScrollAndResize;
    private _constructDropdown;
    /**
    * Removes the identity from the querying identity's MRU
    **/
    private _removeIdentityFromMru;
    /**
    *   keepIndex: Keep the index of the selected identity at the current location
    **/
    private _alterStateAndRender;
    private _fireActiveDescendantUpdate;
    /**
    * Scroll to selected item
    **/
    private _setSelectedIndex;
    private _scrollItemIntoView;
    /**
    * Set the position of this control with respect to its parent
    **/
    private _setPosition;
    private _getPositioningElement;
    /**
    * Show the status indicator till all users are loaded
    **/
    private _showLoading;
    /**
    * Show error message in case of non-2xx response
    **/
    private _showError;
    private _nextPage;
    private _prevPage;
    private _nextItem;
    private _prevItem;
    private _selectItem;
    private _clearItemsSelection;
    /**
    * Create the li that shall represent an user item
    **/
    private _createItem;
    private _logSelectedEntity;
    private _setupDom;
    private _showAdditionalInformation;
    private _setupEntitiesInDom;
    private _constructSearchResultStatus;
    private _constructSearchButton;
    private _constructInformativeMessage;
    private _loadNextPage;
    private _searchButtonClickDelegate;
}
export interface IIdentityPickerIdCardDialogOptions extends Identities_Picker_Services.IIdentityServiceOptions, Identities_Picker_Services.IIdentityPickerExtensionOptions {
    /**
    *   an identity to initialize with (and to avoid a call to the identity picker service API)
    **/
    identity?: Identities_Picker_RestClient.IEntity;
    /**
    *   the uniqueIdentifier of the identity which shall be used for resolving the IdCardDialog - signInAddress or entityId for users and entityId for other kinds of entities
    **/
    uniqueIdentifier?: string;
    /**
    *   The left positioning offset of the dialog
    **/
    leftValue?: number;
    /**
    *   The top positioning offset of the dialog
    **/
    topValue?: number;
    /**
    *   A base element which shall be used as reference for positioning the dialog
    **/
    anchor?: JQuery;
    /**
    *   An optional container of the anchor to be considered. Passing an iframe allows for positioning over an anchor in an other frame.
    **/
    anchorContainer?: JQuery;
    /**
    *   An element that will receive focus when the contact card is closed. If unset, the focus will go to the previously active element
    **/
    focusElementOnClose?: JQuery;
    /**
    *   Defined by JQueryUI.DialogOptions -- optional JQuery selector string for element to append dialog to, instead of DOM root
    **/
    appendTo?: string;
    /**
    *   (optional) Determines whether the new profile card should be used. Requires a dependency on Office Fabric.
    *   Default is false inside extensions, otherwise true.
    **/
    useOfficeFabricProfileCard?: boolean;
}
export class IdCardDialog extends Controls.Control<IIdentityPickerIdCardDialogOptions> {
    static IDCARD_LOADED_EVENT: string;
    private static MAX_HEIGHT;
    private static IMAGE_MARGINS_PX;
    private static MEMBERS_TAB_LEFT_PADDING_PX;
    private static ID_CARD_LIST_CLASS;
    private static ID_CARD_MEMBERS_DROPDOWN_CLASS;
    private static JQUERY_UI_DIALOG_CLASS;
    private static ID_CARD_DIALOG_ID;
    private _identityType;
    private _operationScope;
    private _identity;
    private _$idCardDialog;
    private _scrollTimeout;
    private _numItemsDisplayed;
    private _groupMembers;
    private _$groupMembersContainer;
    private _pageSize;
    private _$loading;
    private _$liveStatus;
    private _entityOperationsFacade;
    private _previousFocusedElement;
    private _selectedIndex;
    constructor(options?: IIdentityPickerIdCardDialogOptions);
    initializeOptions(options?: IIdentityPickerIdCardDialogOptions): void;
    initialize(): void;
    private _getEntityOperationsFacade;
    private static _getHigherZIndex;
    private _repositionDialog;
    private _getDirectoryEntities;
    private _getIdentitiesFailure;
    private _getIdentitiesSuccess;
    private _displayReactIdCard;
    private _displayIdCard;
    private _constructMemberTabContent;
    private _getDirectoryMemberEntities;
    private _isMembersListVisible;
    private _onIdCardBlur;
    private _onIdCardClose;
    private _onKeyDown;
    private _createItem;
    private _renderMembersList;
    private _loadNextPage;
    private _nextItem;
    private _prevItem;
    private _nextPage;
    private _prevPage;
    private _setSelectedIndex;
}
export interface ISearchControlCallbackOptions {
    /**
    *   action that should execute when an item in this dropdown is selected. This action, if supplied, shall be called after the dropdown's default onItemSelect action has executed
    **/
    onItemSelect?: (item: Identities_Picker_RestClient.IEntity) => any;
    /**
    *   action that should execute when the input field loses focus. This action, if supplied, shall be called after the control's default onInputBlur action has executed
    **/
    onInputBlur?: () => any;
    /**
    *   action that should execute when a key is pressed. This action, if supplied, shall be called before the dropdown's default onKeyPress action has executed to allow for overrides
    **/
    onKeyPress?: (keyCode: number) => any;
    /**
    *   a pre-render hook that takes in the list of identities that would otherwise have been displayed and rearranges or adds to them prior to returning the new list
    **/
    preDropdownRender?: (entityList: Identities_Picker_RestClient.IEntity[]) => Identities_Picker_RestClient.IEntity[];
    /**
    *   callback for a custom tooltip to be displayed for the single-select search control instead of the display name and sign-in address of the resolved identity
    **/
    getCustomTooltip?: () => string;
    /**
    *   callback allowing to peek at the search results (after rendering). Will not get executed for MRU-only searches. The callback function should not alter the rendered list
    **/
    onDirectorySearchFinished?: (identityList: Identities_Picker_RestClient.IEntity[]) => void;
}
export interface IIdentityPickerSearchOptions extends Identities_Picker_Services.IIdentityServiceOptions, Identities_Picker_Services.IIdentityPickerExtensionOptions {
    /**
    *   default identities to initialize the search control with - if you are constructing the IEntity objects, their identifiers (such as entityId, localId etc.) have to be valid;
    *   alternatively the input can be a semi-colon separated sequence of unique identifiers (such as sign-in addresses, vsIds, entityIds or SubjectDescriptors).
    *   We also support the format "DisplayName <UniqueIdentifier>" (see the option showTemporaryDisplayName for details)
    **/
    items?: string | Identities_Picker_RestClient.IEntity[];
    /**
    *   restrict displayed identities in dropdown
    **/
    pageSize?: number;
    /**
    *   DEPRECATED: the minimum length of the prefix to start searching the directories - in the absence of an MRU - default 3
    **/
    minimumPrefixSize?: number;
    /**
    *   whether the search and dropdown controls should handle multiple identities
    **/
    multiIdentitySearch?: boolean;
    /**
    *   whether to display the contact card icon for each identity in the dropdown and for resolved identities. Default false.
    **/
    showContactCard?: boolean;
    /**
    *   whether to style the search control with a triangle that displays the MRU on click or not. Default false. Setting this will also enable the MRU on the dropdown.
    **/
    showMruTriangle?: boolean;
    /**
    *   whether the dropdown should display the MRU with the search button or just search directories directly.
    *   Default false.
    **/
    showMru?: boolean;
    /**
    *   whether to preload (e.g. the MRU identities) on control creation.
    **/
    loadOnCreate?: boolean;
    /**
    *   whether for a single-select control a click on the resolved item highlights the text (true) or opens the contact card (false - default)
    **/
    highlightResolved?: boolean;
    /**
    *   the size of the search control elements (Small - most elements are 16px in height, Medium - 24px, Large - 32px). Default: Medium
    **/
    size?: IdentityPickerControlSize;
    /**
    *   the size of the dropdown control elements (Medium - most elements are 24px, Large - 32px). Default: Large
    **/
    dropdownSize?: IdentityPickerControlSize;
    /**
    *   custom value for the placeholder attribute of the input element.
    *   Defaults to "Search {identity type(s)}", where {identity type(s)} can be "users", "groups" or "users and groups".
    **/
    placeholderText?: string;
    /**
    *   custom value for the aria-label attribute of the input element.
    *   Defaults to the placeholder value if not set (see option placeholderText for details)
    **/
    ariaLabel?: string;
    /**
    *   Don't include aria label regardless if aria label is set or is the default (the place holder value).
    *   Defaults to false, which is to include.
    **/
    excludeAriaLabel?: boolean;
    /**
     * Use this to mark the input as required in the DOM
     */
    required?: boolean;
    /**
     * Use this to announce some help text
     */
    ariaDescribedby?: string;
    /**
    *   a custom id for the input element
    **/
    elementId?: string;
    /**
    *   an IEntity to be displayed by default instead of the empty input element
    **/
    watermark?: Identities_Picker_RestClient.IEntity;
    /**
    *   the width of the dropdown control. Default is max(positioningElement width, 300px)
    **/
    dropdownWidth?: number;
    /**
    *   Callbacks supported by the search control
    **/
    callbacks?: ISearchControlCallbackOptions;
    /**
    *   in case the control gets initialized with items in the format "DisplayName <UniqueIdentifier>",
    *   whether to show the DisplayName until the UniqueIdentifier gets resolved to an IEntity. Default false
    **/
    showTemporaryDisplayName?: boolean;
    /**
    *   Specifies whether or not the dropdown will be forced open and not closable until the control is destroyed.
    *   This is specifically for the mobile work item form where we want to show the picker in a full screen view
    *   and we do not want the dropdown to close.
    **/
    forceOpen?: boolean;
    /**
    *   Specifies whether or not the dropdown will try to use all remaining space below the positioning element.
    *   For internal use only, this is specifically for the mobile work item form where we want to show the picker in a
    *   full screen view and the behavior may change over time.
    **/
    useRemainingSpace?: boolean;
    /**
    *   Optimizations for small screen (mobile) which renders controls with additional icons and
    *   text information suitable for small screens.
    */
    smallScreenRender?: boolean;
    /**
    *   (optional) JQuery selector string which specifies a DOM element to render all JQueryUI dialogs in.
    *   Currently the only dialog which is displayed is IdCardDialog, but this should be used for any future
    *   dialogs as well, in order to work with Fabric's dialog model.
    *   If this is not specified, JQueryUI's default is to append the dialog element to the <body> element.
    **/
    dialogAppendTo?: string;
    /**
    *   (optional) Determines whether the new profile card should be used. Requires a dependency on Office Fabric.
    *   Default is false inside extensions, otherwise true.
    **/
    useOfficeFabricProfileCard?: boolean;
    /**
     * (optional) Specifies whether to enforce the rendering of search results in multi-select versions of the control in the same order as
     * the provided input tokens.
     *
     * Limitation:
     * The order is not guaranteed to be preserved when the input exceeds 50 tokens (page size), due to the paging logic.
     * Within the page, the results will be ordered.
     *
     * Defaults to false.
     */
    retainInputIdentitiesSequenceWithinPage?: boolean;
    /**
     * (optional) When turned on, the MRU list will be displayed when a user first clicks into the input.
     * Default is false
     */
    showMruOnClick?: boolean;
    /**
     * (optional) When turned on, the "No identities found" dropdown message will not be displayed.
     * Default is true
     */
    showNoIdentitiesFound?: boolean;
}
/**
 * @exemptedapi
 * For internal unit testing use only
 */
export interface IIdentityPickerSearchTestOptions {
    /**
    *   Return the container that is to be used for the dropdown - default is body
    **/
    dropdownContainer?: (container?: JQuery) => JQuery;
}
/**
 * @exemptedapi
 * For internal unit testing use only
 */
export interface IIdentityPickerSearchOptionsInternal extends IIdentityPickerSearchOptions, IIdentityPickerSearchTestOptions {
}
export interface IIdentityPickerControlInteractable {
    enableReadOnlyMode(): any;
    disableReadOnlyMode(): any;
}
export class IdentityPickerSearchControl extends Controls.Control<IIdentityPickerSearchOptions> implements IdentityPickerSearchControl {
    static INVALID_INPUT_EVENT: string;
    static VALID_INPUT_EVENT: string;
    static RESOLVED_INPUT_REMOVED_EVENT: string;
    static SEARCH_STARTED_EVENT: string;
    static SEARCH_FINISHED_EVENT: string;
    static DIALOG_MOVE_EVENT: string;
    static readonly SEQUENCED_IDENTITIES_IN_PAGE_RESOLVED_EVENT_INTERNAL: string;
    static SEARCH_MRU_TRIANGLE_CLASS: string;
    private static DEFAULT_WIDTH;
    private static OUTER_PADDING_PX;
    private static TRIANGLE_WIDTH_PX;
    private static NAME_PADDING_PX;
    private static INACTIVE_ENTITY_TYPE;
    private static INACTIVE_ENTITY_ID_PREFIX;
    private static INACTIVE_ORIGIN_ID_PREFIX;
    private _identityPickerDropdown;
    private _identityPickerDropdownUniqueId;
    private _identityType;
    private _operationScope;
    private _selectedItems;
    private _unresolvedItems;
    private _$input;
    private _$closeInput;
    private _$container;
    private _$mruTriangle;
    private _$currentlyFocusedItem;
    private _controlWidth;
    private _resolvedIEntity;
    private _preDropdownRender;
    private _onDirectorySearchFinished;
    private _placeholderText;
    private _controlLoaded;
    private _loadOnCreate;
    private _size;
    private _dropdownShowEventDelegate;
    private _dropdownHideEventDelegate;
    private _updateActiveDescendantIdEventDelegate;
    private _previousInput;
    private _externalEventDelegate;
    private _showContactCard;
    private _dropdownContainerDelegate;
    private _isSearchEverIssued;
    private _readOnlyMode;
    private _showMruExpander;
    private _trackTabKeyDown;
    private _queryTokensRequested;
    private _entityOperationsFacade;
    constructor(options?: IIdentityPickerSearchOptions, testUse?: boolean);
    /**
    *   To be used only by unit tests
    **/
    initializeOptionsInternal(options: IIdentityPickerSearchOptionsInternal): void;
    private _onDocumentLoad;
    initialize(): void;
    load(): IPromise<boolean>;
    getIdentitySearchResult(): IdentitySearchResult;
    clear(): void;
    isDropdownVisible(): boolean;
    isDropdownFiltered(): boolean;
    addIdentitiesToMru(identities: Identities_Picker_RestClient.IEntity[]): void;
    /**
    * Appends to the search control's entities - this expects valid IEntity objects or valid query tokens - such as unique email addresses - entity objects must have been retrieved at some point from the control or DDS, or created using EntityFactory
    **/
    setEntities(entities: Identities_Picker_RestClient.IEntity[], queryTokens: string[], operationScope?: Identities_Picker_Services.IOperationScope): void;
    getDropdownPrefix(): string;
    showMruDropdown(): void;
    /**
    * Focuses on the visible input element or on an available resolved/unresolved item if the input is hidden. It also triggers the focus event on the container element for eventual styling
    **/
    focusOnSearchInput(): void;
    enableReadOnlyMode(): void;
    disableReadOnlyMode(): void;
    /**
     * getValue returns "" while an identity is being resolved, but we need to know
     * if the control is actually empty vs temporarily empty.
     */
    hasPendingRequests(): boolean;
    dispose(): void;
    private _getEntityOperationsFacade;
    private _isReadOnly;
    private _hideMruTriangle;
    private _showMruTriangle;
    private _getAriaDescribedby;
    private _resetSearchControl;
    /**
    *   Clears but does not recreate the watermark
    **/
    private _clearSearchControl;
    private _showAllMruInDropdownWithoutDefaultSelection;
    private _showAllMruInDropdown;
    private _showProgressCursor;
    private _stopProgressCursor;
    private _fireInvalidInput;
    private _fireValidInput;
    private _fireRemoveResolvedInput;
    private _updateActiveDescendantId;
    private _isShowMruEnabledInDropdown;
    private _attachHandlersOnShowDropdown;
    private _detachHandlersOnHideDropdown;
    private _hideDropdown;
    private _showDropdown;
    private _compareInputOnInputChangeEvent;
    private _setInputText;
    private _resetPreviousInput;
    private _onInputChange;
    private _onInputClick;
    private _onMruTriangleMousedown;
    private _onMruTriangleClick;
    private _isDropdownHovered;
    private _isContactCardHovered;
    private _onInputBlur;
    private _focusOnResolvedItem;
    private _onInputKeyDown;
    private _fireInputValidityEvent;
    private _resolveSelectedItem;
    private _onInputKeyUp;
    private _removeFromUnresolved;
    private _removeFromResolved;
    getInputText(): string;
    private _resolveInputToIdentities;
    private _resolveIdentityResponseInSequence;
    private _recalculateInputWidth;
    private _replaceAndCleanup;
    private _findInSelectedItems;
    private _showIdCardDialog;
    private _clearWatermark;
    private _showWatermark;
    private _createTemporaryItem;
    private _isControlInFocus;
    private _createResolvedItem;
    private _setResolvedItemRole;
    private _resolveItem;
    private _getItemNameContainerMaxWidth;
    private _createCloseButton;
    private _getSearchPrefix;
    private _unresolveItem;
    private _generatePlaceHolder;
    private _isInArray;
}
export interface IdentitySearchResult {
    resolvedEntities: Identities_Picker_RestClient.IEntity[];
    unresolvedQueryTokens: string[];
}
export enum IdentityPickerControlSize {
    Small = 0,
    Medium = 1,
    Large = 2
}
export interface IIdentityDisplayOptions extends Identities_Picker_Services.IIdentityServiceOptions, Identities_Picker_Services.IIdentityPickerExtensionOptions {
    /**
    *   the identity to be displayed - if you are constructing the IEntity object, its identifiers (such as entityId, localId etc.) have to be valid;
    *   alternatively the input can be a unique identifier (such as a sign-in address or alias)
    **/
    item: string | Identities_Picker_RestClient.IEntity;
    /**
    *   the size of the control elements (Small - most elements are 16px in height, Medium - 24px, Large - 32px). Default: Medium
    **/
    size?: IdentityPickerControlSize;
    /**
    *   Determines what is shown in the control
    **/
    displayType?: EDisplayControlType;
    /**
    *   the string to be shown before the IEntity gets resolved
    **/
    friendlyDisplayName?: string;
    /**
    *   Turn off the hover effect. Default: false
    **/
    turnOffHover?: boolean;
    /**
    *   (optional) JQuery selector string which specifies a DOM element to render all JQueryUI dialogs in.
    *   Currently the only dialog which is displayed is IdCardDialog, but this should be used for any future
    *   dialogs as well, in order to work with Fabric's dialog model.
    *   If this is not specified, JQueryUI's default is to append the dialog element to the <body> element.
    **/
    dialogAppendTo?: string;
}
export enum EDisplayControlType {
    AvatarText = 0,
    AvatarOnly = 1,
    TextOnly = 2
}
export class IdentityDisplayControl extends Controls.Control<IIdentityDisplayOptions> {
    private static DEFAULT_HOVER_WAIT_ENTER_INTERVAL;
    private static DEFAULT_HOVER_WAIT_EXIT_INTERVAL;
    private static MIN_WIDTH;
    private static OUTER_PADDING_PX;
    private _identityType;
    private _operationScope;
    private _size;
    private _displayType;
    private _hoverIdCardEnterTimer;
    private _hoverIdCardExitTimer;
    private _displayedEntity;
    private _turnOffHover;
    private _showIdCard;
    private _entityOperationsFacade;
    constructor(options?: IIdentityDisplayOptions);
    initialize(): void;
    getDisplayedEntity(): Identities_Picker_RestClient.IEntity;
    private _getEntityOperationsFacade;
    private _resolveStringToEntity;
    private _showIdCardDialog;
    private _displayString;
    private _displayEntity;
}
/**
*   Contruct an IEntity from a string.
*   Creation is only intended to be called by the controls here, public due to lack of internal-like keywords in ts.
*   isStringEntity and isStringEntityId are publicly supported.
**/
export class EntityFactory {
    static STRING_ENTITY_TYPE: string;
    private static STRING_ENTITY_ID_PREFIX;
    private static STRING_DIRECTORY;
    private static STRING_ORIGIN_ID_PREFIX;
    private static STRING_LOCAL_ID_PREFIX;
    static createStringEntity(displayName: string, imageUrl?: string): Identities_Picker_RestClient.IEntity;
    static isStringEntityId(entityId: string): boolean;
    static isStringPrefixedLocalId(localId: string): boolean;
}
/**
 * @exemptedapi
 * Each registered source for entity retrieval
 */
export class SourceId {
    static Directory: string;
    static Mru: string;
    static Persistent: string;
    static String: string;
}
/**
 * @exemptedapi
 */
export enum SourceType {
    Sync = 0,
    Async = 1
}
/**
 * @exemptedapi
 */
export interface ISource {
    id: string;
    sortRank: number;
    sourceType: SourceType;
}
/**
 * @exemptedapi
 */
export interface ISyncSource extends ISource {
    getEntities(currentEntitySet: Identities_Picker_RestClient.IEntity[], request: IEntityOperationsFacadeRequest): Identities_Picker_RestClient.IEntity[];
}
/**
 * @exemptedapi
 */
export interface IEntityOperationsFacadeResponse {
    queryTokenResponse?: IDictionaryStringTo<IPromise<Identities_Picker_RestClient.QueryTokenResultModel>>;
    entityResponse?: Identities_Picker_RestClient.IEntity[];
}
/**
 * @exemptedapi
 */
export interface IEntityOperationsFacadeRequest {
    sources: string[];
    identityServiceOptions: Identities_Picker_Services.IIdentityServiceOptions;
    identityExtensionOptions?: Identities_Picker_Services.IIdentityPickerExtensionOptions;
    prefix?: string;
    queryTypeHint?: Identities_Picker_Services.IQueryTypeHint;
    filterByScope?: Identities_Picker_Common.FilterByScope;
}
/**
 * @exemptedapi
 */
export interface IEntityOperationsFacadeOptions {
    loadMru?: boolean;
    filterByScope?: Identities_Picker_Common.FilterByScope;
}
/**
 * @exemptedapi
 */
export class EntityOperationsFacade extends Service.VssService {
    private _entityRetrieverPrepComplete;
    private _mruEntitiesPromise;
    private _userMruReady;
    private _mruEntities;
    private _syncSources;
    private _requestStack;
    private _deferredStack;
    queryTokenEntityImageCache: Identities_Picker_Cache.HashCache<string>;
    constructor();
    registerSyncSource(source: ISyncSource): void;
    search(request: IEntityOperationsFacadeRequest): IPromise<IEntityOperationsFacadeResponse>;
    isUserMruReady(filterByScope: Identities_Picker_Common.FilterByScope): boolean;
    getMruEntitiesUnchecked(filterByScope: Identities_Picker_Common.FilterByScope): Identities_Picker_RestClient.IEntity[];
    refreshUserMru(filterByScope: Identities_Picker_Common.FilterByScope): IPromise<boolean>;
    load(options?: IEntityOperationsFacadeOptions): Q.Promise<boolean>;
    /**
    *   Return only the MRU users or groups that have the prefix
    **/
    static filterEntities(identities: Identities_Picker_RestClient.IEntity[], prefix: string): Identities_Picker_RestClient.IEntity[];
    /**
    *   This is the default way the controls internally merge MRU and DDS entities entities.
    *   Assumes that list1 and list2 are lists of distinct entities.
    *   Use-cases apart from calls by the controls here are not supported; provided as a example of merging logic.
    **/
    static mergeEntities(list1: Identities_Picker_RestClient.IEntity[], list2: Identities_Picker_RestClient.IEntity[], mergePreference?: string): Identities_Picker_RestClient.IEntity[];
    getImagesForEntities(entities: Identities_Picker_RestClient.IEntity[], request?: IEntityOperationsFacadeRequest): IPromise<IDictionaryStringTo<string>>;
    /**
    *   This is the default way the controls internally fetch the key for disambiguating entities.
    *   Use-cases apart from calls by the controls here are not supported; provided as an example of merging logic.
    **/
    private static _getMergingKeyFromEntity;
    private static _mergeSimilarEntities;
    private static _computeValue;
    private static _filterMruEntitiesByIdentityType;
    private _mruSourceGetEntitiesHandler;
    private _directorySourceGetEntities;
    private _getRegisteredSyncSourcesSorted;
    /**
    * Get the querying identity's MRU
    **/
    private _getUserMruEntities;
}
}
declare module "VSS/Identities/Picker/DefaultAbridgedCard" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import React = require("react");
import Component_Base = require("VSS/Flux/Component");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
export interface DefaultAbridgedCardProps extends Component_Base.Props {
    /**
     * Identity object for persona and contact information.
     */
    identity: Identities_Picker_RestClient.IEntity;
    /**
    * Publish telemetry on card load
    */
    publishTelemetry: (cardType: string, action: string) => void;
}
export class DefaultAbridgedCard extends React.Component<DefaultAbridgedCardProps, {}> {
    render(): JSX.Element;
    private _verifySignInAddress;
}
}
declare module "VSS/Identities/Picker/DefaultCard" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import React = require("react");
import Component_Base = require("VSS/Flux/Component");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
/**
 * Definitions for DefaultCardContactLine (used by DefaultCard).
 */
export interface DefaultCardContactLineProps extends Component_Base.Props {
    /**
    * Name for icon.
    */
    iconName?: string;
    /**
    * Content for line.
    */
    content?: string;
    /**
    * Link (if not link, left blank).
    */
    link?: string;
    /**
    * Publish telemetry on contact information click
    */
    publishTelemetry?: (componentType: string, action: string) => void;
}
export class DefaultCardContactLine extends React.Component<DefaultCardContactLineProps, {}> {
    render(): JSX.Element;
}
/**
 * Definitions for DefaultCard.
 */
export interface DefaultCardProps extends Component_Base.Props {
    /**
     * Identity object for persona and contact information.
     */
    identity?: Identities_Picker_RestClient.IEntity;
    /**
     * Direct manager identity object.
     */
    manager?: Identities_Picker_RestClient.IEntity;
    /**
     * Previous header exists boolean.
     */
    isPreviousHeader?: boolean;
    /**
     * Method to show contact card.
     */
    showContactCard?: () => void;
    /**
     * Method to show organization card.
     */
    showOrganizationCard?: () => void;
    /**
     * Method to handle identity click.
     */
    onClickEntity?: (identifier: string | Identities_Picker_RestClient.IEntity) => void;
    /**
     * Publish telemetry on card load
    */
    publishTelemetry: (componentType: string, action: string, source?: string) => void;
    /**
    * Function to set the focus to first active element of focuszone on update of the card.
    */
    setFocus?: () => void;
}
export class DefaultCard extends React.Component<DefaultCardProps, {}> {
    componentDidMount(): void;
    render(): JSX.Element;
    /**
     * Renders the direct manager for the persona.
     * @param managerPersona The manager persona.
     */
    private _renderDirectManagerElement;
}
}
declare module "VSS/Identities/Picker/DefaultSimpleCard" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import React = require("react");
import Component_Base = require("VSS/Flux/Component");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
export interface DefaultSimpleCardProps extends Component_Base.Props {
    /**
     * Identity object for persona and contact information.
     */
    identity: Identities_Picker_RestClient.IEntity;
}
export class DefaultSimpleCard extends React.Component<DefaultSimpleCardProps, {}> {
    render(): JSX.Element;
}
}
declare module "VSS/Identities/Picker/OrganizationCard" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import React = require("react");
import Component_Base = require("VSS/Flux/Component");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
export interface OrganizationCardProps extends Component_Base.Props {
    /**
     * Identity object for persona and contact information.
     */
    identity?: Identities_Picker_RestClient.IEntity;
    /**
     * List of managers.
     */
    managerList?: Identities_Picker_RestClient.IEntity[];
    /**
     * List of direct reports.
     */
    directReportList?: Identities_Picker_RestClient.IEntity[];
    /**
     * Method to handle identity click.
     */
    onClickEntity?: (identifier: string | Identities_Picker_RestClient.IEntity) => void;
    /**
    * Publish telemetry on card load
    */
    publishTelemetry: (cardType: string, action: string, source?: string) => void;
}
export class OrganizationCard extends React.Component<OrganizationCardProps, {}> {
    render(): JSX.Element;
    private createManagerChainPersonaElements;
    private createDirectReportsPersonaElements;
}
}
declare module "VSS/Identities/Picker/PersonaCard" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import * as Component_Base from "VSS/Flux/Component";
import { IDataState, PersonaCardProps } from "VSS/Identities/Picker/PersonaCardContracts";
import * as Identities_Picker_Services from "VSS/Identities/Picker/Services";
export const sourceOperationScope: Identities_Picker_Services.IOperationScope;
export const sourceAdOperationScope: Identities_Picker_Services.IOperationScope;
export const sourceImsOperationScope: Identities_Picker_Services.IOperationScope;
export const sourceImsAdOperationScope: Identities_Picker_Services.IOperationScope;
export const userIdentityType: Identities_Picker_Services.IEntityType;
export const managerAndDirectReportsConnectionType: Identities_Picker_Services.IConnectionType;
export const managerConnectionType: Identities_Picker_Services.IConnectionType;
export interface PersonaCardState extends Component_Base.State {
    /** Mimics stack to allow for breadcrumb */
    dataState: IDataState;
    /** Prevent requests if working */
    working: boolean;
}
export const PersonaCard: (props: PersonaCardProps) => JSX.Element;
}
declare module "VSS/Identities/Picker/PersonaCardContent" {
import * as React from "react";
import * as Component_Base from "VSS/Flux/Component";
import { IDataState, PersonaCardProps } from "VSS/Identities/Picker/PersonaCardContracts";
import * as Identities_Picker_RestClient from "VSS/Identities/Picker/RestClient";
export interface PersonaCardContentProps extends Component_Base.Props, PersonaCardProps {
    dataProps: IDataState;
    onClickEntity?: (identity: Identities_Picker_RestClient.IEntity) => void;
    onHeaderClick?: () => void;
    onShowOrganizationCard?: () => void;
    onShowContactCard?: () => void;
    working?: boolean;
}
/**
 * The content of the callout for the persona card. See the associated wiki page for design details:
 * https://mseng.visualstudio.com/VSOnline/_wiki?pagePath=%2FWorking-with-the-React-Profile-Card
 */
export class PersonaCardContent extends React.Component<PersonaCardContentProps> {
    private _focusZone;
    componentDidMount(): void;
    componentDidUpdate(): void;
    render(): JSX.Element;
    private _renderCard;
    private _onFocusZoneRef;
    private _focusOnUpdate;
    private _renderInnerCard;
    private _onDismissCallout;
    private _publishTelemetry;
}
}
declare module "VSS/Identities/Picker/PersonaCardContracts" {
import * as Component_Base from "VSS/Flux/Component";
import * as Picker_Controls from "VSS/Identities/Picker/Controls";
import { HeaderElementProps } from "VSS/Identities/Picker/PersonaCardHeaderElement";
import * as Identities_Picker_RestClient from "VSS/Identities/Picker/RestClient";
import { IPoint } from "VSS/Identities/Picker/Common";
export enum CardType {
    Default = 0,
    Contact = 1,
    Organization = 2
}
export interface IDataState {
    header: Identities_Picker_RestClient.IEntity;
    identity: Identities_Picker_RestClient.IEntity;
    managerList: Identities_Picker_RestClient.IEntity[];
    directReportList: Identities_Picker_RestClient.IEntity[];
    previousDataState: IDataState;
    cardType: CardType;
    displayName: string;
    imageUrl: string;
    email: string;
    source?: string;
}
export namespace personaCardEntity {
    const contactCard = "ContactCard";
    const clicked = "Clicked";
    const featureName = "PersonaCard";
    const loaded = "Loaded";
    const orgCard = "OrgCard";
    const orgCardManagerChain = "OrgCardManagerChain";
    const orgCardDirectReport = "OrgCardDirectReport";
    const personaCard = "PersonaCard";
    const reportingManager = "ReportingManager";
}
export interface PersonaCardProps extends Component_Base.Props {
    identity?: Identities_Picker_RestClient.IEntity;
    uniqueAttribute?: string;
    consumerId: string;
    entityOperationsFacade: Picker_Controls.EntityOperationsFacade;
    initialHeader?: HeaderElementProps;
    displayName?: string;
    imageUrl?: string;
    referenceHTMLComponent?: HTMLElement;
    target?: HTMLElement | IPoint;
    onDismissCallback?: () => void;
    consumer?: string;
}
}
declare module "VSS/Identities/Picker/PersonaCardHeaderElement" {
/// <amd-dependency path="VSS/LoaderPlugins/Css!PersonaCard" />
import React = require("react");
import * as Component_Base from "VSS/Flux/Component";
import * as Identities_Picker_RestClient from "VSS/Identities/Picker/RestClient";
/**
 * Definitions for HeaderElement used by PersonaCard.
 */
export interface HeaderElementProps extends Component_Base.Props {
    /**
    * Current data state (can be null).
    */
    identity?: Identities_Picker_RestClient.IEntity;
    /**
    * Function on click (show default card or pop breadcrumb).
    */
    onClickFunction?: () => void;
    /**
    * Function to set the focus to first active element of focuszone on update of the card.
    */
    setFocus?: () => void;
}
export class PersonaCardHeaderElement extends React.Component<HeaderElementProps, {}> {
    private _personaElement;
    componentDidMount(): void;
    componentDidUpdate(): void;
    constructor(props: HeaderElementProps);
    render(): JSX.Element;
    /**
     * Sets the focus on this header.
     */
    setFocus(): void;
}
}
declare module "VSS/Identities/Picker/PersonaCardIdentityUtils" {
import * as Identities_Picker_RestClient from "VSS/Identities/Picker/RestClient";
export function isCompleteIdentity(identity: Identities_Picker_RestClient.IEntity): boolean;
export function isAadUser(identity: Identities_Picker_RestClient.IEntity): boolean;
export function isAdUser(identity: Identities_Picker_RestClient.IEntity): boolean;
export function isVsdUser(identity: Identities_Picker_RestClient.IEntity): boolean;
export function isWmdUser(identity: Identities_Picker_RestClient.IEntity): boolean;
}
declare module "VSS/Identities/Picker/RestClient" {
import WebApi_RestClient = require("VSS/WebApi/RestClient");
/**
 * @exemptedapi
 */
export class AbstractIdentityPickerHttpClient extends WebApi_RestClient.VssHttpClient {
    beginGetIdentities(identitiesRequest: IdentitiesSearchRequestModel): IPromise<IdentitiesSearchResponseModel>;
    beginGetIdentityImageLocation(objectId: string): IPromise<string>;
    beginGetConnections(objectId: string, getRequestParams: IdentitiesGetConnectionsRequestModel): IPromise<IdentitiesGetConnectionsResponseModel>;
    beginGetIdentityFeatureMru(identityId: string, featureId: string, getRequestParams: IdentitiesGetMruRequestModel): IPromise<IdentitiesGetMruResponseModel>;
    beginPatchIdentityFeatureMru(identityId: string, featureId: string, patchRequestBody: IdentitiesPatchMruAction[]): IPromise<IdentitiesPatchMruResponseModel>;
}
/**
 * @exemptedapi
 */
export class CommonIdentityPickerHttpClient extends AbstractIdentityPickerHttpClient {
    private static _identityImageLocation;
    beginGetIdentities(identitiesRequest: IdentitiesSearchRequestModel): IPromise<IdentitiesSearchResponseModel>;
    beginGetIdentityImageLocation(objectId: string): IPromise<string>;
    beginGetConnections(objectId: string, getRequestParams: IdentitiesGetConnectionsRequestModel): IPromise<IdentitiesGetConnectionsResponseModel>;
    beginGetIdentityFeatureMru(identityId: string, featureId: string, getRequestParams: IdentitiesGetMruRequestModel): IPromise<IdentitiesGetMruResponseModel>;
    beginPatchIdentityFeatureMru(identityId: string, featureId: string, patchRequestBody: IdentitiesPatchMruAction[]): IPromise<IdentitiesPatchMruResponseModel>;
}
/**
 *   Identity Picker Models
**/
export interface IEntity {
    /**
    *   Always set. Not to be parsed as any non-string type.
    **/
    entityId: string;
    /**
    *   Always set. e.g. user or group
    **/
    entityType: string;
    /**
    *   Always set. e.g. vsd or aad - aad for AAD-backed/linked accounts, vsd otherwise
    **/
    originDirectory: string;
    /**
    *   Always set. e.g. the objectId in case of AAD sourced entities (AAD-backed/linked accounts).
    **/
    originId: string;
    /**
    *   Set to the IMS vsid in case of non-AAD-backed/linked entities.
    **/
    localDirectory?: string;
    localId?: string;
    displayName?: string;
    scopeName?: string;
    department?: string;
    jobTitle?: string;
    mail?: string;
    mailNickname?: string;
    physicalDeliveryOfficeName?: string;
    signInAddress?: string;
    subjectDescriptor?: string;
    surname?: string;
    guest?: boolean;
    active?: boolean;
    description?: string;
    image?: string;
    manager?: string;
    samAccountName?: string;
    telephoneNumber?: string;
    /**
    *   The isMru field denotes whether this identity was loaded via a MruService operation or an IdentityService operation.
    *   Furthermore, this should not be set for identities that were constructed (for constants etc.)
    **/
    isMru?: boolean;
}
export interface QueryTokenResultModel {
    queryToken: string;
    identities: IEntity[];
    pagingToken?: string;
}
/**
 * @exemptedapi
 */
export interface IdentitiesSearchRequestModel {
    query: string;
    identityTypes: string[];
    operationScopes: string[];
    queryTypeHint?: string;
    pagingToken?: string;
    properties?: string[];
    filterByAncestorEntityIds?: string[];
    filterByEntityIds?: string[];
    options?: any;
}
/**
 * @exemptedapi
 */
export interface IdentitiesSearchResponseModel {
    results: QueryTokenResultModel[];
}
/**
 * @exemptedapi
 */
export interface IdentitiesGetAvatarResponseModel {
    avatar: string;
}
/**
 * @exemptedapi
 */
export interface IdentitiesGetConnectionsRequestModel {
    connectionTypes: string[];
    identityTypes: string[];
    operationScopes: string[];
    depth?: number;
    options?: any;
    pagingToken?: string;
    properties?: string[];
}
/**
 * @exemptedapi
 */
export interface IdentitiesGetConnectionsResponseModel {
    successors?: IEntity[];
    managers?: IEntity[];
    directReports?: IEntity[];
}
/**
 * @exemptedapi
 */
export interface IdentitiesGetMruRequestModel {
    operationScopes: string[];
    properties?: string[];
    filterByAncestorEntityIds?: string[];
    filterByEntityIds?: string[];
}
/**
 * @exemptedapi
 */
export interface IdentitiesGetMruResponseModel {
    mruIdentities: IEntity[];
}
/**
 * @exemptedapi
 */
export interface IdentitiesPatchMruAction {
    op: string;
    value: string[];
    operationScopes: string[];
}
/**
 * @exemptedapi
 */
export interface IdentitiesPatchMruResponseModel {
    result: boolean;
}
}
declare module "VSS/Identities/Picker/Services" {
import Service = require("VSS/Service");
import Identities_Picker_RestClient = require("VSS/Identities/Picker/RestClient");
import Identities_Picker_Common = require("VSS/Identities/Picker/Common");
/**
*   Maps to static Directory in the DirectoryDiscoveryService
**/
export interface IOperationScope {
    /**
    *   Search the applicable source directory - AAD tenant-level for AAD-backed accounts or IMS account-level for MSA accounts/on-premise TFS
    **/
    Source?: boolean;
    /**
    *   Search IMS (Identity service)
    **/
    IMS?: boolean;
    /**
    *   Search the Azure Active Directory
    **/
    AAD?: boolean;
    /**
    *   Search Active Directory
    **/
    AD?: boolean;
    /**
    *   Search Windows Machine Directory
    **/
    WMD?: boolean;
}
/**
*   Suggest that the query need not be treated as a prefix
**/
export interface IQueryTypeHint {
    UID?: boolean;
}
/**
*   Maps to static DirectoryObjectType in the DirectoryDiscoveryService
**/
export interface IEntityType {
    User?: boolean;
    Group?: boolean;
}
/**
*  The kinds of edges in the identity directed graph that you want to traverse
**/
export interface IConnectionType {
    successors?: boolean;
    managers?: boolean;
    directReports?: boolean;
}
/**
 * @exemptedapi
 * These client service helpers are meant to be used only by the framework identity picker controls and services and should not be used elsewhere.
 */
export class ServiceHelpers {
    static _defaultProperties: string[];
    static _defaultUserProperties: string[];
    static _defaultGroupProperties: string[];
    static DefaultUserImage: string;
    static DefaultVsoGroupImage: string;
    static DefaultRemoteGroupImage: string;
    static VisualStudioDirectory: string;
    static AzureActiveDirectory: string;
    static ActiveDirectory: string;
    static WindowsMachineDirectory: string;
    static SourceDirectory: string;
    static UserEntity: string;
    static GroupEntity: string;
    static OptionsMinResultsKey: string;
    static OptionsMaxResultsKey: string;
    static ExtensionData_ExtensionIdKey: string;
    static ExtensionData_ProjectScopeNameKey: string;
    static ExtensionData_CollectionScopeNameKey: string;
    static ExtensionData_ConstraintListKey: string;
    static ExtensionData_NoServiceIdentities: string;
    static GetIdentities_Prefix_Separator: string;
    /**
    *   Currently supports only AAD, IMS, Source, AD and WMD (AAD for AAD-backed accounts, IMS for MSA accounts/on-premise TFS and AD and WMD for on-premise TFS)
    **/
    static getOperationScopeList(operationScope: IOperationScope): string[];
    static getQueryTypeHint(queryTypeHint: IQueryTypeHint): string;
    /**
    *   Currently supports only Users and Groups
    **/
    static getIdentityTypeList(identityType: IEntityType): string[];
    /**
    *   Currently supports only Successors, Managers, and Direct Reports
    **/
    static getConnectionTypeList(connectionType: IConnectionType): string[];
    static getDefaultIdentityImage(identity: Identities_Picker_RestClient.IEntity): string;
    static getDistinct(array: string[]): string[];
    static isAuthenticatedMember(): boolean;
    static getPrefixTypeForTelemetry(prefix: string): "signInAddress" | "domainSamAccountName" | "entityId" | "vsid" | "scopedPrefix" | "stringPrefix";
    static addScenarioProperties(service: Service.VssService, scenarioProperties: IDictionaryStringTo<any>, operationScope?: IOperationScope, identityType?: IEntityType, options?: IIdentityServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IDictionaryStringTo<any>;
    private static _getHostMetadata;
}
/**
 * @exemptedapi
 * This interface provides data for the identity picker service extension
 */
export interface IExtensionData {
    extensionId: string;
    projectScopeName?: string;
    collectionScopeName?: string;
    constraints?: string[];
}
/**
 * @exemptedapi
 */
export interface IIdentityPickerExtensionOptions {
    /**
    *   The source of the request - please update the Common Identity Picker wiki with your consumer GUID
    **/
    consumerId: string;
}
/**
 * @exemptedapi
 */
export interface IIdentityServiceOptions {
    /**
    *   The httpClient that should be used instead of the CommonIdentityPickerHttpClient
    **/
    httpClient?: Identities_Picker_RestClient.AbstractIdentityPickerHttpClient;
    /**
    *   The minimum results that need to be fetched
    **/
    minResults?: number;
    /**
    *   The maximum results that need to be fetched
    **/
    maxResults?: number;
    /**
    *   Details about the control's current environment that might help an IEntityOperationsExtension in modifying requests.
    **/
    extensionData?: IExtensionData;
    /**
    *   type of identities - one or more of User or Group
    **/
    identityType?: IEntityType;
    /**
    *   scope - one or more of AAD, IMS, Source, AD, WMD
    **/
    operationScope?: IOperationScope;
    /**
    *   The scope over which the search and MRU results are filtered by.
    *   A consumer must pass a delegate that returns a FilterByScope instance, which can be constructed by passing two arrays of strings
    *   corresponding to Entity Ids and Ancestor Entity Ids
    *   over which the scope is restricted.
    *   Default null.
    *   NOTE: Null scope and an empty scope (a scope which is not null but whose internal arrays are empty) are treated differently.
    *         Null scope means no filtering will take place on entities, whereas empty scope means no entities would be returned.
    *         So an empty FilterByScope will result in no search being issued.
    **/
    getFilterByScope?: () => Identities_Picker_Common.FilterByScope;
}
/**
 * @exemptedapi
 */
export interface IIdentityService {
    getIdentities(prefix: string, operationScope: IOperationScope, identityType: IEntityType, options?: IIdentityServiceOptions, queryTypeHint?: IQueryTypeHint, extensionOptions?: IIdentityPickerExtensionOptions): IDictionaryStringTo<IPromise<Identities_Picker_RestClient.QueryTokenResultModel>>;
    getIdentityImages(identities: Identities_Picker_RestClient.IEntity[], options?: IIdentityServiceOptions): IDictionaryStringTo<IPromise<IDictionaryStringTo<string>>>;
    getIdentityConnections(identity: Identities_Picker_RestClient.IEntity, operationScope: IOperationScope, identityType: IEntityType, connectionType: IConnectionType, options?: IIdentityServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions, depth?: number): IPromise<Identities_Picker_RestClient.IdentitiesGetConnectionsResponseModel>;
}
/**
 * @exemptedapi
 * This client service is meant to be used only by the framework identity picker controls and should not be used elsewhere.
 */
export class IdentityService extends Service.VssService implements IIdentityService {
    static MIN_RESULTS: number;
    static MAX_RESULTS: number;
    constructor();
    /**
    *   Get all users with specific properties starting with the prefix.
    **/
    getIdentities(prefix: string, operationScope: IOperationScope, identityType: IEntityType, options?: IIdentityServiceOptions, queryTypeHint?: IQueryTypeHint, extensionOptions?: IIdentityPickerExtensionOptions): IDictionaryStringTo<IPromise<Identities_Picker_RestClient.QueryTokenResultModel>>;
    /**
    *   Get images of identities asynchronously, if available. Currently only supports AAD and profile images.
    *   @param  successCallback:    This is called once all the images have been loaded for the identities supplied
    *   @param  errorCallback:      This is called for each error received from either the controller or one of the federated services
    **/
    getIdentityImages(identities: Identities_Picker_RestClient.IEntity[], options?: IIdentityServiceOptions): IDictionaryStringTo<IPromise<IDictionaryStringTo<string>>>;
    /**
    *   Get an identity's connections in the overlay of the AD graph on the VSTS Identity graph
    **/
    getIdentityConnections(identity: Identities_Picker_RestClient.IEntity, operationScope: IOperationScope, identityType: IEntityType, connectionType: IConnectionType, options?: IIdentityServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions, depth?: number): IPromise<Identities_Picker_RestClient.IdentitiesGetConnectionsResponseModel>;
    private static _getEntityIdsAsQueryTokens;
    private _cacheQueryTokenResult;
    private static _removeQueryToken;
    private static getUniqueRequestString;
    private static getExtensionUniqueRequestString;
    private _qtrCache;
    private _qtrRequestAggregator;
    private _entityImageRequestAggregator;
}
/**
 * @exemptedapi
 */
export interface IMruServiceOptions {
    /**
    *   The httpClient that should be used instead of the CommonIdentityPickerHttpClient
    **/
    httpClient?: Identities_Picker_RestClient.AbstractIdentityPickerHttpClient;
    /**
    *   The scope over which the MRU filters identities by.
    **/
    filterByScope?: Identities_Picker_Common.FilterByScope;
}
/**
 * @exemptedapi
 * Operations on the account-bound MRU identities (across all IdentityTypeFilters) of the querying user in its account
 */
export interface IMruService {
    getMruIdentities(operationScope: IOperationScope, identityId?: string, featureId?: string, options?: IMruServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IPromise<Identities_Picker_RestClient.IEntity[]>;
    removeMruIdentities(objectIds: string[], operationScope: IOperationScope, identityId?: string, featureId?: string, options?: IMruServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IPromise<boolean>;
    addMruIdentities(objectIds: string[], operationScope: IOperationScope, identityId?: string, featureId?: string, options?: IMruServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IPromise<boolean>;
}
/**
 * @exemptedapi
 * This client service is meant to be used only by the framework identity picker controls and should not be used elsewhere.
 */
export class MruService extends Service.VssService implements IMruService {
    static DEFAULT_IDENTITY_ID: string;
    static DEFAULT_FEATURE_ID: string;
    getMruIdentities(operationScope: IOperationScope, identityId?: string, featureId?: string, options?: IMruServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IPromise<Identities_Picker_RestClient.IEntity[]>;
    removeMruIdentities(objectIds: string[], operationScope: IOperationScope, identityId?: string, featureId?: string, options?: IMruServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IPromise<boolean>;
    addMruIdentities(objectIds: string[], operationScope: IOperationScope, identityId?: string, featureId?: string, options?: IMruServiceOptions, extensionOptions?: IIdentityPickerExtensionOptions): IPromise<boolean>;
}
}
declare module "VSS/Identities/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Identities/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_DelegatedAuthorization_Contracts = require("VSS/DelegatedAuthorization/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected claimsApiVersion: string;
    protected descriptorsApiVersion: string;
    protected groupsApiVersion: string;
    protected identitiesApiVersion: string;
    protected identityApiVersion: string;
    protected identityBatchApiVersion: string;
    protected identitySnapshotApiVersion: string;
    protected maxSequenceIdApiVersion: string;
    protected meApiVersion: string;
    protected membersApiVersion: string;
    protected membersOfApiVersion: string;
    protected scopesApiVersion: string;
    protected signedInTokenApiVersion: string;
    protected signoutTokenApiVersion: string;
    protected swapApiVersion: string;
    protected tenantApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} tenantId
     * @return IPromise<Contracts.TenantInfo>
     */
    getTenant(tenantId: string): IPromise<Contracts.TenantInfo>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @return IPromise<VSS_DelegatedAuthorization_Contracts.AccessTokenResult>
     */
    getSignoutToken(): IPromise<VSS_DelegatedAuthorization_Contracts.AccessTokenResult>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @return IPromise<VSS_DelegatedAuthorization_Contracts.AccessTokenResult>
     */
    getSignedInToken(): IPromise<VSS_DelegatedAuthorization_Contracts.AccessTokenResult>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {Contracts.IdentityScope} renameScope
     * @param {string} scopeId
     * @return IPromise<void>
     */
    renameScope(renameScope: Contracts.IdentityScope, scopeId: string): IPromise<void>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} scopeName
     * @return IPromise<Contracts.IdentityScope>
     */
    getScopeByName(scopeName: string): IPromise<Contracts.IdentityScope>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} scopeId
     * @return IPromise<Contracts.IdentityScope>
     */
    getScopeById(scopeId: string): IPromise<Contracts.IdentityScope>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} scopeId
     * @return IPromise<void>
     */
    deleteScope(scopeId: string): IPromise<void>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {Contracts.CreateScopeInfo} info
     * @param {string} scopeId
     * @return IPromise<Contracts.IdentityScope>
     */
    createScope(info: Contracts.CreateScopeInfo, scopeId: string): IPromise<Contracts.IdentityScope>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} memberId
     * @param {Contracts.QueryMembership} queryMembership
     * @return IPromise<Contracts.IdentityDescriptor[]>
     */
    readMembersOf(memberId: string, queryMembership?: Contracts.QueryMembership): IPromise<Contracts.IdentityDescriptor[]>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} memberId
     * @param {string} containerId
     * @param {Contracts.QueryMembership} queryMembership
     * @return IPromise<Contracts.IdentityDescriptor>
     */
    readMemberOf(memberId: string, containerId: string, queryMembership?: Contracts.QueryMembership): IPromise<Contracts.IdentityDescriptor>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} containerId
     * @param {string} memberId
     * @return IPromise<boolean>
     */
    removeMember(containerId: string, memberId: string): IPromise<boolean>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} containerId
     * @param {Contracts.QueryMembership} queryMembership
     * @return IPromise<Contracts.IdentityDescriptor[]>
     */
    readMembers(containerId: string, queryMembership?: Contracts.QueryMembership): IPromise<Contracts.IdentityDescriptor[]>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} containerId
     * @param {string} memberId
     * @param {Contracts.QueryMembership} queryMembership
     * @return IPromise<Contracts.IdentityDescriptor>
     */
    readMember(containerId: string, memberId: string, queryMembership?: Contracts.QueryMembership): IPromise<Contracts.IdentityDescriptor>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} containerId
     * @param {string} memberId
     * @return IPromise<boolean>
     */
    addMember(containerId: string, memberId: string): IPromise<boolean>;
    /**
     * Read identity of the home tenant request user.
     *
     * @return IPromise<Contracts.IdentitySelf>
     */
    getSelf(): IPromise<Contracts.IdentitySelf>;
    /**
     * Read the max sequence id of all the identities.
     *
     * @return IPromise<number>
     */
    getMaxSequenceId(): IPromise<number>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} scopeId
     * @return IPromise<Contracts.IdentitySnapshot>
     */
    getIdentitySnapshot(scopeId: string): IPromise<Contracts.IdentitySnapshot>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {Contracts.IdentityBatchInfo} batchInfo
     * @return IPromise<Contracts.Identity[]>
     */
    readIdentityBatch(batchInfo: Contracts.IdentityBatchInfo): IPromise<Contracts.Identity[]>;
    /**
     * @param {Contracts.FrameworkIdentityInfo} frameworkIdentityInfo
     * @return IPromise<Contracts.Identity>
     */
    createIdentity(frameworkIdentityInfo: Contracts.FrameworkIdentityInfo): IPromise<Contracts.Identity>;
    /**
     * @param {Contracts.Identity} identity
     * @param {string} identityId
     * @return IPromise<void>
     */
    updateIdentity(identity: Contracts.Identity, identityId: string): IPromise<void>;
    /**
     * @param {VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.Identity[]>} identities
     * @return IPromise<Contracts.IdentityUpdateData[]>
     */
    updateIdentities(identities: VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.Identity[]>): IPromise<Contracts.IdentityUpdateData[]>;
    /**
     * @param {string} identityId
     * @param {Contracts.QueryMembership} queryMembership
     * @param {string} properties
     * @return IPromise<Contracts.Identity>
     */
    readIdentity(identityId: string, queryMembership?: Contracts.QueryMembership, properties?: string): IPromise<Contracts.Identity>;
    /**
     * @param {string} scopeId
     * @param {Contracts.QueryMembership} queryMembership
     * @param {string} properties
     * @return IPromise<Contracts.Identity[]>
     */
    readIdentitiesByScope(scopeId: string, queryMembership?: Contracts.QueryMembership, properties?: string): IPromise<Contracts.Identity[]>;
    /**
     * @param {string} descriptors
     * @param {string} identityIds
     * @param {string} subjectDescriptors
     * @param {string} searchFilter
     * @param {string} filterValue
     * @param {Contracts.QueryMembership} queryMembership
     * @param {string} properties
     * @param {boolean} includeRestrictedVisibility
     * @param {Contracts.ReadIdentitiesOptions} options
     * @return IPromise<Contracts.Identity[]>
     */
    readIdentities(descriptors?: string, identityIds?: string, subjectDescriptors?: string, searchFilter?: string, filterValue?: string, queryMembership?: Contracts.QueryMembership, properties?: string, includeRestrictedVisibility?: boolean, options?: Contracts.ReadIdentitiesOptions): IPromise<Contracts.Identity[]>;
    /**
     * @param {string} domainId
     * @return IPromise<string[]>
     */
    getUserIdentityIdsByDomainId(domainId: string): IPromise<string[]>;
    /**
     * @param {number} identitySequenceId
     * @param {number} groupSequenceId
     * @param {number} organizationIdentitySequenceId
     * @param {number} pageSize
     * @param {string} scopeId
     * @return IPromise<Contracts.ChangedIdentities>
     */
    getIdentityChanges(identitySequenceId: number, groupSequenceId: number, organizationIdentitySequenceId?: number, pageSize?: number, scopeId?: string): IPromise<Contracts.ChangedIdentities>;
    /**
     * @param {string} scopeIds
     * @param {boolean} recurse
     * @param {boolean} deleted
     * @param {string} properties
     * @return IPromise<Contracts.Identity[]>
     */
    listGroups(scopeIds?: string, recurse?: boolean, deleted?: boolean, properties?: string): IPromise<Contracts.Identity[]>;
    /**
     * @param {string} groupId
     * @return IPromise<void>
     */
    deleteGroup(groupId: string): IPromise<void>;
    /**
     * @param {any} container
     * @return IPromise<Contracts.Identity[]>
     */
    createGroups(container: any): IPromise<Contracts.Identity[]>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {string} id
     * @param {boolean} isMasterId
     * @return IPromise<Contracts.IdentityDescriptor>
     */
    getDescriptorById(id: string, isMasterId?: boolean): IPromise<Contracts.IdentityDescriptor>;
    /**
     * @exemptedapi
     * [Preview API]
     *
     * @param {Contracts.Identity} sourceIdentity
     * @return IPromise<Contracts.Identity>
     */
    createOrBindWithClaims(sourceIdentity: Contracts.Identity): IPromise<Contracts.Identity>;
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class IdentitiesHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class IdentitiesHttpClient extends IdentitiesHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return IdentitiesHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): IdentitiesHttpClient4_1;
}
declare module "VSS/Invitation/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\invitation.genclient.json
 */
/**
 * Invitation Data
 */
export interface InvitationData {
    /**
     * Invitation Attributes
     */
    attributes: {
        [key: string]: string;
    };
    /**
     * Type of Invitation
     */
    invitationType: InvitationType;
    /**
     * Id of the Sender
     */
    senderId: string;
}
/**
 * Enum value indicating type of invitation
 */
export enum InvitationType {
    AccountInvite = 1
}
export var TypeInfo: {
    InvitationData: any;
    InvitationType: {
        enumValues: {
            "accountInvite": number;
        };
    };
};
}
declare module "VSS/Invitation/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\invitation.genclient.json
 */
import Contracts = require("VSS/Invitation/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods4_1To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected invitationsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Send Account Invitation to a user
     *
     * @param {Contracts.InvitationData} invitationData - optional Invitation Data
     * @param {string} userId - IdentityId of the user
     * @return IPromise<void>
     */
    sendAccountInvitation(invitationData: Contracts.InvitationData, userId: string): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class InvitationHttpClient5 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class InvitationHttpClient4_1 extends CommonMethods4_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class InvitationHttpClient extends InvitationHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return InvitationHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): InvitationHttpClient4_1;
}
declare module "VSS/JoinOrganization/Contracts" {
import Contracts = require("VSS/ReparentCollection/Contracts");
export interface JoinOrganizationRequest {
    /**
     * New organization for this collection (application host id)
     */
    organizationId: string;
    properties: Contracts.PropertyPair[];
}
}
declare module "VSS/JoinOrganization/RestClient" {
import Contracts = require("VSS/JoinOrganization/Contracts");
import ReparentCollection_Contracts = require("VSS/ReparentCollection/Contracts");
import VSS_Operations_Contracts = require("VSS/Operations/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3To4_1 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected requestsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.JoinOrganizationRequest} request
     * @param {boolean} validateOnly
     * @return IPromise<VSS_Operations_Contracts.OperationReference>
     */
    queueJoinOrganization(request: Contracts.JoinOrganizationRequest, validateOnly?: boolean): IPromise<VSS_Operations_Contracts.OperationReference>;
    /**
     * [Preview API]
     *
     * @param {string} requestId
     * @return IPromise<Contracts.ServicingOrchestrationRequestStatus>
     */
    getStatus(requestId: string): IPromise<ReparentCollection_Contracts.ServicingOrchestrationRequestStatus>;
}
/**
 * @exemptedapi
 */
export class OrganizationJoinHttpClient4_1 extends CommonMethods3To4_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationJoinHttpClient4 extends CommonMethods3To4_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationJoinHttpClient3_2 extends CommonMethods3To4_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationJoinHttpClient3_1 extends CommonMethods3To4_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationJoinHttpClient3 extends CommonMethods3To4_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class OrganizationJoinHttpClient extends OrganizationJoinHttpClient4_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return OrganizationJoinHttpClient4
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): OrganizationJoinHttpClient4;
}
declare module "VSS/LicensingRule/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\licensingrule.genclient.json
 */
import VSS_Operations_Contracts = require("VSS/Operations/Contracts");
export enum AccountLicenseType {
    None = 0,
    EarlyAdopter = 1,
    Express = 2,
    Professional = 3,
    Advanced = 4,
    Stakeholder = 5
}
export interface AccountUserLicense {
    license: number;
    source: LicensingSource;
}
export interface ApplicationStatus {
    extensions: ExtensionApplicationStatus[];
    isTruncated: boolean;
    licenses: LicenseApplicationStatus[];
    option: RuleOption;
    status: VSS_Operations_Contracts.OperationStatus;
}
export interface ExtensionApplicationStatus extends LicensingApplicationStatus {
    extensionId: string;
    incompatible: number;
    unassigned: number;
}
/**
 * Represents an Extension Rule
 */
export interface ExtensionRule {
    /**
     * Extension Id
     */
    extensionId: string;
    /**
     * Status of the group rule (applied, missing licenses, etc)
     */
    status: GroupLicensingRuleStatus;
}
export interface GraphSubjectLookup {
    lookupKeys: GraphSubjectLookupKey[];
}
export interface GraphSubjectLookupKey {
    descriptor: string;
}
/**
 * Represents a GroupLicensingRule
 */
export interface GroupLicensingRule {
    /**
     * Extension Rules
     */
    extensionRules: ExtensionRule[];
    /**
     * License Rule
     */
    licenseRule: LicenseRule;
    /**
     * SubjectDescriptor for the rule
     */
    subjectDescriptor: string;
}
export enum GroupLicensingRuleStatus {
    /**
     * Rule is created or updated, but apply is pending
     */
    ApplyPending = 0,
    /**
     * Rule is applied
     */
    Applied = 1,
    /**
     * The group rule was incompatible
     */
    Incompatible = 5,
    /**
     * Rule failed to apply unexpectedly and should be retried
     */
    UnableToApply = 10
}
/**
 * Represents an GroupLicensingRuleUpdate Model
 */
export interface GroupLicensingRuleUpdate {
    /**
     * Extensions to Add
     */
    extensionsToAdd: string[];
    /**
     * Extensions to Remove
     */
    extensionsToRemove: string[];
    /**
     * New License
     */
    license: License;
    /**
     * SubjectDescriptor for the rule
     */
    subjectDescriptor: string;
}
/**
 * The base class for a specific license source and license
 */
export interface License {
    /**
     * Gets the source of the license
     */
    source: LicensingSource;
}
export interface LicenseApplicationStatus extends LicensingApplicationStatus {
    accountUserLicense: AccountUserLicense;
    license: License;
}
/**
 * Represents a License Rule
 */
export interface LicenseRule {
    /**
     * The last time the rule was executed (regardless of whether any changes were made)
     */
    lastExecuted: Date;
    /**
     * License
     */
    license: License;
    /**
     * Status of the group rule (applied, missing licenses, etc)
     */
    status: GroupLicensingRuleStatus;
}
export interface LicensingApplicationStatus {
    assigned: number;
    failed: number;
    insufficientResources: number;
}
export enum LicensingSource {
    None = 0,
    Account = 1,
    Msdn = 2,
    Profile = 3,
    Auto = 4,
    Trial = 5
}
export enum MsdnLicenseType {
    None = 0,
    Eligible = 1,
    Professional = 2,
    Platforms = 3,
    TestProfessional = 4,
    Premium = 5,
    Ultimate = 6,
    Enterprise = 7
}
export enum RuleOption {
    ApplyGroupRule = 0,
    TestApplyGroupRule = 1
}
export var TypeInfo: {
    AccountLicenseType: {
        enumValues: {
            "none": number;
            "earlyAdopter": number;
            "express": number;
            "professional": number;
            "advanced": number;
            "stakeholder": number;
        };
    };
    AccountUserLicense: any;
    ApplicationStatus: any;
    ExtensionRule: any;
    GroupLicensingRule: any;
    GroupLicensingRuleStatus: {
        enumValues: {
            "applyPending": number;
            "applied": number;
            "incompatible": number;
            "unableToApply": number;
        };
    };
    GroupLicensingRuleUpdate: any;
    License: any;
    LicenseApplicationStatus: any;
    LicenseRule: any;
    LicensingSource: {
        enumValues: {
            "none": number;
            "account": number;
            "msdn": number;
            "profile": number;
            "auto": number;
            "trial": number;
        };
    };
    MsdnLicenseType: {
        enumValues: {
            "none": number;
            "eligible": number;
            "professional": number;
            "platforms": number;
            "testProfessional": number;
            "premium": number;
            "ultimate": number;
            "enterprise": number;
        };
    };
    RuleOption: {
        enumValues: {
            "applyGroupRule": number;
            "testApplyGroupRule": number;
        };
    };
};
}
declare module "VSS/LicensingRule/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\licensingrule.genclient.json
 */
import Contracts = require("VSS/LicensingRule/Contracts");
import VSS_Operations_Contracts = require("VSS/Operations/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected groupLicensingRulesApiVersion: string;
    protected groupLicensingRulesApplicationApiVersion: string;
    protected groupLicensingRulesApplicationStatusApiVersion: string;
    protected groupLicensingRulesLookupApiVersion: string;
    protected groupLicensingRulesUserApplicationApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Removes direct assignments from, and re-applies group rules to, the specified users
     *
     * @param {string} userId
     * @return IPromise<void>
     */
    removeDirectAssignment(userId: string): IPromise<void>;
    /**
     * [Preview API] Applies group rules to the specified user
     *
     * @param {string} userId
     * @return IPromise<void>
     */
    applyGroupLicensingRulesToUser(userId: string): IPromise<void>;
    /**
     * [Preview API] Get Group License Rules for the given batch batch of group Ids
     *
     * @param {Contracts.GraphSubjectLookup} groupRuleLookup
     * @return IPromise<Contracts.GroupLicensingRule[]>
     */
    lookupGroupLicensingRules(groupRuleLookup: Contracts.GraphSubjectLookup): IPromise<Contracts.GroupLicensingRule[]>;
    /**
     * [Preview API] Gets application status for the specific rule
     *
     * @param {string} operationId
     * @return IPromise<Contracts.ApplicationStatus>
     */
    getApplicationStatus(operationId?: string): IPromise<Contracts.ApplicationStatus>;
    /**
     * [Preview API] Applies group rules to the specified user
     *
     * @param {Contracts.RuleOption} ruleOption
     * @return IPromise<VSS_Operations_Contracts.OperationReference>
     */
    applyGroupLicensingRulesToAllUsers(ruleOption?: Contracts.RuleOption): IPromise<VSS_Operations_Contracts.OperationReference>;
    /**
     * [Preview API] Update a group Licensing rule
     *
     * @param {Contracts.GroupLicensingRuleUpdate} licensingRuleUpdate - The update model for the Licensing Rule
     * @param {Contracts.RuleOption} ruleOption - Rule Option
     * @return IPromise<VSS_Operations_Contracts.OperationReference>
     */
    updateGroupLicensingRule(licensingRuleUpdate: Contracts.GroupLicensingRuleUpdate, ruleOption?: Contracts.RuleOption): IPromise<VSS_Operations_Contracts.OperationReference>;
    /**
     * [Preview API]
     *
     * @param {number} top
     * @param {number} skip
     * @return IPromise<Contracts.GroupLicensingRule[]>
     */
    getGroupLicensingRules(top: number, skip?: number): IPromise<Contracts.GroupLicensingRule[]>;
    /**
     * [Preview API] Gets the group Licensing rule for the group with given SubjectDescriptor
     *
     * @param {string} subjectDescriptor
     * @return IPromise<Contracts.GroupLicensingRule>
     */
    getGroupLicensingRule(subjectDescriptor: string): IPromise<Contracts.GroupLicensingRule>;
    /**
     * [Preview API] Delete a group Licensing rule
     *
     * @param {string} subjectDescriptor - subjectDescriptor
     * @param {Contracts.RuleOption} ruleOption - Rule Option
     * @return IPromise<VSS_Operations_Contracts.OperationReference>
     */
    deleteGroupLicenseRule(subjectDescriptor: string, ruleOption?: Contracts.RuleOption): IPromise<VSS_Operations_Contracts.OperationReference>;
    /**
     * [Preview API] Add a new group Licensing rule asynchronously
     *
     * @param {Contracts.GroupLicensingRule} licensingRule - The Licensing Rule
     * @param {Contracts.RuleOption} ruleOption - Rule Option
     * @return IPromise<VSS_Operations_Contracts.OperationReference>
     */
    addGroupLicensingRule(licensingRule: Contracts.GroupLicensingRule, ruleOption?: Contracts.RuleOption): IPromise<VSS_Operations_Contracts.OperationReference>;
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingRuleHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class LicensingRuleHttpClient extends LicensingRuleHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return LicensingRuleHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): LicensingRuleHttpClient4_1;
}
declare module "VSS/Licensing/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Accounts_Contracts = require("VSS/Accounts/Contracts");
import VSS_Commerce_Contracts = require("VSS/Commerce/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
/**
 * Represents a license granted to a user in an account
 */
export interface AccountEntitlement {
    /**
     * Gets or sets the id of the account to which the license belongs
     */
    accountId: string;
    /**
     * Gets or sets the date the license was assigned
     */
    assignmentDate: Date;
    /**
     * Assignment Source
     */
    assignmentSource: AssignmentSource;
    /**
     * Gets or sets the creation date of the user in this account
     */
    dateCreated: Date;
    /**
     * Gets or sets the date of the user last sign-in to this account
     */
    lastAccessedDate: Date;
    license: License;
    /**
     * Licensing origin
     */
    origin: LicensingOrigin;
    /**
     * The computed rights of this user in the account.
     */
    rights: AccountRights;
    /**
     * The status of the user in the account
     */
    status: VSS_Accounts_Contracts.AccountUserStatus;
    /**
     * Identity information of the user to which the license belongs
     */
    user: VSS_Common_Contracts.IdentityRef;
    /**
     * Gets the id of the user to which the license belongs
     */
    userId: string;
}
/**
 * Model for updating an AccountEntitlement for a user, used for the Web API
 */
export interface AccountEntitlementUpdateModel {
    /**
     * Gets or sets the license for the entitlement
     */
    license: License;
}
export interface AccountLicenseExtensionUsage {
    extensionId: string;
    extensionName: string;
    includedQuantity: number;
    isTrial: boolean;
    minimumLicenseRequired: VSS_Commerce_Contracts.MinimumRequiredServiceLevel;
    msdnUsedCount: number;
    provisionedCount: number;
    remainingTrialDays: number;
    trialExpiryDate: Date;
    usedCount: number;
}
export enum AccountLicenseType {
    None = 0,
    EarlyAdopter = 1,
    Express = 2,
    Professional = 3,
    Advanced = 4,
    Stakeholder = 5
}
export interface AccountLicenseUsage {
    /**
     * Amount that is disabled (Usually from licenses that were provisioned, but became invalid due to loss of subscription in a new billing cycle)
     */
    disabledCount: number;
    license: AccountUserLicense;
    /**
     * Amount that will be purchased in the next billing cycle
     */
    pendingProvisionedCount: number;
    /**
     * Amount that has been purchased
     */
    provisionedCount: number;
    /**
     * Amount currently being used.
     */
    usedCount: number;
}
export interface AccountRights {
    level: VisualStudioOnlineServiceLevel;
    reason: string;
}
export interface AccountUserLicense {
    license: number;
    source: LicensingSource;
}
export enum AssignmentSource {
    None = 0,
    Unknown = 1,
    GroupRule = 2
}
export interface ClientRightsContainer {
    certificateBytes: number[];
    token: string;
}
/**
 * Model for assigning an extension to users, used for the Web API
 */
export interface ExtensionAssignment {
    /**
     * Gets or sets the extension ID to assign.
     */
    extensionGalleryId: string;
    /**
     * Set to true if this a auto assignment scenario.
     */
    isAutoAssignment: boolean;
    /**
     * Gets or sets the licensing source.
     */
    licensingSource: LicensingSource;
    /**
     * Gets or sets the user IDs to assign the extension to.
     */
    userIds: string[];
}
export interface ExtensionAssignmentDetails {
    assignmentStatus: ExtensionAssignmentStatus;
    sourceCollectionName: string;
}
export enum ExtensionAssignmentStatus {
    NotEligible = 0,
    NotAssigned = 1,
    AccountAssignment = 2,
    BundleAssignment = 3,
    ImplicitAssignment = 4,
    PendingValidation = 5,
    TrialAssignment = 6,
    RoamingAccountAssignment = 7
}
export enum ExtensionFilterOptions {
    None = 1,
    Bundle = 2,
    AccountAssignment = 4,
    ImplicitAssignment = 8,
    All = -1
}
export interface ExtensionLicenseData {
    createdDate: Date;
    extensionId: string;
    isFree: boolean;
    minimumRequiredAccessLevel: VisualStudioOnlineServiceLevel;
    updatedDate: Date;
}
export enum ExtensionOperation {
    Assign = 0,
    Unassign = 1
}
export interface ExtensionOperationResult {
    accountId: string;
    extensionId: string;
    message: string;
    operation: ExtensionOperation;
    result: OperationResult;
    userId: string;
}
export enum ExtensionRightsReasonCode {
    Normal = 0,
    FeatureFlagSet = 1,
    NullIdentity = 2,
    ServiceIdentity = 3,
    ErrorCallingService = 4
}
export interface ExtensionRightsResult {
    entitledExtensions: string[];
    hostId: string;
    reason: string;
    reasonCode: ExtensionRightsReasonCode;
    resultCode: ExtensionRightsResultCode;
}
export enum ExtensionRightsResultCode {
    Normal = 0,
    AllFree = 1,
    FreeExtensionsFree = 2
}
/**
 * Model for assigning an extension to users, used for the Web API
 */
export interface ExtensionSource {
    /**
     * Assignment Source
     */
    assignmentSource: AssignmentSource;
    /**
     * extension Identifier
     */
    extensionGalleryId: string;
    /**
     * The licensing source of the extension. Account, Msdn, ect.
     */
    licensingSource: LicensingSource;
}
/**
 * The base class for a specific license source and license
 */
export interface License {
    /**
     * Gets the source of the license
     */
    source: LicensingSource;
}
export enum LicensingOrigin {
    None = 0,
    OnDemandPrivateProject = 1,
    OnDemandPublicProject = 2,
    UserHubInvitation = 3,
    PrivateProjectInvitation = 4,
    PublicProjectInvitation = 5
}
export enum LicensingSource {
    None = 0,
    Account = 1,
    Msdn = 2,
    Profile = 3,
    Auto = 4,
    Trial = 5
}
export interface MsdnEntitlement {
    /**
     * Entilement id assigned to Entitlement in Benefits Database.
     */
    entitlementCode: string;
    /**
     * Entitlement Name e.g. Downloads, Chat.
     */
    entitlementName: string;
    /**
     * Type of Entitlement e.g. Downloads, Chat.
     */
    entitlementType: string;
    /**
     * Entitlement activation status
     */
    isActivated: boolean;
    /**
     * Entitlement availability
     */
    isEntitlementAvailable: boolean;
    /**
     * Write MSDN Channel into CRCT (Retail,MPN,VL,BizSpark,DreamSpark,MCT,FTE,Technet,WebsiteSpark,Other)
     */
    subscriptionChannel: string;
    /**
     * Subscription Expiration Date.
     */
    subscriptionExpirationDate: Date;
    /**
     * Subscription id which identifies the subscription itself. This is the Benefit Detail Guid from BMS.
     */
    subscriptionId: string;
    /**
     * Identifier of the subscription or benefit level.
     */
    subscriptionLevelCode: string;
    /**
     * Name of subscription level.
     */
    subscriptionLevelName: string;
    /**
     * Subscription Status Code (ACT, PND, INA ...).
     */
    subscriptionStatus: string;
}
export enum MsdnLicenseType {
    None = 0,
    Eligible = 1,
    Professional = 2,
    Platforms = 3,
    TestProfessional = 4,
    Premium = 5,
    Ultimate = 6,
    Enterprise = 7
}
export enum OperationResult {
    Success = 0,
    Warning = 1,
    Error = 2
}
export enum VisualStudioOnlineServiceLevel {
    /**
     * No service rights. The user cannot access the account
     */
    None = 0,
    /**
     * Default or minimum service level
     */
    Express = 1,
    /**
     * Premium service level - either by purchasing on the Azure portal or by purchasing the appropriate MSDN subscription
     */
    Advanced = 2,
    /**
     * Only available to a specific set of MSDN Subscribers
     */
    AdvancedPlus = 3,
    /**
     * Stakeholder service level
     */
    Stakeholder = 4
}
export var TypeInfo: {
    AccountEntitlement: any;
    AccountEntitlementUpdateModel: any;
    AccountLicenseExtensionUsage: any;
    AccountLicenseType: {
        enumValues: {
            "none": number;
            "earlyAdopter": number;
            "express": number;
            "professional": number;
            "advanced": number;
            "stakeholder": number;
        };
    };
    AccountLicenseUsage: any;
    AccountRights: any;
    AccountUserLicense: any;
    AssignmentSource: {
        enumValues: {
            "none": number;
            "unknown": number;
            "groupRule": number;
        };
    };
    ExtensionAssignment: any;
    ExtensionAssignmentDetails: any;
    ExtensionAssignmentStatus: {
        enumValues: {
            "notEligible": number;
            "notAssigned": number;
            "accountAssignment": number;
            "bundleAssignment": number;
            "implicitAssignment": number;
            "pendingValidation": number;
            "trialAssignment": number;
            "roamingAccountAssignment": number;
        };
    };
    ExtensionFilterOptions: {
        enumValues: {
            "none": number;
            "bundle": number;
            "accountAssignment": number;
            "implicitAssignment": number;
            "all": number;
        };
    };
    ExtensionLicenseData: any;
    ExtensionOperation: {
        enumValues: {
            "assign": number;
            "unassign": number;
        };
    };
    ExtensionOperationResult: any;
    ExtensionRightsReasonCode: {
        enumValues: {
            "normal": number;
            "featureFlagSet": number;
            "nullIdentity": number;
            "serviceIdentity": number;
            "errorCallingService": number;
        };
    };
    ExtensionRightsResult: any;
    ExtensionRightsResultCode: {
        enumValues: {
            "normal": number;
            "allFree": number;
            "freeExtensionsFree": number;
        };
    };
    ExtensionSource: any;
    License: any;
    LicensingOrigin: {
        enumValues: {
            "none": number;
            "onDemandPrivateProject": number;
            "onDemandPublicProject": number;
            "userHubInvitation": number;
            "privateProjectInvitation": number;
            "publicProjectInvitation": number;
        };
    };
    LicensingSource: {
        enumValues: {
            "none": number;
            "account": number;
            "msdn": number;
            "profile": number;
            "auto": number;
            "trial": number;
        };
    };
    MsdnEntitlement: any;
    MsdnLicenseType: {
        enumValues: {
            "none": number;
            "eligible": number;
            "professional": number;
            "platforms": number;
            "testProfessional": number;
            "premium": number;
            "ultimate": number;
            "enterprise": number;
        };
    };
    OperationResult: {
        enumValues: {
            "success": number;
            "warning": number;
            "error": number;
        };
    };
    VisualStudioOnlineServiceLevel: {
        enumValues: {
            "none": number;
            "express": number;
            "advanced": number;
            "advancedPlus": number;
            "stakeholder": number;
        };
    };
};
}
declare module "VSS/Licensing/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Licensing/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected certificateApiVersion: string;
    protected clientRightsApiVersion: string;
    protected entitlementsApiVersion: string;
    protected entitlementsApiVersion_c01e9fd5: string;
    protected entitlementsApiVersion_ea37be6f: string;
    protected entitlementsBatchApiVersion: string;
    protected extensionEntitlementsBatchApiVersion: string;
    protected extensionRegistrationApiVersion: string;
    protected extensionRightsApiVersion: string;
    protected msdnApiVersion: string;
    protected msdnApiVersion_69522c3f: string;
    protected usageApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.AccountLicenseUsage[]>
     */
    getAccountLicensesUsage(): IPromise<Contracts.AccountLicenseUsage[]>;
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.MsdnEntitlement[]>
     */
    getEntitlements(): IPromise<Contracts.MsdnEntitlement[]>;
    /**
     * [Preview API]
     *
     * @return IPromise<void>
     */
    getMsdnPresence(): IPromise<void>;
    /**
     * [Preview API]
     *
     * @return IPromise<Contracts.ExtensionRightsResult>
     */
    getExtensionRights(): IPromise<Contracts.ExtensionRightsResult>;
    /**
     * [Preview API]
     *
     * @param {string[]} ids
     * @return IPromise<{ [key: string] : boolean; }>
     */
    computeExtensionRights(ids: string[]): IPromise<{
        [key: string]: boolean;
    }>;
    /**
     * [Preview API]
     *
     * @param {Contracts.ExtensionLicenseData} extensionLicenseData
     * @return IPromise<boolean>
     */
    registerExtensionLicense(extensionLicenseData: Contracts.ExtensionLicenseData): IPromise<boolean>;
    /**
     * [Preview API]
     *
     * @param {string} extensionId
     * @return IPromise<Contracts.ExtensionLicenseData>
     */
    getExtensionLicenseData(extensionId: string): IPromise<Contracts.ExtensionLicenseData>;
    /**
     * [Preview API] Returns extensions that are currrently assigned to the users that are in the account
     *
     * @param {string[]} userIds
     * @return IPromise<{ [key: string] : Contracts.ExtensionSource[]; }>
     */
    bulkGetExtensionsAssignedToUsers(userIds: string[]): IPromise<{
        [key: string]: Contracts.ExtensionSource[];
    }>;
    /**
     * [Preview API] Returns AccountEntitlements that are currently assigned to the given list of users in the account
     *
     * @param {string[]} userIds - List of user Ids.
     * @return IPromise<Contracts.AccountEntitlement[]>
     */
    obtainAvailableAccountEntitlements(userIds: string[]): IPromise<Contracts.AccountEntitlement[]>;
    /**
     * [Preview API] Returns AccountEntitlements that are currently assigned to the given list of users in the account
     *
     * @param {string[]} userIds - List of user Ids.
     * @return IPromise<Contracts.AccountEntitlement[]>
     */
    getAccountEntitlementsBatch(userIds: string[]): IPromise<Contracts.AccountEntitlement[]>;
    /**
     * [Preview API] Get the entitlements for a user
     *
     * @param {string} userId - The id of the user
     * @param {boolean} determineRights
     * @param {boolean} createIfNotExists
     * @return IPromise<Contracts.AccountEntitlement>
     */
    getAccountEntitlementForUser(userId: string, determineRights?: boolean, createIfNotExists?: boolean): IPromise<Contracts.AccountEntitlement>;
    /**
     * [Preview API]
     *
     * @param {string} userId
     * @return IPromise<void>
     */
    deleteUserEntitlements(userId: string): IPromise<void>;
    /**
     * [Preview API] Assign an explicit account entitlement
     *
     * @param {Contracts.AccountEntitlementUpdateModel} body - The update model for the entitlement
     * @param {string} userId - The id of the user
     * @param {boolean} dontNotifyUser
     * @param {Contracts.LicensingOrigin} origin
     * @return IPromise<Contracts.AccountEntitlement>
     */
    assignAccountEntitlementForUser(body: Contracts.AccountEntitlementUpdateModel, userId: string, dontNotifyUser?: boolean, origin?: Contracts.LicensingOrigin): IPromise<Contracts.AccountEntitlement>;
    /**
     * [Preview API] Gets top (top) entitlements for users in the account from offset (skip) order by DateCreated ASC
     *
     * @param {number} top - number of accounts to return
     * @param {number} skip - records to skip, null is interpreted as 0
     * @return IPromise<Contracts.AccountEntitlement[]>
     */
    getAccountEntitlements(top?: number, skip?: number): IPromise<Contracts.AccountEntitlement[]>;
    /**
     * [Preview API] Gets the account entitlement of the current user it is mapped to _apis/licensing/entitlements/me so specifically is looking for the user of the request
     *
     * @return IPromise<Contracts.AccountEntitlement>
     */
    getAccountEntitlement(): IPromise<Contracts.AccountEntitlement>;
    /**
     * [Preview API] Assign an available entitilement to a user
     *
     * @param {string} userId - The user to which to assign the entitilement
     * @param {boolean} dontNotifyUser
     * @param {Contracts.LicensingOrigin} origin
     * @return IPromise<Contracts.AccountEntitlement>
     */
    assignAvailableAccountEntitlement(userId: string, dontNotifyUser?: boolean, origin?: Contracts.LicensingOrigin): IPromise<Contracts.AccountEntitlement>;
    /**
     * [Preview API]
     *
     * @param {string} rightName
     * @param {string} productVersion
     * @param {string} edition
     * @param {string} relType
     * @param {boolean} includeCertificate
     * @param {string} canary
     * @param {string} machineId
     * @return IPromise<Contracts.ClientRightsContainer>
     */
    getClientRights(rightName?: string, productVersion?: string, edition?: string, relType?: string, includeCertificate?: boolean, canary?: string, machineId?: string): IPromise<Contracts.ClientRightsContainer>;
    /**
     * [Preview API]
     *
     * @return IPromise<ArrayBuffer>
     */
    getCertificate(): IPromise<ArrayBuffer>;
}
export class CommonMethods3To5 extends CommonMethods2To5 {
    protected extensionEntitlementsApiVersion: string;
    protected extensionEntitlementsApiVersion_5434f182: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Returns extensions that are currently assigned to the user in the account
     *
     * @param {string} userId - The user's identity id.
     * @return IPromise<{ [key: string] : Contracts.LicensingSource; }>
     */
    getExtensionsAssignedToUser(userId: string): IPromise<{
        [key: string]: Contracts.LicensingSource;
    }>;
    /**
     * [Preview API] Assigns the access to the given extension for a given list of users
     *
     * @param {Contracts.ExtensionAssignment} body - The extension assignment details.
     * @return IPromise<Contracts.ExtensionOperationResult[]>
     */
    assignExtensionToUsers(body: Contracts.ExtensionAssignment): IPromise<Contracts.ExtensionOperationResult[]>;
    /**
     * [Preview API] Returns extension assignment status of all account users for the given extension
     *
     * @param {string} extensionId - The extension to check the status of the users for.
     * @return IPromise<{ [key: string] : Contracts.ExtensionAssignmentDetails; }>
     */
    getExtensionStatusForUsers(extensionId: string): IPromise<{
        [key: string]: Contracts.ExtensionAssignmentDetails;
    }>;
    /**
     * [Preview API] Returns users that are currently eligible to assign the extension to. the list is filtered based on the value of ExtensionFilterOptions
     *
     * @param {string} extensionId - The extension to check the eligibility of the users for.
     * @param {Contracts.ExtensionFilterOptions} options - The options to filter the list.
     * @return IPromise<string[]>
     */
    getEligibleUsersForExtension(extensionId: string, options: Contracts.ExtensionFilterOptions): IPromise<string[]>;
    /**
     * [Preview API] Assigns the access to the given extension for all eligible users in the account that do not already have access to the extension though bundle or account assignment
     *
     * @param {string} extensionId - The extension id to assign the access to.
     * @return IPromise<Contracts.ExtensionOperationResult[]>
     */
    assignExtensionToAllEligibleUsers(extensionId: string): IPromise<Contracts.ExtensionOperationResult[]>;
}
export class CommonMethods3_1To5 extends CommonMethods3To5 {
    protected accountAssignedExtensionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Returns Licensing info about paid extensions assigned to user passed into GetExtensionsAssignedToAccount
     *
     * @return IPromise<Contracts.AccountLicenseExtensionUsage[]>
     */
    getExtensionLicenseUsage(): IPromise<Contracts.AccountLicenseExtensionUsage[]>;
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient5 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient4_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient4 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient3_2 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient3_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LicensingHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class LicensingHttpClient extends LicensingHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return LicensingHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): LicensingHttpClient4_1;
}
declare module "VSS/Locations" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Locations_Contracts = require("VSS/Locations/Contracts");
import Locations_RestClient = require("VSS/Locations/RestClient");
/**
* Options for generating content urls
*/
export interface ContentLocationOptions {
    /**
    * Unique id of the service to generate the url for
    */
    serviceInstanceId?: string;
    /**
    * Specific web context to use when generating the url
    */
    webContext?: Contracts_Platform.WebContext;
    /**
    * Host level to get the url of
    */
    hostType?: Contracts_Platform.ContextHostType;
    /**
    * Relative path to append to the url. This needs to be properly encoded by the consumer.
    */
    relativePath?: string;
    /**
    * Query parameters to add to the url
    */
    queryParams?: IDictionaryStringTo<string>;
}
/**
* Options for generating MVC urls
*/
export interface MvcRouteOptions {
    /**
    * Unique id of the service to generate the url for
    */
    serviceInstanceId?: string;
    /**
    * Specific web context to use when generating the url
    */
    webContext?: Contracts_Platform.WebContext;
    /**
    * Navigation level at which to generate the url (Deployment, Account, Collection, Project, Team)
    */
    level?: Contracts_Platform.NavigationContextLevels;
    /**
    * Route Area (e.g. "admin") or null/undefined for the default
    */
    area?: string;
    /**
    * MVC controller name
    */
    controller?: string;
    /**
    * Controller action
    */
    action?: string;
    /**
    * Array of parameters (path parts) to append to the path (after controller and action)
    */
    parameters?: string[];
    /**
    * Override the project in the web context
    */
    project?: string;
    /**
    * Override the team in the web context
    */
    team?: string;
    /**
    * Query parameters to add to the url
    */
    queryParams?: IDictionaryStringTo<string>;
}
/**
* Helper class for generating urls
*/
export class UrlHelper {
    private _areaPrefix;
    private _controllerPrefix;
    constructor(areaPrefix?: string, controllerPrefix?: string);
    /**
    * Get the url of particular content. If a service id is specified, its url needs to already be in the cached locations.
    *
    * @param options Url generation options
    * @return The generated url string
    */
    getContentUrl(options: ContentLocationOptions): string;
    /**
    * Get the url of a versioned _content file from the hosting page's service.
    *
    * @param contentFileName filename relative to "/_static/tfs/{Version}/_content/"
    * @param serviceInstanceTypeId The id of the service instance to generate the content url of
    * @return The generated url string
    */
    getVersionedContentUrl(contentFileName: string, serviceInstanceTypeId?: string): string;
    /**
    * Get the url of an MVC endpoint.
    *
    * @param options Url generation options
    * @return Promise which returns the generated url string
    */
    beginGetMvcUrl(options: MvcRouteOptions): IPromise<string>;
    /**
    * Get the url of an MVC endpoint. If a service id is specified, its url needs to already be in the cached locations.
    *
    * @param options Url generation options
    * @return The generated url string
    */
    getMvcUrl(options: MvcRouteOptions): string;
}
/**
* Url helper which provides methods for generating urls
*/
export var urlHelper: UrlHelper;
/**
* Get the preferred url for the given service definition
*/
export function getUrlForServiceDefinition(serviceDefinition: Locations_Contracts.ServiceDefinition): string;
/**
* Get the url for the given service if its location has already been cached
*
* @param serviceInstanceId Unique id for the service
* @param hostType The host level to get the url for
* @param webContext The original context to get the url for
* @return Url if the location could be resolved
*/
export function getCachedServiceLocation(serviceInstanceId: string, hostType: Contracts_Platform.ContextHostType, webContext?: Contracts_Platform.WebContext): string;
/**
* Set the url for the given service and host type
*
* @param url The Url of the location to add
* @param serviceInstanceId Unique id for the service
* @param hostType The host level of the url
*/
export function addServiceLocation(url: string, serviceInstanceId: string, hostType: Contracts_Platform.ContextHostType): void;
/**
* Get the SPS url at the given host type level.
*/
export function getSpsLocation(hostType: Contracts_Platform.ContextHostType, webContext?: Contracts_Platform.WebContext, authTokenManager?: IAuthTokenManager<any>): IPromise<string>;
/**
* Create a Locations HttpClient pointed to the given SPS location
*/
export function getSpsLocationClient(spsLocationUrl: string, hostType: Contracts_Platform.ContextHostType, authTokenManager?: IAuthTokenManager<any>): Locations_RestClient.LocationsHttpClient;
/**
* Get the url for the given service
* @param serviceInstanceId Unique id for the service
* @param hostType The host level to get the url for
* @param webContext The original context to get the url for
* @param faultInMissingHost If true, attempt to fault in the target host if the location's service definition doesn't already exist.
* @param authTokenManager A custom AuthTokenManager to be used when retrieving the SPS location for the host and when talking to the SPS instance subsequently
* @return Promise that resolves to the location string
*/
export function beginGetServiceLocation(serviceInstanceId: string, hostType: Contracts_Platform.ContextHostType, webContext?: Contracts_Platform.WebContext, faultInMissingHost?: boolean, authTokenManager?: IAuthTokenManager<any>): IPromise<string>;
}
declare module "VSS/Locations/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_Identities_Contracts = require("VSS/Identities/Contracts");
export interface AccessMapping {
    accessPoint: string;
    displayName: string;
    moniker: string;
    /**
     * The service which owns this access mapping e.g. TFS, ELS, etc.
     */
    serviceOwner: string;
    /**
     * Part of the access mapping which applies context after the access point of the server.
     */
    virtualDirectory: string;
}
/**
 * Data transfer class that holds information needed to set up a connection with a VSS server.
 */
export interface ConnectionData {
    /**
     * The Id of the authenticated user who made this request. More information about the user can be obtained by passing this Id to the Identity service
     */
    authenticatedUser: VSS_Identities_Contracts.Identity;
    /**
     * The Id of the authorized user who made this request. More information about the user can be obtained by passing this Id to the Identity service
     */
    authorizedUser: VSS_Identities_Contracts.Identity;
    /**
     * The id for the server.
     */
    deploymentId: string;
    /**
     * The type for the server Hosted/OnPremises.
     */
    deploymentType: VSS_Common_Contracts.DeploymentFlags;
    /**
     * The instance id for this host.
     */
    instanceId: string;
    /**
     * The last user access for this instance.  Null if not requested specifically.
     */
    lastUserAccess: Date;
    /**
     * Data that the location service holds.
     */
    locationServiceData: LocationServiceData;
    /**
     * The virtual directory of the host we are talking to.
     */
    webApplicationRelativeDirectory: string;
}
export enum InheritLevel {
    None = 0,
    Deployment = 1,
    Account = 2,
    Collection = 4,
    All = 7
}
export interface LocationMapping {
    accessMappingMoniker: string;
    location: string;
}
/**
 * Data transfer class used to transfer data about the location service data over the web service.
 */
export interface LocationServiceData {
    /**
     * Data about the access mappings contained by this location service.
     */
    accessMappings: AccessMapping[];
    /**
     * Data that the location service holds.
     */
    clientCacheFresh: boolean;
    /**
     * The time to live on the location service cache.
     */
    clientCacheTimeToLive: number;
    /**
     * The default access mapping moniker for the server.
     */
    defaultAccessMappingMoniker: string;
    /**
     * The obsolete id for the last change that took place on the server (use LastChangeId64).
     */
    lastChangeId: number;
    /**
     * The non-truncated 64-bit id for the last change that took place on the server.
     */
    lastChangeId64: number;
    /**
     * Data about the service definitions contained by this location service.
     */
    serviceDefinitions: ServiceDefinition[];
    /**
     * The identifier of the deployment which is hosting this location data (e.g. SPS, TFS, ELS, Napa, etc.)
     */
    serviceOwner: string;
}
export enum RelativeToSetting {
    Context = 0,
    WebApplication = 2,
    FullyQualified = 3
}
export interface ResourceAreaInfo {
    id: string;
    locationUrl: string;
    name: string;
}
export interface ServiceDefinition {
    description: string;
    displayName: string;
    identifier: string;
    inheritLevel: InheritLevel;
    locationMappings: LocationMapping[];
    /**
     * Maximum api version that this resource supports (current server version for this resource). Copied from <c>ApiResourceLocation</c>.
     */
    maxVersion: string;
    /**
     * Minimum api version that this resource supports. Copied from <c>ApiResourceLocation</c>.
     */
    minVersion: string;
    parentIdentifier: string;
    parentServiceType: string;
    properties: any;
    relativePath: string;
    relativeToSetting: RelativeToSetting;
    /**
     * The latest version of this resource location that is in "Release" (non-preview) mode. Copied from <c>ApiResourceLocation</c>.
     */
    releasedVersion: string;
    /**
     * The current resource version supported by this resource location. Copied from <c>ApiResourceLocation</c>.
     */
    resourceVersion: number;
    /**
     * The service which owns this definition e.g. TFS, ELS, etc.
     */
    serviceOwner: string;
    serviceType: string;
    status: ServiceStatus;
    toolId: string;
}
export enum ServiceStatus {
    Assigned = 0,
    Active = 1,
    Moving = 2
}
export var TypeInfo: {
    ConnectionData: any;
    InheritLevel: {
        enumValues: {
            "none": number;
            "deployment": number;
            "account": number;
            "collection": number;
            "all": number;
        };
    };
    LocationServiceData: any;
    RelativeToSetting: {
        enumValues: {
            "context": number;
            "webApplication": number;
            "fullyQualified": number;
        };
    };
    ServiceDefinition: any;
    ServiceStatus: {
        enumValues: {
            "assigned": number;
            "active": number;
            "moving": number;
        };
    };
};
}
declare module "VSS/Locations/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Locations/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To3_1 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected connectionDataApiVersion: string;
    protected serviceDefinitionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.ServiceDefinition[]>} serviceDefinitions
     * @return IPromise<void>
     */
    updateServiceDefinitions(serviceDefinitions: VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.ServiceDefinition[]>): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} serviceType
     * @return IPromise<Contracts.ServiceDefinition[]>
     */
    getServiceDefinitions(serviceType?: string): IPromise<Contracts.ServiceDefinition[]>;
    /**
     * [Preview API] Finds a given service definition.
     *
     * @param {string} serviceType
     * @param {string} identifier
     * @param {boolean} allowFaultIn - If true, we will attempt to fault in a host instance mapping if in SPS.
     * @param {boolean} previewFaultIn - If true, we will calculate and return a host instance mapping, but not persist it.
     * @return IPromise<Contracts.ServiceDefinition>
     */
    getServiceDefinition(serviceType: string, identifier: string, allowFaultIn?: boolean, previewFaultIn?: boolean): IPromise<Contracts.ServiceDefinition>;
    /**
     * [Preview API]
     *
     * @param {string} serviceType
     * @param {string} identifier
     * @return IPromise<void>
     */
    deleteServiceDefinition(serviceType: string, identifier: string): IPromise<void>;
    /**
     * [Preview API] This was copied and adapted from TeamFoundationConnectionService.Connect()
     *
     * @param {VSS_Common_Contracts.ConnectOptions} connectOptions
     * @param {number} lastChangeId - Obsolete 32-bit LastChangeId
     * @param {number} lastChangeId64 - Non-truncated 64-bit LastChangeId
     * @return IPromise<Contracts.ConnectionData>
     */
    getConnectionData(connectOptions?: VSS_Common_Contracts.ConnectOptions, lastChangeId?: number, lastChangeId64?: number): IPromise<Contracts.ConnectionData>;
}
/**
 * @exemptedapi
 */
export class LocationsHttpClient3_1 extends CommonMethods2To3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LocationsHttpClient3 extends CommonMethods2To3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LocationsHttpClient2_3 extends CommonMethods2To3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LocationsHttpClient2_2 extends CommonMethods2To3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LocationsHttpClient2_1 extends CommonMethods2To3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class LocationsHttpClient2 extends CommonMethods2To3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class LocationsHttpClient extends LocationsHttpClient3_1 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
}
declare module "VSS/LWP" {
import React = require("react");
/**
 * Gets an already loaded new-platform LWP module
 *
 * @param moduleName Module path
 */
export function getLWPModule(moduleName: string): any;
/**
 * Registers a React component with the new web platform (if available)
 *
 * @param componentType Named component type
 * @param reactClass React component class
 */
export function registerLWPComponent(componentType: string, reactClass: React.ComponentClass<any>): void;
}
declare module "VSS/Navigation/HubsProvider" {
import Serialization = require("VSS/Serialization");
/**
 * Base class for hubs providers.
 */
export class HubsProvider implements IHubsProvider {
    private _containerHubPromises;
    private _containerHubCommonPromise;
    private _refreshDelegates;
    private _variesByOwner;
    /**
     * Create a hubs provider
     *
     * @param sameAtAllLevels True if the provider's items are different based on the owner control
     */
    constructor(variesByOwner: boolean);
    /**
     * Get the root contributed hub for this provider
     *
     * @param context hubs provider context
     */
    protected getRootContributedHub(context: IHubsProviderContext): IContributedHub | IPromise<IContributedHub>;
    getContainerHub(context: IHubsProviderContext): IPromise<IContributedHub>;
    invokeRefreshCallbacks(): void;
    /**
     * Get page data from a data provider contribution that is cached, optionally queueing an update of the data
     * after reading from the cache
     *
     * @param cachedDataProviderContributionId Id of the data provider which caches data in localStorage
     * @param primaryDataProviderContributionId Optional contribution id of a data provider to use if it exists. The cached data will not be used or updated if this exists.
     * @param refreshCache If true and data was read from the cache, queue up a request to update it.
     * @param contractMetadata Optional contract metadata to use when deserializing the JSON island data
     */
    getCachedPageData<T>(cachedDataProviderContributionId: string, primaryDataProviderContributionId?: string, refreshCache?: boolean, contractMetadata?: Serialization.ContractMetadata): T;
    /**
     * Always reloads provider data by queuing up a new request
     *
     * @param cachedDataProviderContributionId Id of the data provider
     * @param properties Additional properties to pass to the provider on reload as part of the context
     */
    reloadCachedProviderData(cachedDataProviderContributionId: string, properties?: any): void;
}
}
declare module "VSS/Navigation/HubsService" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import PlatformContracts = require("VSS/Common/Contracts/Platform");
import Service = require("VSS/Service");
/**
 * Hub-related event names
 */
export module HubEventNames {
    /**
     * Event fired when xhr navigate is initiated.  This will fire prior to PreXHRNavigate.
     */
    const XHRNavigateStarted = "hub-navigate-started";
    /**
     * Event fired before the AJAX call is made to get data for the hub being navigated to
     */
    const PreXHRNavigate = "hub-navigate-pre-xhr";
    /**
     * Event fired after the XHR request of a navigation has completed, allowing services to update their context.
     */
    const ProcessXHRNavigate = "hub-navigate-process";
    /**
     * Event fired after an XHR navigation has completed. UI can update itself with the new hub's UI on this event
     */
    const PostXHRNavigate = "hub-navigate-post-xhr";
    /**
     * Event fired when the selected hub has changed. The navigation-related UI should update itself when this event is fired
     */
    const SelectedHubChanged = "selected-hub-changed";
}
/**
* Argument data passed to hub events
*/
export interface IHubEventArgs {
    /**
    * The id of the hub that the event corresponds to
    */
    hubId?: string;
    /**
    * The hub that the event corresponds to
    */
    hub?: Hub;
    /**
    * The page json data from
    */
    pageXHRData?: PlatformContracts.PageXHRData;
}
/**
 * Service for managing the hubs on the current page
 */
export class HubsService implements Service.ILocalService {
    private static LOCAL_STORAGE_KEY;
    private _hubsContext;
    private _pinningPreferences;
    constructor();
    /**
     * Get the id of the selected hub group
     */
    getSelectedHubGroupId(): string;
    /**
     * Get the id of the selected hub
     */
    getSelectedHubId(): string;
    /**
     * Gets all hub groups
     */
    getHubGroups(): Contracts_Platform.HubGroup[];
    /**
     * Get the hubs in the specified hub group
     *
     * @param id Id of the hub group
     * @param excludeContributed If true, exclude contributed hubs
     * @param excludeBuiltIn If true, exclude built-in hubs
     * @param includeHidden If true, exclude hidden hubs
     */
    getHubsByGroupId(id: string, excludeContributed?: boolean, excludeBuiltIn?: boolean, includeHidden?: boolean): Hub[];
    /**
     * Gets the hub group by its id.
     *
     * @param id Id of the hub group to return.
     * @returns {HubGroup}
     */
    getHubGroupById(id: string): HubGroup;
    /**
     * Gets the hub by its id
     *
     * @param id Id of the hub to return
     */
    getHubById(id: string): Hub;
    /**
     * Gets non-built in, pinned hubs.
     *
     * @param hubGroupId Id of the hub group
     */
    getPinnedHubsByGroupId(hubGroupId: string): {
        pinnedHubs: Hub[];
        unpinnedHubs: Hub[];
    };
    /**
     * Is the specified hub group explicitly pinned by the user?
     *
     * @param hubGroup The hub group to check
     */
    isHubGroupPinned(hubGroup: HubGroup): boolean;
    /**
     * Is the specified hub group explicitly unpinned by the user?
     *
     * @param hubGroup Hub group to check
     */
    isHubGroupUnpinned(hubGroup: HubGroup): boolean;
    /**
     * Pin the hub group for the current user
     *
     * @param hubGroup Hub group to pin
     */
    pinHubGroup(hubGroup: HubGroup): void;
    /**
     * Unpin the hub group for the current user
     *
     * @param hubGroup Hub group to unpin
     */
    unpinHubGroup(hubGroup: HubGroup): void;
    /**
     * Returns true if the specified hub has not been explicitly unpinned by the current user
     *
     * @param hub The hub to check
     */
    isHubPinned(hub: Hub): boolean;
    /**
     * Pin the specified hub for the current user
     *
     * @param hub Hub to pin
     */
    pinHub(hub: Hub): void;
    /**
     * Unpin the specified hub for the current user
     *
     * @param hub Hub to unpin
     */
    unpinHub(hub: Hub): void;
    getPinningPreferences(): PinningPreferences;
    /**
     * Get the default hub to use for the specified hub group
     *
     * @param hubGroup The hub group whose default hub to return
     * @param hubGroupHubs Optional list of the hubs to consider for the group.
     */
    getDefaultHubForHubGroup(hubGroup: HubGroup, hubGroupHubs?: Hub[]): Hub;
    /**
     * Saves details of the current route to Local Storage, keyed off of the Hub Group ID.
     *
     * @param hubGroupId The id of the hub group
     * @param hubId The id of the hub to save/remember as the default hub for the hub group for this user
     */
    saveDefaultHubForGroup(hubGroupId: string, hubId: string): void;
    /**
     * Trigger the global selected-hub-changed event, letting the system know that the current hub
     * has changed, so all navigation-related elements should be updated appropriately.
     *
     * @param hubId The id of the newly selected hub
     */
    triggerSelectedHubChangedEvent(hubId: string): void;
    /**
     * Navigate the page to the specified hub
     *
     * @param hubId Id of the hub to navigate to
     * @param url (Optional) Specific url to navigate to. The hub's default url if not specified.
     */
    navigateToHub(hubId: string, url?: string): void;
    /**
     * Replace current hub state
     *
     * @param hubId Id of the hub to navigate to
     * @param url (Optional) Specific url to navigate to. The hub's default url if not specified.
     */
    replaceCurrentHubState(hubId: string, url?: string): void;
    /**
     * Get an event handler to navigate to the specified hub
     *
     * @param hubId Id of the hub to navigate to
     * @param url Optional specific url for the hub (the hub's default url if not specified)
     */
    getHubNavigateHandler(hubId: string, url?: string): (e: any) => boolean;
}
}
declare module "VSS/Navigation/Location" {
import { IParsedRoute } from "VSS/Utils/Url";
import { ILocalService } from "VSS/Service";
export class LocationService implements ILocalService {
    private _parsedRoutes;
    /**
     * Gets the route templates for a given route
     *
     * @param routeId Id of the route
     */
    routeTemplates(routeId: string): IParsedRoute[];
    /**
     * Generate a url for the given route id with the given route values
     *
     * @param routeId Id of the route to generate a url for
     * @param routeValues Dictionary of route values
     */
    routeUrl(routeId: string, routeValues: IDictionaryStringTo<string>, hostPath?: string): string;
}
}
declare module "VSS/Navigation/NavigationHistoryService" {
/**
 * Service to manage browser history and navigation state
 */
export interface INavigationHistoryService {
    /**
     * Updates (replaces) the current history entry, optionally updating the address bar with a new url
     *
     * @param state Optional set of current URL state parameters (route values and query parameters). If not specified, computed from the given url.
     * @param url Optional url to update the address bar with. If not specified, computed from the given state (and current page's route template).
     * @param routeId Optional route id to set for this entry. If not specified, the current page's route id is used.
     * @param navigationElementId Optional id of the navigation element that this entry targets. If not specified the current page's hub id is used.
     */
    replaceState(state: {
        [key: string]: string;
    }, url?: string, routeId?: string, navigationElementId?: string): any;
    /**
     * Adds a new history entry, updating the address bar with a new url
     *
     * @param state Optional set of current URL state parameters (route values and query parameters). If not specified, computed from the given url.
     * @param url Optional url to update the address bar with. If not specified, computed from the given state (and current page's route template).
     * @param routeId Optional route id to set for this entry. If not specified, the current page's route id is used.
     * @param navigationElementId Optional id of the navigation element that this entry targets. If not specified the current page's hub id is used.
     * @param forcePush Optional boolean to push state even when the url is same
     */
    pushState(state: {
        [key: string]: string;
    }, url?: string, routeId?: string, navigationElementId?: string, forcePush?: boolean): any;
    /**
     * Get the current dictionary of all URL state parameters. This includes route values as well as query parameters.
     */
    getState(): {
        [key: string]: string;
    };
    /**
     * Generate a URL given the current navigation state values
     *
     * @param state State values (query parameters and route values)
     * @param mergeOptions Options around whether the provided state just provides overrides for the current navigation
     *        state or a full set of state values. The default is to merge with the current navigation state.
     */
    generateUrl(state: {
        [key: string]: string;
    }, mergeOptions?: StateMergeOptions): string;
    /**
     * Generate a URL for a given route given the current navigation state values
     *
     * @param routeId Id of the route to generate link for
     * @param state State values (query parameters and route values)
     * @param mergeOptions Options around whether the provided state just provides overrides for the current navigation
     *        state or a full set of state values. The default is to merge with the current navigation state.
     */
    generateUrlForRoute(routeId: string, state: {
        [key: string]: string;
    }, mergeOptions?: StateMergeOptions): string;
    /**
     * Get the current value for all the routeValues used for the current page.
     */
    getCurrentRouteValues(): {
        [key: string]: string;
    };
    /**
     * Get the route id for the current page.
     */
    getCurrentRouteId(): string;
    /**
     * Subscribe to pop state events. The provided listener is invoked whenever a forward or back navigation
     * has occurred to a push-state entry that this service is managing.
     *
     * @param listener Method invoked when a forward or back navigation has occurred.
     */
    subscribe(listener: (event: INavigationPopStateEvent) => void): any;
    /**
     * Remove a pop-state listener.
     *
     * @param listener Listener to remove.
     */
    unsubscribe(listener: (event: INavigationPopStateEvent) => void): any;
    /**
     * Register that the same code handles the aliasRouteId as hanldes the baseRouteId. Navigation
     * between routes that map to the same baseRouteId won't set isNewRoute on the navigation
     * events.
     */
    registerRouteAlias(baseRouteId: string, aliasRouteId: string): void;
}
/**
 * The state pushed in a single history entry
 */
export interface INavigationHistoryEntry {
    /**
     * Dictionary of all URL state parameters used in this history entry. This includes
     * route values as well as query parameters.
     */
    state: {
        [key: string]: string;
    };
    /**
     * The id of the route that this entry is using
     */
    routeId: string;
    /**
     * The contribution id of the selected navigation element (like a hub) for this history entry.
     */
    navigationElementId: string;
    /**
     * The url for this entry
     */
    url: string;
}
/**
 * Event triggered when a browser history entry has been popped (back or forward navigate)
 */
export interface INavigationPopStateEvent {
    /**
     * The previous history entry that we navigated away from
     */
    oldState: INavigationHistoryEntry;
    /**
     * The new/current history entry
     */
    newState: INavigationHistoryEntry;
    /**
     * True if the new state has a different route id than the previous state.
     */
    isNewRouteId: boolean;
}
/**
 * Set of options used when supplying a state dictionary for generating a URL, or when
 * modifying existing state.
 */
export const enum StateMergeOptions {
    /**
     * Don't merge any current values into the state object. The given state object
     * represents all state values to use.
     */
    none = 0,
    /**
     * Merge with the current route values (those defined in the route template).
     * Current query parameters are NOT merged into the given state object. Values for the current route
     * values will be overridden by entries in the given state object.
     */
    routeValues = 1,
    /**
     * Merge with all current navigation state values. The given state just overrides entries in
     * the current navigation state.
     */
    currentState = 2
}
export function getNavigationHistoryService(): INavigationHistoryService;
}
declare module "VSS/Navigation/Services" {
import Service = require("VSS/Service");
/**
* Handler for pop state events.
*/
export interface IPopStateHandler {
    /**
    * Handler for pop state events
    *
    * @param newState The new push state
    * @param oldState The previous push state
    *
    * @returns True if the event was handled. False otherwise.
    */
    (newState: Object, previousState: Object): boolean;
}
/**
* Local service to manage history and navigation state
*/
export class HistoryService implements Service.ILocalService {
    private _namedEvents;
    private _usePushState;
    private _suppressNavigate;
    private _initialized;
    private _lastNavigatedHashString;
    private _lastNavigatedQueryString;
    private _ignoreQueryString;
    private _onHashChangedDelegate;
    private _navHistoryService;
    constructor();
    /**
    * Gets the serialized version of the current navigation state.
    */
    getCurrentFragment(): string;
    /**
    * Gets the current url's hash string
    */
    getCurrentHashString(): string;
    /**
    * Gets the current url's query string
    */
    getCurrentQueryString(): string;
    /**
     * Creates a fragment url to be used in flight navigation.
     * This always returns a fragment link, regardless of the browser's capability to handle push state.
     *
     * @param action The action name
     * @param data Action parameters
     * @return fragment URL in the form of #_a=[action]&routevalue1=routevalue2...
     */
    getFragmentActionLink(action: string, data?: any): string;
    /**
    * Get the current navigation state dictionary. Uses query parameters and hash parameters.
    */
    getCurrentState(): any;
    /**
    * Replace the current history entry with the given state.
    * The back button will therefore not map to the current url (at the time this call is made), but rather to the previous history entry.
    *
    * @param action The "action" state parameter. This is the _a key in the url or "action" in the current state dictionary
    * @param data The new full set of navigation/history entries. This set completely replaces the current set.
    * @param windowTitle The new window title. A null or empty value indicates to leave the title unchanged.
    * @param suppressNavigate If true, don't trigger any of the attached navigate event handlers due to this update.
    * @param mergeCurrentState If true, the supplied data just modify the existing/current state. If false, they replace all existing key/value pairs.
    */
    replaceHistoryPoint(action: string, data: any, windowTitle?: string, suppressNavigate?: boolean, mergeCurrentState?: boolean): void;
    /**
    * Add a new history entry with the given state. Merges data with the current navigation data.
    *
    * @param action The "action" state parameter. This is the _a key in the url or "action" in the current state dictionary
    * @param data New history entries to merge into the current navigation data. Set keys to null/undefined to remove them from the current state.
    * @param windowTitle The new window title. A null or empty value indicates to leave the title unchanged.
    * @param suppressNavigate If true, don't trigger any of the attached navigate event handlers due to this update.
    * @param mergeCurrentState If true, the supplied data just modify the existing/current state. If false, they replace all existing key/value pairs.
    */
    addHistoryPoint(action: string, data?: any, windowTitle?: string, suppressNavigate?: boolean, mergeCurrentState?: boolean): void;
    /**
    * Update the current history entry
    *
    * @param action The "action" state parameter. This is the _a key in the url or "action" in the current state dictionary
    * @param data The history entry's new state key/value pairs
    * @param replaceHistoryEntry If true, replace the current history entry. Otherwise, add a new history entry.
    * @param mergeWithCurrentState If true, the supplied data just modify the existing/current state. If false, they replace all existing key/value pairs.
    * @param windowTitle The new window title. A null or empty value indicates to leave the title unchanged.
    * @param suppressNavigate If true, don't trigger any of the attached navigate event handlers due to this update.
    */
    updateHistoryEntry(action: string, data?: IDictionaryStringTo<any>, replaceHistoryEntry?: boolean, mergeWithCurrentState?: boolean, windowTitle?: string, suppressNavigate?: boolean): void;
    /**
    * Serialize a navigation data lookup into a string that can be used as a hash or query string.
    *
    * @param state The navigation state dictionary to convert
    */
    static serializeState(state: IDictionaryStringTo<any>): string;
    /**
    * Deserialize a navigation state string into a navigation data lookup.
    *
    * @param state The serialized navigation state string (hash or query string)
    */
    static deserializeState(state: string): IDictionaryStringTo<any>;
    /**
    * Attach a new navigate handler
    *
    * @param handler The method called whenever a navigation event occurs
    * @param checkCurrentState If true, immediately invoke the handler
    */
    attachNavigate(handler: IFunctionPPR<any, any, void>, checkCurrentState?: boolean): void;
    /**
    * Attach a new navigate handler
    *
    * @param action The action that the handler applies to
    * @param handler The method called whenever a navigation event occurs with the matching action value
    * @param checkCurrentState If true, immediately invoke the handler if the current state is appropriate (has the matching action value)
    */
    attachNavigate(action: string, handler: IFunctionPPR<any, any, void>, checkCurrentState?: boolean): void;
    /**
    * Remove a navigate handler
    *
    * @param handler The global navigate handler method to remove
    */
    detachNavigate(handler: IFunctionPPR<any, any, void>): void;
    /**
    * Remove a navigate handler
    *
    * @param action The action that the handler applies to
    * @param handler The method called whenever a navigation event occurs with the matching action value
    */
    detachNavigate(action: string, handler?: IFunctionPPR<any, any, void>): void;
    /**
     * Add a new history entry to the browser's history (updating the url in the address bar)
     *
     * @param url Url to update the browser's address bar to
     */
    pushState(url: string): void;
    /**
     * Replace the current history entry in the browser's history (updating the url in the address bar)
     *
     * @param url Url to update the browser's address bar to
     */
    replaceState(url: string): void;
    private _getFullTitle;
    private _getRootUrl;
    private _moveHashStateToQueryParams;
    private _onHashChanged;
    private _onPopState;
    private _onNavigate;
    private _setLastNavigateState;
}
/**
* Gets the instance of the local History service
*/
export function getHistoryService(): HistoryService;
/**
* Gets page title using the default page title format
*/
export function getDefaultPageTitle(title: string): string;
/**
* Gets default page title format
*/
export function getDefaultPageTitleFormatString(): string;
}
declare module "VSS/NewDomainUrlMigration/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\cloud.webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_ReparentCollection_Contracts = require("VSS/ReparentCollection/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
/**
 * @exemptedapi
 */
export class NewDomainUrlOrchestrationHttpClient5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @return IPromise<VSS_ReparentCollection_Contracts.ServicingOrchestrationRequestStatus>
     */
    getStatus(): IPromise<VSS_ReparentCollection_Contracts.ServicingOrchestrationRequestStatus>;
    /**
     * [Preview API]
     *
     * @param {boolean} codexDomainUrls
     * @return IPromise<void>
     */
    queueMigration(codexDomainUrls: boolean): IPromise<void>;
}
export class NewDomainUrlOrchestrationHttpClient extends NewDomainUrlOrchestrationHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return NewDomainUrlOrchestrationHttpClient5
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): NewDomainUrlOrchestrationHttpClient5;
}
declare module "VSS/Operations/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
/**
 * Contains information about the progress or result of an async operation.
 */
export interface Operation extends OperationReference {
    /**
     * Links to other related objects.
     */
    _links: any;
    /**
     * Detailed messaged about the status of an operation.
     */
    detailedMessage: string;
    /**
     * Result message for an operation.
     */
    resultMessage: string;
    /**
     * URL to the operation result.
     */
    resultUrl: OperationResultReference;
}
/**
 * Reference for an async operation.
 */
export interface OperationReference {
    /**
     * Unique identifier for the operation.
     */
    id: string;
    /**
     * Unique identifier for the plugin.
     */
    pluginId: string;
    /**
     * The current status of the operation.
     */
    status: OperationStatus;
    /**
     * URL to get the full operation object.
     */
    url: string;
}
export interface OperationResultReference {
    /**
     * URL to the operation result.
     */
    resultUrl: string;
}
/**
 * The status of an operation.
 */
export enum OperationStatus {
    /**
     * The operation does not have a status set.
     */
    NotSet = 0,
    /**
     * The operation has been queued.
     */
    Queued = 1,
    /**
     * The operation is in progress.
     */
    InProgress = 2,
    /**
     * The operation was cancelled by the user.
     */
    Cancelled = 3,
    /**
     * The operation completed successfully.
     */
    Succeeded = 4,
    /**
     * The operation completed with a failure.
     */
    Failed = 5
}
export var TypeInfo: {
    Operation: any;
    OperationReference: any;
    OperationStatus: {
        enumValues: {
            "notSet": number;
            "queued": number;
            "inProgress": number;
            "cancelled": number;
            "succeeded": number;
            "failed": number;
        };
    };
};
}
declare module "VSS/Operations/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Operations/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected operationsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * Gets an operation from the the operationId using the given pluginId.
     *
     * @param {string} operationId - The ID for the operation.
     * @param {string} pluginId - The ID for the plugin.
     * @return IPromise<Contracts.Operation>
     */
    getOperation(operationId: string, pluginId?: string): IPromise<Contracts.Operation>;
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OperationsHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class OperationsHttpClient extends OperationsHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return OperationsHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): OperationsHttpClient4_1;
}
declare module "VSS/OrganizationPolicy/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\organizationpolicy.genclient.json
 */
export interface Policy {
    effectiveValue: any;
    enforce: boolean;
    isValueUndefined: boolean;
    name: string;
    parentPolicy: Policy;
    value: any;
}
export interface PolicyInfo {
    description: string;
    moreInfoLink: string;
    name: string;
}
}
declare module "VSS/OrganizationPolicy/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\organizationpolicy.genclient.json
 */
import Contracts = require("VSS/Organization/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3To5 extends VSS_WebApi.VssHttpClient {
    protected policiesApiVersion: string;
    protected policiesBatchApiVersion: string;
    protected policyInformationApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string[]} policyNames
     * @return IPromise<{ [key: string] : Contracts.PolicyInfo; }>
     */
    getPolicyInformations(policyNames?: string[]): IPromise<{
        [key: string]: Contracts.PolicyInfo;
    }>;
    /**
     * [Preview API]
     *
     * @param {string} policyName
     * @return IPromise<Contracts.PolicyInfo>
     */
    getPolicyInformation(policyName: string): IPromise<Contracts.PolicyInfo>;
    /**
     * [Preview API]
     *
     * @param {string[]} policyNames
     * @param {string[]} defaultValues
     * @return IPromise<{ [key: string] : Contracts.Policy; }>
     */
    getPolicies(policyNames: string[], defaultValues: string[]): IPromise<{
        [key: string]: Contracts.Policy;
    }>;
    /**
     * [Preview API]
     *
     * @param {VSS_Common_Contracts.JsonPatchDocument} patchDocument
     * @param {string} policyName
     * @return IPromise<void>
     */
    updatePolicy(patchDocument: VSS_Common_Contracts.JsonPatchDocument, policyName: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} policyName
     * @param {string} defaultValue
     * @return IPromise<Contracts.Policy>
     */
    getPolicy(policyName: string, defaultValue: string): IPromise<Contracts.Policy>;
}
/**
 * @exemptedapi
 */
export class OrganizationPolicyHttpClient5 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationPolicyHttpClient4_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationPolicyHttpClient4 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationPolicyHttpClient3_2 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationPolicyHttpClient3_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationPolicyHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class OrganizationPolicyHttpClient extends OrganizationPolicyHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return OrganizationPolicyHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): OrganizationPolicyHttpClient4_1;
}
declare module "VSS/Organization/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\organization.genclient.json
 */
export interface Collection {
    data: {
        [key: string]: any;
    };
    dateCreated: Date;
    /**
     * Identifier for a collection under an organization
     */
    id: string;
    lastUpdated: Date;
    /**
     * The unqiue name of collection under an organziation
     */
    name: string;
    owner: string;
    preferredRegion: string;
    /**
     * Extended properties
     */
    properties: any;
    status: CollectionStatus;
}
export enum CollectionSearchKind {
    Unknown = 0,
    ById = 1,
    ByName = 2,
    ByTenantId = 3
}
export enum CollectionStatus {
    Unknown = 0,
    Initial = 10,
    Enabled = 20,
    LogicallyDeleted = 30,
    MarkedForPhysicalDelete = 40
}
export interface Logo {
    /**
     * The image for the logo represented as a byte array
     */
    image: number[];
}
export interface Organization {
    collections: Collection[];
    creatorId: string;
    data: {
        [key: string]: any;
    };
    dateCreated: Date;
    /**
     * Identifier for an Organization
     */
    id: string;
    isActivated: boolean;
    lastUpdated: Date;
    name: string;
    preferredRegion: string;
    primaryCollection: Collection;
    /**
     * Extended properties
     */
    properties: any;
    status: OrganizationStatus;
    tenantId: string;
    type: OrganizationType;
}
export interface OrganizationMigrationBlob {
    blobAsJson: string;
    id: string;
}
export enum OrganizationSearchKind {
    Unknown = 0,
    ById = 1,
    ByName = 2,
    ByTenantId = 3
}
export enum OrganizationStatus {
    Unknown = 0,
    Initial = 10,
    Enabled = 20,
    MarkedForDelete = 30
}
export enum OrganizationType {
    Unknown = 0,
    Personal = 1,
    Work = 2
}
export interface Policy {
    effectiveValue: any;
    enforce: boolean;
    isValueUndefined: boolean;
    name: string;
    parentPolicy: Policy;
    value: any;
}
export interface PolicyInfo {
    description: string;
    moreInfoLink: string;
    name: string;
}
export interface Region {
    /**
     * The number of hosts that are readily available for host creation in this region on this service instance
     */
    availableHostsCount: number;
    /**
     * Display name for the region.
     */
    displayName: string;
    /**
     * Whether the region is default or not
     */
    isDefault: boolean;
    /**
     * Name identifier for the region.
     */
    name: string;
    /**
     * Short name used in Microsoft Azure. Ex: southcentralus, westcentralus, southindia, etc.
     */
    nameInAzure: string;
    /**
     * The identifier of the service instance that supports host creations in this region
     */
    serviceInstanceId: string;
}
export var TypeInfo: {
    Collection: any;
    CollectionSearchKind: {
        enumValues: {
            "unknown": number;
            "byId": number;
            "byName": number;
            "byTenantId": number;
        };
    };
    CollectionStatus: {
        enumValues: {
            "unknown": number;
            "initial": number;
            "enabled": number;
            "logicallyDeleted": number;
            "markedForPhysicalDelete": number;
        };
    };
    Organization: any;
    OrganizationSearchKind: {
        enumValues: {
            "unknown": number;
            "byId": number;
            "byName": number;
            "byTenantId": number;
        };
    };
    OrganizationStatus: {
        enumValues: {
            "unknown": number;
            "initial": number;
            "enabled": number;
            "markedForDelete": number;
        };
    };
    OrganizationType: {
        enumValues: {
            "unknown": number;
            "personal": number;
            "work": number;
        };
    };
};
}
declare module "VSS/Organization/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\organization.genclient.json
 */
import Contracts = require("VSS/Organization/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected collectionPropertiesApiVersion: string;
    protected collectionsApiVersion: string;
    protected organizationLogoApiVersion: string;
    protected organizationMigrationBlobsApiVersion: string;
    protected organizationPropertiesApiVersion: string;
    protected organizationsApiVersion: string;
    protected regionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {boolean} includeRegionsWithNoAvailableHosts
     * @param {string} impersonatedUser
     * @return IPromise<Contracts.Region[]>
     */
    getRegions(includeRegionsWithNoAvailableHosts?: boolean, impersonatedUser?: string): IPromise<Contracts.Region[]>;
    /**
     * [Preview API]
     *
     * @param {VSS_Common_Contracts.JsonPatchDocument} patchDocument
     * @param {string} organizationId
     * @return IPromise<Contracts.Organization>
     */
    updateOrganization(patchDocument: VSS_Common_Contracts.JsonPatchDocument, organizationId: string): IPromise<Contracts.Organization>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OrganizationSearchKind} searchKind
     * @param {string} searchValue
     * @param {boolean} isActivated
     * @return IPromise<Contracts.Organization[]>
     */
    getOrganizations(searchKind: Contracts.OrganizationSearchKind, searchValue: string, isActivated?: boolean): IPromise<Contracts.Organization[]>;
    /**
     * [Preview API]
     *
     * @param {string} organizationId
     * @param {string[]} propertyNames
     * @return IPromise<Contracts.Organization>
     */
    getOrganization(organizationId: string, propertyNames?: string[]): IPromise<Contracts.Organization>;
    /**
     * [Preview API]
     *
     * @param {Contracts.Organization} resource
     * @return IPromise<Contracts.Organization>
     */
    createOrganization(resource: Contracts.Organization): IPromise<Contracts.Organization>;
    /**
     * [Preview API]
     *
     * @param {string} organizationId
     * @param {VSS_Common_Contracts.JsonPatchDocument} patchDocument
     * @return IPromise<boolean>
     */
    updateOrganizationProperties(organizationId: string, patchDocument: VSS_Common_Contracts.JsonPatchDocument): IPromise<boolean>;
    /**
     * [Preview API]
     *
     * @param {Contracts.OrganizationMigrationBlob} migrationBlob
     * @return IPromise<void>
     */
    importOrganizationMigrationBlob(migrationBlob: Contracts.OrganizationMigrationBlob): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} organizationId
     * @return IPromise<Contracts.OrganizationMigrationBlob>
     */
    exportOrganizationMigrationBlob(organizationId: string): IPromise<Contracts.OrganizationMigrationBlob>;
    /**
     * [Preview API]
     *
     * @param {string} organizationId
     * @param {Contracts.Logo} logo
     * @return IPromise<boolean>
     */
    updateOrganizationLogo(organizationId: string, logo: Contracts.Logo): IPromise<boolean>;
    /**
     * [Preview API]
     *
     * @param {VSS_Common_Contracts.JsonPatchDocument} patchDocument
     * @param {string} collectionId
     * @return IPromise<Contracts.Collection>
     */
    updateCollection(patchDocument: VSS_Common_Contracts.JsonPatchDocument, collectionId: string): IPromise<Contracts.Collection>;
    /**
     * [Preview API]
     *
     * @param {string} collectionId
     * @param {string} collectionName
     * @return IPromise<boolean>
     */
    restoreCollection(collectionId: string, collectionName: string): IPromise<boolean>;
    /**
     * [Preview API]
     *
     * @param {Contracts.CollectionSearchKind} searchKind
     * @param {string} searchValue
     * @param {boolean} includeDeletedCollections
     * @return IPromise<Contracts.Collection[]>
     */
    getCollections(searchKind?: Contracts.CollectionSearchKind, searchValue?: string, includeDeletedCollections?: boolean): IPromise<Contracts.Collection[]>;
    /**
     * [Preview API]
     *
     * @param {string} collectionId
     * @param {string[]} propertyNames
     * @return IPromise<Contracts.Collection>
     */
    getCollection(collectionId: string, propertyNames?: string[]): IPromise<Contracts.Collection>;
    /**
     * [Preview API]
     *
     * @param {string} collectionId
     * @param {number} gracePeriodToRestoreInHours
     * @param {boolean} violatedTerms
     * @return IPromise<boolean>
     */
    deleteCollection(collectionId: string, gracePeriodToRestoreInHours?: number, violatedTerms?: boolean): IPromise<boolean>;
    /**
     * [Preview API]
     *
     * @param {Contracts.Collection} resource
     * @return IPromise<Contracts.Collection>
     */
    createCollection(resource: Contracts.Collection): IPromise<Contracts.Collection>;
    /**
     * [Preview API]
     *
     * @param {string} collectionId
     * @param {VSS_Common_Contracts.JsonPatchDocument} patchDocument
     * @return IPromise<boolean>
     */
    updateCollectionProperties(collectionId: string, patchDocument: VSS_Common_Contracts.JsonPatchDocument): IPromise<boolean>;
}
/**
 * @exemptedapi
 */
export class OrganizationHttpClient5 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationHttpClient4_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationHttpClient4 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationHttpClient3_2 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationHttpClient3_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class OrganizationHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class OrganizationHttpClient extends OrganizationHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return OrganizationHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): OrganizationHttpClient4_1;
}
declare module "VSS/Performance" {
import Telemetry = require("VSS/Telemetry/Services");
/** Gets scenario manager instance */
export function getScenarioManager(): IScenarioManager;
/** DO NOT USE: Only exported for unit testing */
export function _createScenarioManagerForTesting(): IScenarioManager;
/** Scenario management */
export interface IScenarioManager {
    /**
     * Start new scenario
     * @param area Feature area of scenario.
     * @param name Name of scenario.
     * @param startTime Optional: Scenario start time. IMPORTANT: Has to be obtained using getTimestamp
     * @param isPageInteractive Optional: Whether or not the scenario is the primary one for the page, indicating whether or not hte page is yet interactive (TTI)
     * @param serviceInstanceType The id of the service instance type to send the telemetry to.
     *
     * @returns Scenario descriptor
     */
    startScenario(featureArea: string, name: string, startTime?: number, isPageInteractive?: boolean, serviceInstanceType?: string): IScenarioDescriptor;
    /**
     * End scenario if it's currently active
     * @param area Feature area of scenario.
     * @param name Name of scenario.
     */
    endScenario(featureArea: string, name: string): Promise<void>;
    /**
     * Abort scenario if it's currently active. Use this when a scenario that has started hit an error condition and you want to abort performance tracking for the scenario.
     * @param area Feature area of scenario.
     * @param name Name of scenario.
     */
    abortScenario(featureArea: string, name: string): void;
    /**
     * Start new scenario beginning at the browser's navigationStart event
     * @param featureArea Feature area name for CI event.
     * @param name Name of scenario.
     * @param isPageInteractive Optional: Whether or not the scenario is the primary one for the page, indicating whether or not hte page is yet interactive (TTI)
     * @param serviceInstanceType The id of the service instance type to send the telemetry to
     * @param includePageLoadScenarioData Include the default page load scenario data
     *
     * @returns Scenario descriptor
     */
    startScenarioFromNavigation(featureArea: string, name: string, isPageInteractive?: boolean, serviceInstanceType?: string, includePageLoadScenarioData?: boolean): IScenarioDescriptor;
    /**
     * Record a page load scenario.
     * @param area Feature area name for CI event.
     * @param name Name of scenario.
     * @param data Optional data to be recorded with scenario
     * @param serviceInstanceType The id of the service instance type to send the telemetry to
     */
    recordPageLoadScenarioForService(featureArea: string, name: string, data?: any, serviceInstanceType?: string): any;
    /**
     * Record a page load scenario.
     * @param area Feature area name for CI event.
     * @param name Name of scenario.
     * @param data Optional data to be recorded with scenario
     */
    recordPageLoadScenario(featureArea: string, name: string, data?: any): any;
    /**
     * Get active scenarios with given area/name
     * @param area Feature area of scenario.
     * @param name Name of scenario.
     */
    getScenarios(featureArea: string, name: string): IScenarioDescriptor[];
    /**
     * Get all completed scenarios
     */
    getAllCompletedScenarios(): IScenarioDescriptor[];
    /**
     * Insert split timing for all currently active scenarios
     * @param splitName Name of split timing
     */
    split(splitName: string): void;
    /**
     * Add information about ajax call to all currently active scenarios
     * @returns Function to end measurement
     */
    addAjaxCallStart(): IEndAjaxCallTiming;
    /**
     * Add an event listener for scenario-complete events
     *
     * @param callback Method invoked when a perf scenario has been marked as completed
     */
    addScenarioCompletedListener(callback: IPerfScenarioEventCallback): void;
    /**
     * Get status of page load scenario
     * @returns boolean indicating whether the page load scenario is active
     */
    isPageLoadScenarioActive(): boolean;
    /**
     * Resets page interactive event and starts default scenario
     */
    resetPageLoadScenario(): void;
    /**
     * Indicate whether the page load scenario is full navigation (i.e. not an FPS navigate).
     */
    isPageLoadScenarioFullNavigation(): boolean;
}
/** Describes split timing within scenarios */
export interface ISplitTiming {
    /** Name of split timing */
    name: string;
    /** Time relative to scenario start */
    timestamp: number;
    /** Deprecated: Elapsed time for split timing. */
    elapsedTime?: number;
}
export interface IEndAjaxCallTiming {
    /**
     * @param url Url of ajax request
     * @param method HTTP method
     * @param activityId ActivityId for server call
     * @param status HTTP status
     * @param contentLength Length of content
     */
    (url: string, method: string, activityId: string, status?: number, contentLength?: number): void;
}
/** Describes timing for an ajax call made while a scenario was active */
export interface IAjaxCallTiming {
    url: string;
    method: string;
    activityId: string;
    status?: number;
    contentLength?: number;
    timestampStart: number;
    duration: number;
}
/** Describes single scenario */
export interface IScenarioDescriptor {
    /** Returns a value indicating whether the scenario is active */
    isActive(): boolean;
    /**
    * Determines whether or not the scenario is the primary indicator
    * of Time-to-Interactive on the page
    */
    isPageInteractive(): boolean;
    /** Returns scenario area */
    getFeatureArea(): string;
    /** Returns scenario name */
    getName(): string;
    /** Returns scenario duration in ms */
    getDuration(): number;
    /** Get the scenario start timestamp */
    getStartTime(): number;
    /** Returns scenario's correlation id */
    getCorrelationId(): string;
    /** Return split timings */
    getSplitTimings(): ISplitTiming[];
    /** Return ajax call timings */
    getAjaxCalls(): IAjaxCallTiming[];
    /** Return the data associated with the scenario */
    getData(): any;
    /** Ends this scenario
     * @param endTime Optional Scenario End Time. IMPORTANT: Has to be obtained using getTimestamp
     */
    end(endTime?: number): Promise<void>;
    /** Aborts this scenario */
    abort(): void;
    /**
     * Add split timing at current timestamp
     * @param name Name of split timing
     * @param elapsedTime Optional: Deprecated: Store elapsed time in addition to split
     */
    addSplitTiming(name: string, elapsedTime?: number): any;
    /**
     * Add information about ajax call to scenario

     * @returns Function to end measurement
     */
    addAjaxCallStart(): IEndAjaxCallTiming;
    /**
     * Add additional data to the scenario.
     * @param data Property bag of additional data
     */
    addData(data: any): void;
    /**
     * Logs scenario data to the browser's console
     */
    log(): void;
    /** Returns telemetry data for scenario */
    getTelemetry(): Telemetry.TelemetryEventData;
    /** Get the service through which the telemetry should be emitted.
     * The default is undefined which translates to TFS.
     */
    getServiceInstanceType(): string;
    /** Set the service through which the telemetry should be emitted. */
    setServiceInstanceType(serviceInstanceType: string): any;
}
export interface IPerfScenarioEventCallback {
    (scenario: IScenarioDescriptor): void;
}
export interface IResourceTypeStats {
    total: number;
    cached: number;
    duration: number;
}
export interface IBundleLoadStats {
    downloadStartTime: number;
    downloadDuration: number;
    innerLoad: number;
    innerStartTime: number;
    outerLoad: number;
    outerStartTime: number;
    bundleName: string;
}
export interface IResourceStats {
    scripts: IResourceTypeStats;
    styles: IResourceTypeStats;
    ajax: IResourceTypeStats;
    other: IResourceTypeStats;
    all: IResourceTypeStats;
    bundleLoads: IBundleLoadStats[];
    scriptsTotalSize: number;
    cssTotalSize: number;
    requireStartTime: number;
}
/**
 * Get the performance timing entries with the specified name
 *
 * @param name The name of the timing entries to get
 */
export function getResourceTimingEntries(): PerformanceResourceTiming[];
/**
 * Get the performance timing entries with the specified name
 *
 * @param name The name of the timing entries to get
 */
export function getTimingEntriesByName(name: string): PerformanceEntry[];
/**
 * Get statistics about the resources currently loaded on the page
 */
export function getResourceStats(): IResourceStats;
/** Map native PerformanceEntry objects for serialization */
export interface IMappedPerformanceEntry {
    name: string;
    startTime: number;
    duration: number;
}
export interface INavigationEvent {
    name: string;
    startEvent: string;
    endEvent: string;
    perfEntry?: IMappedPerformanceEntry;
    isAggregate?: boolean;
}
/** Return performance events to add to each scenario from the performance API. Note: Will add measurements if not already added */
export function getDefaultNavigationEvents(scenario?: IScenarioDescriptor): INavigationEvent[];
export function getTimestamp(): number;
/**
 * Returns navigation start timestamp, or 0 if browser doesn't support it
 */
export function getNavigationStartTimestamp(): number;
/**
 * Decorator to time the decorated method and add it to a performance timeline trace
 *
 * Example:
 * ```ts
 * class Foo {
 *      @timeMethod
 *      public someMethod() {
 *           // Do something
 *      }
 * }
 * ```
 * @param name Optional name of the method, if not given
 */
export const timeMethod: (target: Object, methodName: string, descriptor: TypedPropertyDescriptor<any>) => {
    value: (...args: any[]) => any;
};
/**
 * Decorator to time the decorated method and add it to a performance timeline trace
 *
 * Example:
 * ```ts
 * class Foo {
 *      @timeMethodWithName("custom name")
 *      public someMethod2() {
 *           // Do something
 *      }
 * }
 * ```
 * @param name Optional name of the method, if not given
 */
export const timeMethodWithName: (name: string) => (target: Object, methodName: string, descriptor: TypedPropertyDescriptor<any>) => {
    value: (...args: any[]) => any;
};
}
declare module "VSS/Profile/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\profile.genclient.json
 */
export interface AttributeDescriptor {
    attributeName: string;
    containerName: string;
}
export interface AttributesContainer {
    attributes: {
        [key: string]: ProfileAttribute;
    };
    containerName: string;
    revision: number;
}
export interface Avatar {
    isAutoGenerated: boolean;
    size: AvatarSize;
    timeStamp: Date;
    value: number[];
}
/**
 * Small = 34 x 34 pixels; Medium = 44 x 44 pixels; Large = 220 x 220 pixels
 */
export enum AvatarSize {
    Small = 0,
    Medium = 1,
    Large = 2
}
export interface CoreProfileAttribute extends ProfileAttributeBase<any> {
}
export interface CreateProfileContext {
    cIData: {
        [key: string]: any;
    };
    contactWithOffers: boolean;
    countryName: string;
    displayName: string;
    emailAddress: string;
    hasAccount: boolean;
    language: string;
    phoneNumber: string;
    profileState: ProfileState;
}
export interface GeoRegion {
    regionCode: string;
}
export interface Profile {
    applicationContainer: AttributesContainer;
    coreAttributes: {
        [key: string]: CoreProfileAttribute;
    };
    coreRevision: number;
    id: string;
    profileState: ProfileState;
    revision: number;
    timeStamp: Date;
}
export interface ProfileAttribute extends ProfileAttributeBase<string> {
}
export interface ProfileAttributeBase<T> {
    descriptor: AttributeDescriptor;
    revision: number;
    timeStamp: Date;
    value: T;
}
/**
 * Country/region information
 */
export interface ProfileRegion {
    /**
     * The two-letter code defined in ISO 3166 for the country/region.
     */
    code: string;
    /**
     * Localized country/region name
     */
    name: string;
}
/**
 * Container of country/region information
 */
export interface ProfileRegions {
    /**
     * List of country/region code with contact consent requirement type of notice
     */
    noticeContactConsentRequirementRegions: string[];
    /**
     * List of country/region code with contact consent requirement type of opt-out
     */
    optOutContactConsentRequirementRegions: string[];
    /**
     * List of country/regions
     */
    regions: ProfileRegion[];
}
export enum ProfileState {
    Custom = 0,
    CustomReadOnly = 1,
    ReadOnly = 2
}
export interface RemoteProfile {
    avatar: number[];
    countryCode: string;
    displayName: string;
    /**
     * Primary contact email from from MSA/AAD
     */
    emailAddress: string;
}
export var TypeInfo: {
    AttributesContainer: any;
    Avatar: any;
    AvatarSize: {
        enumValues: {
            "small": number;
            "medium": number;
            "large": number;
        };
    };
    CoreProfileAttribute: any;
    CreateProfileContext: any;
    Profile: any;
    ProfileAttribute: any;
    ProfileAttributeBase: any;
    ProfileState: {
        enumValues: {
            "custom": number;
            "customReadOnly": number;
            "readOnly": number;
        };
    };
};
}
declare module "VSS/ReparentCollection/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\cloud.webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export interface FrameworkReparentCollectionRequest extends FrameworkServicingOrchestrationRequest {
    sourceOrganizationId: string;
    targetOrganizationId: string;
}
export interface FrameworkServicingOrchestrationRequest extends ServicingOrchestrationRequest {
    /**
     * Host Id this request is targeting
     */
    hostId: string;
}
export interface PropertyPair {
    name: string;
    value: string;
}
export interface ServicingOrchestrationRequest {
    /**
     * The Servicing Job Id used to process this particular request
     */
    jobId: string;
    /**
     * Property bag for the custom data
     */
    properties: PropertyPair[];
    /**
     * Id of the import request (MUST be the same for all activities of the particular import)
     */
    requestId: string;
    /**
     * Full type name of the payload used to construct proper object during the deserialization
     */
    typeName: string;
}
export interface ServicingOrchestrationRequestStatus {
    completedDate: Date;
    completedStepCount: number;
    createdDate: Date;
    properties: PropertyPair[];
    requestId: string;
    servicingJobId: string;
    startDate: Date;
    status: ServicingOrchestrationStatus;
    statusMessage: string;
    totalStepCount: number;
}
export enum ServicingOrchestrationStatus {
    Created = 0,
    Queued = 1,
    Running = 2,
    Completed = 3,
    Failed = 4
}
export var TypeInfo: {
    ServicingOrchestrationRequestStatus: any;
    ServicingOrchestrationStatus: {
        enumValues: {
            "created": number;
            "queued": number;
            "running": number;
            "completed": number;
            "failed": number;
        };
    };
};
}
declare module "VSS/SDK/Services/Dialogs" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Dialogs = require("VSS/Controls/Dialogs");
/**
* Class which manages showing dialogs in the parent frame
* @serviceId "vss.dialogs"
*/
export class HostDialogService implements IHostDialogService {
    /**
    * Open a modal dialog in the host frame which will get its content from a contributed control.
    *
    * @param contributionId The id of the control contribution to host in the dialog
    * @param dialogOptions options.title - title of dialog
    * @param contributionConfig Initial configuration to pass to the contribution control.
    * @param postContent Optional data to post to the contribution endpoint. If not specified, a GET request will be performed.
    */
    openDialog(contributionId: string, dialogOptions: IHostDialogOptions, contributionConfig?: Object, postContent?: Object): IPromise<IExternalDialog>;
    /**
     * Open a modal dialog in the host frame which will display the supplied message.
     * @param message the message to display in the dialog. If it's a string, the message is displayed as plain text (no html). For HTML display, pass in a jQuery object.
     * @param methodOptions options affecting the dialog
     * @returns a promise that is resolved when the user accepts the dialog (Ok, Yes, any button with Button.reject===false), or rejected if the user does not (Cancel, No, any button with Button.reject===true).
     */
    openMessageDialog(message: string | JQuery, options?: IOpenMessageDialogOptions): IPromise<IMessageDialogResult>;
    buttons: {
        /**
         * Localized Ok button.
         */
        ok: Dialogs.IMessageDialogButton;
        /**
         * Localized Cancel button.
         */
        cancel: Dialogs.IMessageDialogButton;
        /**
         * Localized Yes button.
         */
        yes: Dialogs.IMessageDialogButton;
        /**
         * Localized No button.
         */
        no: Dialogs.IMessageDialogButton;
    };
}
export interface ExternalDialogOptions extends Dialogs.IModalDialogOptions {
    contributionId: string;
    webContext?: Contracts_Platform.WebContext;
    urlReplacementObject?: any;
    contributionConfig?: any;
    getDialogResult: () => IPromise<any>;
    postContent?: any;
}
/**
* Represents a dialog which hosts an ExternalPart.
*/
export class ExternalDialog extends Dialogs.ModalDialogO<ExternalDialogOptions> implements IExternalDialog {
    private _loadingPromise;
    initializeOptions(options?: any): void;
    initialize(): void;
    /**
    * Gets an object registered in the dialog's contribution control.
    *
    * @param instanceId Id of the instance to get
    * @param contextData Optional data to pass to the extension for it to use when creating the instance
    * @return Promise that is resolved to the instance (a proxy object that talks to the instance)
    */
    getContributionInstance<T>(instanceId: string, contextData?: any): IPromise<T>;
    onOkClick(e?: JQueryEventObject): any;
}
}
declare module "VSS/SDK/Services/ExtensionData" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Contributions_Contracts = require("VSS/Contributions/Contracts");
/**
* Provides a wrapper around the REST client for getting and saving extension setting values
* @serviceId "vss.extensionSettings"
*/
export class ExtensionDataService implements IExtensionDataService {
    private _extensionManagementPromise;
    private _publisherName;
    private _extensionName;
    private static DEFAULT_SCOPE_TYPE;
    private static CURRENT_DEFAULT_SCOPE_VALUE;
    private static USER_SCOPE_TYPE;
    private static CURRENT_USER_SCOPE_VALUE;
    private static SETTINGS_COLLECTION_NAME;
    private static _serviceInstances;
    constructor(publisherName: string, extensionName: string, registrationId: string, webContext: Contracts_Platform.WebContext);
    /**
    * Factory method for creating/getting an instance of the extension settings service.
    *
    * @param extensionId The extension id to get or save settings for
    */
    static getServiceInstance(publisherName: string, extensionName: string, registrationId: string, webContext?: Contracts_Platform.WebContext): ExtensionDataService;
    /**
    * Returns a promise for retrieving a setting at the provided key and scope
    *
    * @param key The key to retrieve a value for
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    getValue<T>(key: string, documentOptions?: IDocumentOptions): IPromise<T>;
    /**
    * Returns a promise for retrieving a list of settings at the provided keys and scope
    *
    * @param keys The keys to retrieve values for
    * @param documentOptions The scope in which the values are stored - default value is collection-wide
    */
    getValues(keys: string[], documentOptions?: IDocumentOptions): IPromise<{
        [key: string]: any;
    }>;
    /**
    * Returns a promise for saving a setting at the provided key and scope
    *
    * @param key The key to save a value for
    * @param value The value to save
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    setValue<T>(key: string, value: T, documentOptions?: IDocumentOptions): IPromise<T>;
    /**
    * Returns a promise for saving a collection of settings at the provided keys and scope
    *
    * @param keyValuePairs A set of key/value pairs to set values for
    * @param documentOptions The scope in which the values are stored - default value is collection-wide
    */
    setValues(keyValuePairs: {
        [key: string]: any;
    }, documentOptions?: IDocumentOptions): IPromise<any[]>;
    /**
    * Returns a promise for getting a document with the provided id in the provided collection
    *
    * @param collectionName The name of the collection where the document lives
    * @param id The id of the document in the collection
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    getDocument(collectionName: string, id: string, documentOptions?: IDocumentOptions): IPromise<any>;
    /**
    * Returns a promise for getting all of the documents in the provided collection
    *
    * @param collectionName The name of the collection where the document lives
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    getDocuments(collectionName: string, documentOptions?: IDocumentOptions): IPromise<any[]>;
    /**
    * Returns a promise for creating a document in the provided collection
    *
    * @param collectionName The name of the collection where the document lives
    * @param doc The document to store
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    createDocument(collectionName: string, doc: any, documentOptions?: IDocumentOptions): IPromise<any>;
    /**
    * Returns a promise for setting a document in the provided collection
    * Creates the document if it does not exist, otherwise updates the existing document with the id provided
    *
    * @param collectionName The name of the collection where the document lives
    * @param doc The document to store
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    setDocument(collectionName: string, doc: any, documentOptions?: IDocumentOptions): IPromise<any>;
    /**
    * Returns a promise for updating a document in the provided collection
    * A document with the id provided must exist
    *
    * @param collectionName The name of the collection where the document lives
    * @param doc The document to store
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    updateDocument(collectionName: string, doc: any, documentOptions?: IDocumentOptions): IPromise<any>;
    /**
    * Returns a promise for deleting the document at the provided scope, collection and id
    *
    * @param collectionName The name of the collection where the document lives
    * @param id The id of the document in the collection
    * @param documentOptions The scope in which the value is stored - default value is account-wide
    */
    deleteDocument(collectionName: string, id: string, documentOptions?: IDocumentOptions): IPromise<void>;
    /**
    * Returns a promise for querying a set of collections
    *
    * @param collections The list of collections to query. Assumes Default Scope Type and Current Scope Value
    */
    queryCollectionNames(collectionNames: string[]): IPromise<Contributions_Contracts.ExtensionDataCollection[]>;
    /**
    * Returns a promise for querying a set of collections
    *
    * @param collections The list of collections to query. Each collection will contain its collectionName, scopeType, and scopeValue
    */
    queryCollections(collections: Contributions_Contracts.ExtensionDataCollection[]): IPromise<Contributions_Contracts.ExtensionDataCollection[]>;
    private _checkDocument;
    private _checkDocumentOptions;
    private _checkForClient;
    private _createDictionaryForArray;
}
}
declare module "VSS/SDK/Services/Navigation" {
import Q = require("q");
/**
* Service which allows interaction with the browser location and navigation of the host frame
* @serviceId "ms.vss-web.navigation-service"
*/
export class HostNavigationService implements IHostNavigationService {
    /**
    * Update the current history entry
    *
    * @param action The "action" state parameter. This is the _a key in the url or "action" in the current state dictionary
    * @param data The history entry's new state key/value pairs
    * @param replaceHistoryEntry If true, replace the current history entry. Otherwise, add a new history entry.
    * @param mergeWithCurrentState If true, the supplied data just modify the existing/current state. If false, they replace all existing key/value pairs.
    * @param windowTitle The new window title. A null or empty value indicates to leave the title unchanged.
    * @param suppressNavigate If true, don't trigger any of the attached navigate event handlers due to this update.
    */
    updateHistoryEntry(action: string, data?: IDictionaryStringTo<any>, replaceHistoryEntry?: boolean, mergeWithCurrentState?: boolean, windowTitle?: string, suppressNavigate?: boolean): void;
    /**
    * Get the current navigation state dictionary. Uses query parameters and hash parameters.
    */
    getCurrentState(): any;
    /**
    * Attach a new navigate handler
    *
    * @param action The action that the handler applies to (or null to listen for all events)
    * @param handler The method called whenever a navigation event occurs with the matching action value
    * @param checkCurrentState If true, immediately invoke the handler if the current state is appropriate (has the matching action value)
    */
    attachNavigate(action: string, handler: IFunctionPPR<any, any, void>, checkCurrentState?: boolean): void;
    /**
    * Remove a navigate handler
    *
    * @param action The action that the handler applies to (or null for global handlers)
    * @param handler The method called whenever a navigation event occurs with the matching action value
    */
    detachNavigate(action: string, handler?: IFunctionPPR<any, any, void>): void;
    /**
    * Add a callback to be invoked each time the hash navigation has changed
    *
    * @param callback Method invoked on each navigation hash change
    */
    onHashChanged(callback: (hash: string) => void): void;
    private _getHash;
    /**
    * Gets the current hash.
    */
    getHash(): Q.Promise<string>;
    /**
     * Reloads the parent frame
     */
    reload(): void;
    /**
    * Sets the provided hash from the hosted content.
    */
    setHash(hash: string): void;
    /**
    * Replace existing hash with the provided hash from the hosted content.
    */
    replaceHash(hash: string): void;
    /**
    * Update the host document's title (appears as the browser tab title).
    *
    * @param title The new title of the window
    */
    setWindowTitle(title: string): void;
    /**
     * Open a new window to the specified url
     *
     * @param url Url of the new window
     * @param features Comma-separated list of features/specs sent as the 3rd parameter to window.open. For example: "height=400,width=400".
     */
    openNewWindow(url: string, features: string): void;
    /**
     * Navigate the parent page to the specified url
     *
     * @param url Url to navigate to
     */
    navigate(url: string): void;
}
}
declare module "VSS/Search" {
export class SearchCore<T> {
    private _strategy;
    private _adapter;
    /**
     * The search core, allows users to perform searches on data using a custom strategy.
     *
     * @param strategy The search strategy to use.
     * @param adapter The search adapter to use.
     */
    constructor(strategy: SearchStrategy<T>, adapter: SearchAdapter<T>);
    /**
     * Add items to the search strategy
     *
     * @param items Items to add
     */
    addItems(items: SearchableObject<T>[]): void;
    /**
     * Performs a search using the Indexer and then runs the adapter's resultHandler on the results
     *
     * @param query Query to run search on
     */
    beginSearch(query: string): T[];
    /**
     * Returns the search strategy currently being used.
     *
     * @return The strategy in use
     */
    getStrategy(): SearchStrategy<T>;
    /**
     * Clears the stored items in the strategy
     */
    clearStrategyStore(): void;
}
export interface ISearchStrategyOptions<T> {
    specialCharacters?: string[];
    delimiter?: string | RegExp;
    comparer?: IComparer<T>;
}
export class SearchStrategy<T> {
    /**
     * Tokenizes the searchText into separate words using a regex. Empty terms ("") will not be returned.
     *
     * @param searchText The searchText to split up.
     * @param delimiter The string or regex delimiter to use to split up the search terms
     * @return An array of strings, the separate words.
     */
    static getTerms(searchText: string[], delimiter?: string | RegExp): string[];
    protected _options: ISearchStrategyOptions<T>;
    private _specialCharactersHashSet;
    /**
     * Abstract Class to inherit from in order to implement the methods needed to store items and search on them.
     */
    constructor(options?: ISearchStrategyOptions<T>);
    private _buildSpecialCharacterHashSet;
    _getTerms(searchTerms: string[]): string[];
    /**
     *     Stores items and terms for each item in order to later retrieve
     *     and search upon.
     *
     * @param searchableObjects SearchableObjects to add
     */
    processItems(searchableObjects: SearchableObject<T>[]): void;
    /**
     * Clears the items stored in the strategy.
     */
    clearStrategyStore(): void;
    /**
     *     Searches the item store for the query given to it. Returns an
     *     array of documents representing the documents which match the query.
     *
     * @param query The query to search for
     * @return The list of items which match the query
     */
    search(query: string): T[];
    /**
     * Checks whether data exists in the search strategy
     *
     * @return True if data exists in the strategy, false if it doesn't.
     */
    dataExists(): boolean;
    /**
     * Return the total count of item indexed.
     */
    getIndexedItemsCount(): number;
    /**
     * Return the total size of the indexed store.
     */
    getIndexTotalSize(): number;
}
export class IndexedSearchStrategy<T> extends SearchStrategy<T> {
    private _searchStore;
    private _dataExists;
    private _indexedItems;
    constructor(store?: IndexedSearchStore<T>, options?: ISearchStrategyOptions<T>);
    getIndexTotalSize(): number;
    /**
     * Clears the items stored in the strategy.
     */
    clearStrategyStore(): void;
    /**
     * Return the total count of item indexed.
     */
    getIndexedItemsCount(): number;
    /**
     * Processes all SearchableObjects and adds them to the index
     *
     * @param searchableObjects SearchableObjects to add
     */
    processItems(searchableObjects: SearchableObject<T>[]): void;
    /**
     * Performs a search using the Indexer and then runs the resultHandler on the results.
     *
     * @param query Query to run search on
     * @return The search results
     */
    search(query: string): T[];
    /**
     * Checks whether data exists in the search strategy
     *
     * @return True if data exists in the strategy, false if it doesn't.
     */
    dataExists(): boolean;
}
export interface IndexedSearchStoreOptions<T> {
    delimiter?: string | RegExp;
    comparer?: IComparer<T>;
}
export class IndexedSearchStore<T> {
    protected _options: IndexedSearchStoreOptions<T>;
    protected _comparer: IComparer<T>;
    /**
     *  Abstract function allowing for additional stores for an IndexedSearchStrategy
     */
    constructor(options?: IndexedSearchStoreOptions<T>);
    /**
     * Runs a query on the index.
     *
     * @param query The query to run.
     * @return An array of items, representing the results.
     */
    search(query: string): T[];
    /**
     * Adds an item to the index, under its token and its subparts.
     *
     * @param item The item to add to the index.
     * @param tokens The tokens to add the item under.
     * @returns true if the item was added to the index, false if it was already in the index
     */
    addToIndex(item: T, tokens: string[]): boolean;
    /**
     * Clears the items stored in the strategy.
     */
    clearStrategyStore(): void;
    /**
     * totalsize of the index store
     */
    getStoreTotalSize(): number;
}
export class TrieStore<T> extends IndexedSearchStore<T> {
    private _trie;
    constructor(options?: IndexedSearchStoreOptions<T>);
    search(query: string): T[];
    /**
     * Adds an item to the index, under its token and its subparts.
     *
     * @param item The item to add to the index.
     * @param tokens The tokens to add the item under.
     * @returns true if the item was added to the index, false if it was already in the index
     */
    addToIndex(item: T, tokens: string[]): boolean;
    clearStrategyStore(): void;
    getStoreTotalSize(): number;
}
export class InvertedIndexStore<T> extends IndexedSearchStore<T> {
    private _index;
    private _tokenCache;
    constructor(options?: IndexedSearchStoreOptions<T>);
    /**
     * Runs a query on the index.
     *
     * @param query The query to run.
     * @return An array of items, representing the results.
     */
    search(query: string): T[];
    /**
     * Adds an item to the index, under its token and its subparts.
     *
     * @param item The item to add to the index.
     * @param tokens The tokens to add the item under.
     * @returns true if the item was added to the index, false if it was already in the index
     */
    addToIndex(item: T, tokens: string[]): boolean;
    /**
     * Clears the items stored in the strategy.
     */
    clearStrategyStore(): void;
    /**
     * Adds a item to the index, under a single key's location.
     *
     * @param item The item to add.
     * @param key The key to add the item under
     * @returns true if the item was added to the index, false if it was already in the index under the given key
     */
    private _addItemToIndex;
}
export class SearchAdapter<T> {
    /**
     * Abstract Class to inherit from in order to implement the UI methods for search.
     */
    constructor();
    /**
     * Adds additional items to the search strategy
     *
     * @param addItemsCallback The function which adds items to the search strategy.
     * @param searchCallback The function which searches the newly updated strategy.
     */
    addMoreItems(addItemsCallback: (items: SearchableObject<T>[]) => void, searchCallback: () => void): void;
    /**
     * Creates SearchableObjects for all available work items
     *
     * @return An array of SearchableObjects.
     */
    createSearchableObjects(): SearchableObject<T>[];
    /**
     *     Handles the results in the UI by filtering through all available items to the ones
     *     provided in the results array.
     *
     * @param results An array of items
     * @param finished Represents whether or not the search is finished
     * @param query search query
     */
    handleResults(results: T[], finished: boolean, query?: string): void;
    /**
     *     Handles an error being thrown in the search process.
     *
     * @param message Specific error message if provided.
     */
    handleError(message: string): void;
    /**
     *     Handles the search results being cleared and the view resetting to normal.
     */
    handleClear(): void;
    /**
     *     Returns whether or not there is more data to be loaded.
     *
     * @return True if no more data needs to be loaded, false otherwise
     */
    isDataSetComplete(): boolean;
}
export class SearchableObject<T> {
    item: T;
    terms: string[];
    /**
     * Represents a single item to be placed in the index.
     *
     * @param item The item to be added
     * @param terms The terms associated to the item.
     */
    constructor(item: T, terms: string[]);
    /**
     * Set the terms for this item
     *
     * @param terms The new terms
     */
    setTerms(terms: string[]): void;
    /**
     * Add a term to the item
     *
     * @param term The additional term
     */
    addTerm(term: string): void;
}
/**
 * Return the unique (and sorted) elements of an array.
 * @param data The array to sort and filter down to unique items
 * @param comparer Comparer for objects of type T. If T is a primitive type, then the comparer can be null/undefined
 */
export function fastUnique<T>(data: T[], comparer?: IComparer<T>): T[];
}
declare module "VSS/SecurityRoles/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\securityroles\client\clientgeneratorconfigs\genclient.json
 */
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
/**
 * Access definition for a RoleAssignment.
 */
export enum RoleAccess {
    /**
     * Access has been explicitly set.
     */
    Assigned = 1,
    /**
     * Access has been inherited from a higher scope.
     */
    Inherited = 2
}
export interface RoleAssignment {
    /**
     * Designates the role as explicitly assigned or inherited.
     */
    access: RoleAccess;
    /**
     * User friendly description of access assignment.
     */
    accessDisplayName: string;
    /**
     * The user to whom the role is assigned.
     */
    identity: VSS_Common_Contracts.IdentityRef;
    /**
     * The role assigned to the user.
     */
    role: SecurityRole;
}
export interface SecurityRole {
    /**
     * Permissions the role is allowed.
     */
    allowPermissions: number;
    /**
     * Permissions the role is denied.
     */
    denyPermissions: number;
    /**
     * Description of user access defined by the role
     */
    description: string;
    /**
     * User friendly name of the role.
     */
    displayName: string;
    /**
     * Globally unique identifier for the role.
     */
    identifier: string;
    /**
     * Unique name of the role in the scope.
     */
    name: string;
    /**
     * Returns the id of the ParentScope.
     */
    scope: string;
}
export interface UserRoleAssignmentRef {
    /**
     * The name of the role assigned.
     */
    roleName: string;
    /**
     * Identifier of the user given the role assignment.
     */
    uniqueName: string;
    /**
     * Unique id of the user given the role assignment.
     */
    userId: string;
}
export var TypeInfo: {
    RoleAccess: {
        enumValues: {
            "assigned": number;
            "inherited": number;
        };
    };
    RoleAssignment: any;
};
}
declare module "VSS/SecurityRoles/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\securityroles\client\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/SecurityRoles/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2_2To5 extends VSS_WebApi.VssHttpClient {
    protected roleassignmentsApiVersion: string;
    protected roledefinitionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} scopeId
     * @return IPromise<Contracts.SecurityRole[]>
     */
    getRoleDefinitions(scopeId: string): IPromise<Contracts.SecurityRole[]>;
    /**
     * [Preview API]
     *
     * @param {Contracts.UserRoleAssignmentRef[]} roleAssignments
     * @param {string} scopeId
     * @param {string} resourceId
     * @param {boolean} limitToCallerIdentityDomain
     * @return IPromise<Contracts.RoleAssignment[]>
     */
    setRoleAssignments(roleAssignments: Contracts.UserRoleAssignmentRef[], scopeId: string, resourceId: string, limitToCallerIdentityDomain?: boolean): IPromise<Contracts.RoleAssignment[]>;
    /**
     * [Preview API]
     *
     * @param {Contracts.UserRoleAssignmentRef} roleAssignment
     * @param {string} scopeId
     * @param {string} resourceId
     * @param {string} identityId
     * @return IPromise<Contracts.RoleAssignment>
     */
    setRoleAssignment(roleAssignment: Contracts.UserRoleAssignmentRef, scopeId: string, resourceId: string, identityId: string): IPromise<Contracts.RoleAssignment>;
    /**
     * [Preview API]
     *
     * @param {string[]} identityIds
     * @param {string} scopeId
     * @param {string} resourceId
     * @return IPromise<void>
     */
    removeRoleAssignments(identityIds: string[], scopeId: string, resourceId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} scopeId
     * @param {string} resourceId
     * @param {string} identityId
     * @return IPromise<void>
     */
    removeRoleAssignment(scopeId: string, resourceId: string, identityId: string): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {string} scopeId
     * @param {string} resourceId
     * @return IPromise<Contracts.RoleAssignment[]>
     */
    getRoleAssignments(scopeId: string, resourceId: string): IPromise<Contracts.RoleAssignment[]>;
    /**
     * [Preview API]
     *
     * @param {string} scopeId
     * @param {string} resourceId
     * @param {boolean} inheritPermissions
     * @return IPromise<void>
     */
    changeInheritance(scopeId: string, resourceId: string, inheritPermissions: boolean): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient5 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient4_1 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient4 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient3_2 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient3_1 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient2_3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityRolesHttpClient2_2 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class SecurityRolesHttpClient extends SecurityRolesHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return SecurityRolesHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): SecurityRolesHttpClient4_1;
}
declare module "VSS/Security/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\security.genclient.json
 */
import VSS_Identities_Contracts = require("VSS/Identities/Contracts");
/**
 * Class for encapsulating the allowed and denied permissions for a given IdentityDescriptor.
 */
export interface AccessControlEntry {
    /**
     * The set of permission bits that represent the actions that the associated descriptor is allowed to perform.
     */
    allow: number;
    /**
     * The set of permission bits that represent the actions that the associated descriptor is not allowed to perform.
     */
    deny: number;
    /**
     * The descriptor for the user this AccessControlEntry applies to.
     */
    descriptor: VSS_Identities_Contracts.IdentityDescriptor;
    /**
     * This value, when set, reports the inherited and effective information for the associated descriptor. This value is only set on AccessControlEntries returned by the QueryAccessControlList(s) call when its includeExtendedInfo parameter is set to true.
     */
    extendedInfo: AceExtendedInformation;
}
/**
 * The AccessControlList class is meant to associate a set of AccessControlEntries with a security token and its inheritance settings.
 */
export interface AccessControlList {
    /**
     * Storage of permissions keyed on the identity the permission is for.
     */
    acesDictionary: {
        [key: string]: AccessControlEntry;
    };
    /**
     * True if this ACL holds ACEs that have extended information.
     */
    includeExtendedInfo: boolean;
    /**
     * True if the given token inherits permissions from parents.
     */
    inheritPermissions: boolean;
    /**
     * The token that this AccessControlList is for.
     */
    token: string;
}
export interface AccessControlListsCollection {
}
/**
 * Holds the inherited and effective permission information for a given AccessControlEntry.
 */
export interface AceExtendedInformation {
    /**
     * This is the combination of all of the explicit and inherited permissions for this identity on this token.  These are the permissions used when determining if a given user has permission to perform an action.
     */
    effectiveAllow: number;
    /**
     * This is the combination of all of the explicit and inherited permissions for this identity on this token.  These are the permissions used when determining if a given user has permission to perform an action.
     */
    effectiveDeny: number;
    /**
     * These are the permissions that are inherited for this identity on this token.  If the token does not inherit permissions this will be 0.  Note that any permissions that have been explicitly set on this token for this identity, or any groups that this identity is a part of, are not included here.
     */
    inheritedAllow: number;
    /**
     * These are the permissions that are inherited for this identity on this token.  If the token does not inherit permissions this will be 0.  Note that any permissions that have been explicitly set on this token for this identity, or any groups that this identity is a part of, are not included here.
     */
    inheritedDeny: number;
}
export interface ActionDefinition {
    /**
     * The bit mask integer for this action. Must be a power of 2.
     */
    bit: number;
    /**
     * The localized display name for this action.
     */
    displayName: string;
    /**
     * The non-localized name for this action.
     */
    name: string;
    /**
     * The namespace that this action belongs to.  This will only be used for reading from the database.
     */
    namespaceId: string;
}
/**
 * Represents an evaluated permission.
 */
export interface PermissionEvaluation {
    /**
     * Permission bit for this evaluated permission.
     */
    permissions: number;
    /**
     * Security namespace identifier for this evaluated permission.
     */
    securityNamespaceId: string;
    /**
     * Security namespace-specific token for this evaluated permission.
     */
    token: string;
    /**
     * Permission evaluation value.
     */
    value: boolean;
}
/**
 * Represents a set of evaluated permissions.
 */
export interface PermissionEvaluationBatch {
    /**
     * True if members of the Administrators group should always pass the security check.
     */
    alwaysAllowAdministrators: boolean;
    /**
     * Array of permission evaluations to evaluate.
     */
    evaluations: PermissionEvaluation[];
}
/**
 * Class for describing the details of a TeamFoundationSecurityNamespace.
 */
export interface SecurityNamespaceDescription {
    /**
     * The list of actions that this Security Namespace is responsible for securing.
     */
    actions: ActionDefinition[];
    /**
     * This is the dataspace category that describes where the security information for this SecurityNamespace should be stored.
     */
    dataspaceCategory: string;
    /**
     * This localized name for this namespace.
     */
    displayName: string;
    /**
     * If the security tokens this namespace will be operating on need to be split on certain character lengths to determine its elements, that length should be specified here. If not, this value will be -1.
     */
    elementLength: number;
    /**
     * This is the type of the extension that should be loaded from the plugins directory for extending this security namespace.
     */
    extensionType: string;
    /**
     * If true, the security namespace is remotable, allowing another service to proxy the namespace.
     */
    isRemotable: boolean;
    /**
     * This non-localized for this namespace.
     */
    name: string;
    /**
     * The unique identifier for this namespace.
     */
    namespaceId: string;
    /**
     * The permission bits needed by a user in order to read security data on the Security Namespace.
     */
    readPermission: number;
    /**
     * If the security tokens this namespace will be operating on need to be split on certain characters to determine its elements that character should be specified here. If not, this value will be the null character.
     */
    separatorValue: string;
    /**
     * Used to send information about the structure of the security namespace over the web service.
     */
    structureValue: number;
    /**
     * The bits reserved by system store
     */
    systemBitMask: number;
    /**
     * If true, the security service will expect an ISecurityDataspaceTokenTranslator plugin to exist for this namespace
     */
    useTokenTranslator: boolean;
    /**
     * The permission bits needed by a user in order to modify security data on the Security Namespace.
     */
    writePermission: number;
}
}
declare module "VSS/Security/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\security.genclient.json
 */
import Contracts = require("VSS/Security/Contracts");
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected accessControlEntriesApiVersion: string;
    protected accessControlListsApiVersion: string;
    protected permissionsApiVersion: string;
    protected securityNamespacesApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * @param {string} securityNamespaceId
     * @param {boolean} localOnly
     * @return IPromise<Contracts.SecurityNamespaceDescription[]>
     */
    querySecurityNamespaces(securityNamespaceId: string, localOnly?: boolean): IPromise<Contracts.SecurityNamespaceDescription[]>;
    /**
     * Removes the specified permissions from the caller or specified user or group.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {string} descriptor - Identity descriptor of the user to remove permissions for.
     * @param {number} permissions - Permissions to remove.
     * @param {string} token - Security token to remove permissions for.
     * @return IPromise<Contracts.AccessControlEntry>
     */
    removePermission(securityNamespaceId: string, descriptor: string, permissions?: number, token?: string): IPromise<Contracts.AccessControlEntry>;
    /**
     * Create or update one or more access control lists. All data that currently exists for the ACLs supplied will be overwritten.
     *
     * @param {VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.AccessControlListsCollection>} accessControlLists
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @return IPromise<void>
     */
    setAccessControlLists(accessControlLists: VSS_Common_Contracts.VssJsonCollectionWrapperV<Contracts.AccessControlListsCollection>, securityNamespaceId: string): IPromise<void>;
    /**
     * Remove access control lists under the specfied security namespace.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {string} tokens - One or more comma-separated security tokens
     * @param {boolean} recurse - If true and this is a hierarchical namespace, also remove child ACLs of the specified tokens.
     * @return IPromise<boolean>
     */
    removeAccessControlLists(securityNamespaceId: string, tokens?: string, recurse?: boolean): IPromise<boolean>;
    /**
     * Return a list of access control lists for the specified security namespace and token. All ACLs in the security namespace will be retrieved if no optional parameters are provided.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {string} token - Security token
     * @param {string} descriptors - An optional filter string containing a list of identity descriptors separated by ',' whose ACEs should be retrieved. If this is left null, entire ACLs will be returned.
     * @param {boolean} includeExtendedInfo - If true, populate the extended information properties for the access control entries contained in the returned lists.
     * @param {boolean} recurse - If true and this is a hierarchical namespace, return child ACLs of the specified token.
     * @return IPromise<Contracts.AccessControlList[]>
     */
    queryAccessControlLists(securityNamespaceId: string, token?: string, descriptors?: string, includeExtendedInfo?: boolean, recurse?: boolean): IPromise<Contracts.AccessControlList[]>;
    /**
     * Add or update ACEs in the ACL for the provided token. In the case of a collision (by identity descriptor) with an existing ACE in the ACL, the "merge" parameter determines the behavior. If set, the existing ACE has its allow and deny merged with the incoming ACE's allow and deny. If unset, the existing ACE is displaced.
     *
     * @param {any} container
     * @param {string} securityNamespaceId
     * @return IPromise<Contracts.AccessControlEntry[]>
     */
    setAccessControlEntries(container: any, securityNamespaceId: string): IPromise<Contracts.AccessControlEntry[]>;
    /**
     * Remove the specified ACEs from the ACL belonging to the specified token.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {string} token
     * @param {string} descriptors - String containing a list of identity descriptors separated by ',' whose entries should be removed.
     * @return IPromise<boolean>
     */
    removeAccessControlEntries(securityNamespaceId: string, token?: string, descriptors?: string): IPromise<boolean>;
}
export class CommonMethods2_2To5 extends CommonMethods2To5 {
    protected permissionsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * Evaluates whether the caller has the specified permissions on the specified set of security tokens.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {number} permissions - Permissions to evaluate.
     * @param {string} tokens - One or more security tokens to evaluate.
     * @param {boolean} alwaysAllowAdministrators - If true and if the caller is an administrator, always return true.
     * @param {string} delimiter - Optional security token separator. Defaults to ",".
     * @return IPromise<boolean[]>
     */
    hasPermissions(securityNamespaceId: string, permissions?: number, tokens?: string, alwaysAllowAdministrators?: boolean, delimiter?: string): IPromise<boolean[]>;
}
export class CommonMethods3To5 extends CommonMethods2_2To5 {
    protected permissionEvaluationBatchApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * Evaluates multiple permissions for the calling user.  Note: This method does not aggregate the results, nor does it short-circuit if one of the permissions evaluates to false.
     *
     * @param {Contracts.PermissionEvaluationBatch} evalBatch - The set of evaluation requests.
     * @return IPromise<Contracts.PermissionEvaluationBatch>
     */
    hasPermissionsBatch(evalBatch: Contracts.PermissionEvaluationBatch): IPromise<Contracts.PermissionEvaluationBatch>;
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient5 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient4_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient4 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient3_2 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient3_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient2_3 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SecurityHttpClient2_2 extends CommonMethods2_2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class SecurityHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * Evaluates whether the caller has the specified permissions.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {number} permissions - Permissions to evaluate.
     * @param {string} token - Security token to evaluate.
     * @param {boolean} alwaysAllowAdministrators - If true and if the caller is an administrator, always return true.
     * @return IPromise<boolean>
     */
    hasPermission(securityNamespaceId: string, permissions?: number, token?: string, alwaysAllowAdministrators?: boolean): IPromise<boolean>;
}
export class SecurityHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * Evaluates whether the caller has the specified permissions.
     *
     * @param {string} securityNamespaceId - Security namespace identifier.
     * @param {number} permissions - Permissions to evaluate.
     * @param {string} token - Security token to evaluate.
     * @param {boolean} alwaysAllowAdministrators - If true and if the caller is an administrator, always return true.
     * @return IPromise<boolean>
     */
    hasPermission(securityNamespaceId: string, permissions?: number, token?: string, alwaysAllowAdministrators?: boolean): IPromise<boolean>;
}
export class SecurityHttpClient extends SecurityHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return SecurityHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): SecurityHttpClient4_1;
}
declare module "VSS/Security/Services" {
import Service = require("VSS/Service");
/**
* Service to manage permission availability data.
*/
export class SecurityService extends Service.VssService {
    hasPermission(securityNamespaceId: string, securityToken: string, requestedPermission: number): boolean;
    checkPermission(securityNamespaceId: string, securityToken: string, requestedPermission: number): void;
    isPermissionIncluded(securityNamespaceId: string, securityToken: string): boolean;
    private handleMissingState;
}
}
declare module "VSS/Serialization" {
/**
 * Metadata for deserializing an enum field on a contract/type
 */
export interface ContractEnumMetadata {
    enumValues?: {
        [name: string]: number;
    };
}
/**
 * Metadata for deserializing a particular field on a contract/type
 */
export interface ContractFieldMetadata {
    isArray?: boolean;
    isDate?: boolean;
    enumType?: ContractEnumMetadata;
    typeInfo?: ContractMetadata;
    isDictionary?: boolean;
    dictionaryKeyIsDate?: boolean;
    dictionaryValueIsDate?: boolean;
    dictionaryKeyEnumType?: ContractEnumMetadata;
    dictionaryValueEnumType?: ContractEnumMetadata;
    dictionaryValueTypeInfo?: ContractMetadata;
    dictionaryValueFieldInfo?: ContractFieldMetadata;
}
/**
 * Metadata required for deserializing a given type
 */
export type ContractMetadata = ContractFieldsMetadata & ContractEnumMetadata;
export interface ContractFieldsMetadata {
    fields?: {
        [fieldName: string]: ContractFieldMetadata;
    };
}
export interface ContractEnumMetadata {
    enumValues?: {
        [enumName: string]: number;
    };
}
/**
 * Module for handling serialization and deserialization of data contracts
 * (contracts sent from the server using the VSTS default REST api serialization settings)
 */
export module ContractSerializer {
    /**
     * Process a contract in its raw form (e.g. date fields are Dates, and Enums are numbers) and
     * return a pure JSON object that can be posted to REST endpoint.
     *
     * @param data The object to serialize
     * @param contractMetadata The type info/metadata for the contract type being serialized
     * @param preserveOriginal If true, don't modify the original object. False modifies the original object (the return value points to the data argument).
     */
    function serialize(data: any, contractMetadata: ContractMetadata, preserveOriginal?: boolean): any;
    /**
     * Process a pure JSON object (e.g. that came from a REST call) and transform it into a JS object
     * where date strings are converted to Date objects and enum values are converted from strings into
     * their numerical value.
     *
     * @param data The object to deserialize
     * @param contractMetadata The type info/metadata for the contract type being deserialize
     * @param preserveOriginal If true, don't modify the original object. False modifies the original object (the return value points to the data argument).
     * @param unwrapWrappedCollections If true check for wrapped arrays (REST apis will not return arrays directly as the root result but will instead wrap them in a { values: [], count: 0 } object.
     */
    function deserialize(data: any, contractMetadata: ContractMetadata, preserveOriginal?: boolean, unwrapWrappedCollections?: boolean): any;
}
/**
* Deserialize the JSON island data that is stored in the given element
*
* @param $element JQuery element containing the JSON to deserialize
* @param contractMetadata The type info/metadata for the contract type being deserialize
* @param removeElement If true remove the element from the DOM after deserializing the content
*/
export function deserializeJsonIsland<T>($element: JQuery, contractMetadata: ContractMetadata, removeElement?: boolean): T;
export function deserializeVssJsonObject<T>(text: string): T;
}
declare module "VSS/Service" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import WebApi_RestClient = require("VSS/WebApi/RestClient");
/**
* A connection to a particular TeamFoundation host
*/
export class VssConnection {
    private static _connectionsCache;
    private _webContext;
    private _hostType;
    private _hostContext;
    private _services;
    private _httpClients;
    /**
    * Get a (cached) VssConnection object of the given type
    *
    * @param webContext Specific web context to get the connection for
    * @param hostType Host type to scope the connection to
    */
    static getConnection(webContext?: Contracts_Platform.WebContext, hostType?: Contracts_Platform.ContextHostType): VssConnection;
    /**
    * Get the host context information given a web context and the desired host type
    */
    private static getHostContext;
    /**
    * Create a new connection object
    * @param webContext Specific web context to get the connection for
    * @param hostType Host type to scope the connection to
    */
    constructor(webContext: Contracts_Platform.WebContext, hostType?: Contracts_Platform.ContextHostType);
    getWebContext(): Contracts_Platform.WebContext;
    /**
    * Gets the host information that this service is scoped to
    */
    getHostContext(): Contracts_Platform.HostContext;
    /**
    * Gets the host type that this service is scoped to
    */
    getHostType(): Contracts_Platform.ContextHostType;
    /**
    * Gets the service host url for this connection. This is typically
    * a relative url, but it can be absolute in child iframes (e.g. extensions)
    */
    getHostUrl(): string;
    /**
    * Gets a (potentially-cached) service associated with this connection
    */
    getService<T extends VssService>(serviceType: {
        new (): T;
    }, useCached?: boolean): T;
    /**
     * Returns a new or a cached instance of an httpClient for the given type.
     *
     * @param httpClientType Type of requeested httpClient.
     * @param serviceInstanceId Unique id of the service to scope the http client to
     * @return http client of the specified type (clients are cached for this connection)
     */
    getHttpClient<T extends WebApi_RestClient.VssHttpClient>(httpClientType: {
        new (url: string, options?: WebApi_RestClient.IVssHttpClientOptions): T;
    }, serviceInstanceId?: string, authTokenManager?: IAuthTokenManager<any>, clientOptions?: WebApi_RestClient.IVssHttpClientOptions): T;
    /**
    * Get the url for the given service
    *
    * @param serviceInstanceId Unique identifier of the VSTS service to get the url for
    * @param hostType The type of host to get the url for
    * @param faultInMissingHost If true, attempt to fault in the target host if the location's service definition doesn't already exist.
    */
    beginGetServiceUrl(serviceInstanceId: string, hostType?: Contracts_Platform.ContextHostType, faultInMissingHost?: boolean): IPromise<string>;
}
/**
* A client service which can be cached per TFS connection.
*/
export class VssService {
    private _connection;
    /**
    * Gets the relative location for the service's connection
    */
    getConnection(): VssConnection;
    getWebContext(): Contracts_Platform.WebContext;
    /**
    * Sets the VssConnection to use for this service
    * @param connection VssConnection used by this service
    */
    initializeConnection(connection: VssConnection): void;
}
export interface ILocalService {
}
/**
 * Get a local service.
 * @param serviceType Type of the local service to get.
 * @param webContext optional web context.
 * @returns {ILocalService}
 */
export function getLocalService<T extends ILocalService>(serviceType: {
    new (): T;
}, useCached?: boolean, webContext?: Contracts_Platform.WebContext): T;
/**
* Get a collection-level service
* @param serviceType Type of service to get
* @param webContext optional web context to use for the connection
* @return Collection-level service
*/
export function getCollectionService<T extends VssService>(serviceType: {
    new (): T;
}, webContext?: Contracts_Platform.WebContext): T;
/**
* Get an application-level (Account) service
* @param serviceType Type of service to get
* @param webContext optional web context to use for the connection
* @return Application-level service
*/
export function getApplicationService<T extends VssService>(serviceType: {
    new (): T;
}, webContext?: Contracts_Platform.WebContext): T;
/**
* Get a service for the web context's default host type
* @param serviceType Type of service to get
* @param webContext optional web context to use for the connection
* @return Collection-level or Application-level service
*/
export function getService<T extends VssService>(serviceType: {
    new (): T;
}, webContext?: Contracts_Platform.WebContext): T;
/**
* Get a collection-level HTTP client
* @param httpClientType Type of http client to get
* @param webContext optional web context to use for the connection
* @return collection-level client
*/
export function getCollectionClient<T extends WebApi_RestClient.VssHttpClient>(httpClientType: {
    new (url: string, options?: WebApi_RestClient.IVssHttpClientOptions): T;
}, webContext?: Contracts_Platform.WebContext, serviceInstanceId?: string, authTokenManager?: IAuthTokenManager<any>, options?: WebApi_RestClient.IVssHttpClientOptions): T;
/**
* Get an organization-level (Organization) HTTP client
* @param httpClientType Type of http client to get
* @param webContext optional web context to use for the connection
* @return application-level client
*/
export function getApplicationClient<T extends WebApi_RestClient.VssHttpClient>(httpClientType: {
    new (url: string, options?: WebApi_RestClient.IVssHttpClientOptions): T;
}, webContext?: Contracts_Platform.WebContext, serviceInstanceId?: string, authTokenManager?: IAuthTokenManager<any>, options?: WebApi_RestClient.IVssHttpClientOptions): T;
/**
* Get an http client for the web context's default host type
* @param serviceType Type of http client to get
* @param webContext optional web context to use for the connection
* @return Collection-level or Application-level http client
*/
export function getClient<T extends WebApi_RestClient.VssHttpClient>(httpClientType: {
    new (url: string, options?: WebApi_RestClient.IVssHttpClientOptions): T;
}, webContext?: Contracts_Platform.WebContext, serviceInstanceId?: string, authTokenManager?: IAuthTokenManager<any>, options?: WebApi_RestClient.IVssHttpClientOptions): T;
}
declare module "VSS/Settings" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
import Service = require("VSS/Service");
/**
* Scope at which the local user setting applies
*/
export enum LocalSettingsScope {
    /**
    * Global (account-specific) settings for a user
    */
    Global = 0,
    /**
    * Project-specific settings for a user
    */
    Project = 1,
    /**
    * Team-specific settings for a user
    */
    Team = 2
}
/**
* Service for reading and writing to local storage
*/
export class LocalSettingsService implements Service.ILocalService {
    private static GLOBAL_SETTING_KEY;
    private static PROJECT_SETTING_KEY;
    private static TEAM_SETTING_KEY;
    private _webContext;
    constructor(webContext?: Contracts_Platform.WebContext);
    /**
     * Write a settings value to browser local storage
     *
     * @param key Key for the setting to be written. This key will be prefixed with a scope.
     * @param value Value for the setting to be written
     * @param scope Scope for the setting to apply to. This will determine the prefix to use at the beginning of the setting key.
     */
    write(key: string, value: any, scope?: LocalSettingsScope): void;
    /**
     * Read a setting from browser local storage.
     *
     * @param key Key for the setting to be written. This key will be prefixed with a scope.
     * @param defaultValue The value to return in case no setting exists
     * @param scope Scope for the setting to apply to. This will determine the prefix to use at the beginning of the setting key.
     * @return Value read from the setting or undefined if no value stored
     */
    read<T>(key: string, defaultValue?: T, scope?: LocalSettingsScope): T;
    private _getScopedKey;
}
}
declare module "VSS/Settings/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3To5 extends VSS_WebApi.VssHttpClient {
    protected entriesApiVersion: string;
    protected entriesApiVersion_cd006711: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API] Set the specified entries for the given named scope
     *
     * @param {{ [key: string] : any; }} entries - The entries to set
     * @param {string} userScope - User-Scope at which to set the values. Should be "me" for the current user or "host" for all users.
     * @param {string} scopeName - Scope at which to set the settings on (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @return IPromise<void>
     */
    setEntriesForScope(entries: {
        [key: string]: any;
    }, userScope: string, scopeName: string, scopeValue: string): IPromise<void>;
    /**
     * [Preview API] Remove the entry or entries under the specified path
     *
     * @param {string} userScope - User-Scope at which to remove the value. Should be "me" for the current user or "host" for all users.
     * @param {string} scopeName - Scope at which to get the setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @param {string} key - Root key of the entry or entries to remove
     * @return IPromise<void>
     */
    removeEntriesForScope(userScope: string, scopeName: string, scopeValue: string, key: string): IPromise<void>;
    /**
     * [Preview API] Get all setting entries for the given named scope
     *
     * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
     * @param {string} scopeName - Scope at which to get the setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @param {string} key - Optional key under which to filter all the entries
     * @return IPromise<{ [key: string] : any; }>
     */
    getEntriesForScope(userScope: string, scopeName: string, scopeValue: string, key?: string): IPromise<{
        [key: string]: any;
    }>;
    /**
     * [Preview API] Set the specified setting entry values for the given user/all-users scope
     *
     * @param {{ [key: string] : any; }} entries - The entries to set
     * @param {string} userScope - User-Scope at which to set the values. Should be "me" for the current user or "host" for all users.
     * @return IPromise<void>
     */
    setEntries(entries: {
        [key: string]: any;
    }, userScope: string): IPromise<void>;
    /**
     * [Preview API] Remove the entry or entries under the specified path
     *
     * @param {string} userScope - User-Scope at which to remove the value. Should be "me" for the current user or "host" for all users.
     * @param {string} key - Root key of the entry or entries to remove
     * @return IPromise<void>
     */
    removeEntries(userScope: string, key: string): IPromise<void>;
    /**
     * [Preview API] Get all setting entries for the given user/all-users scope
     *
     * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
     * @param {string} key - Optional key under which to filter all the entries
     * @return IPromise<{ [key: string] : any; }>
     */
    getEntries(userScope: string, key?: string): IPromise<{
        [key: string]: any;
    }>;
}
/**
 * @exemptedapi
 */
export class SettingsHttpClient5 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SettingsHttpClient4_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SettingsHttpClient4 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SettingsHttpClient3_2 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SettingsHttpClient3_1 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class SettingsHttpClient3 extends CommonMethods3To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class SettingsHttpClient extends SettingsHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return SettingsHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): SettingsHttpClient4_1;
}
declare module "VSS/Settings/Services" {
import { WebContext } from "VSS/Common/Contracts/Platform";
/**
 * Whether settings are applied to the current user or to all users in the host
 */
export const enum SettingsUserScope {
    /**
     * Settings for the current user
     */
    Me = 0,
    /**
     * Shared settings for all users in this host
     */
    Host = 1
}
/**
 * Service for interacting with Settings REST Endpoint which handles anonymous/public users
 * by not calling the server since the server endpoint is not open to public.
 */
export interface ISettingsService {
    /**
     * Synchronous method to get a setting entry from the settings emitted from local data providers. Returns undefined
     * if the value was not present.
     *
     * @param {string} key - Settings key.
     * @param {string} userScope - User-Scope at which to get the value. Should be Me for the current user or Host for all users.
     * @param {string} scopeName - Scope at which to get the setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @return Promise<{ [key: string] : any; }>
     */
    getEntry<T>(key: string, userScope: SettingsUserScope, scopeName?: string, scopeValue?: string): T | undefined;
    /**
     * Get all setting entries by making a REST call if the data was not already included in local data provider data.
     *
     * @param {string} key - Key under which to filter all the entries
     * @param {string} userScope - User-Scope at which to get the value. Should be Me for the current user or Host for all users.
     * @param {string} scopeName - Scope at which to get the setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @return Promise<{ [key: string] : any; }>
     */
    getEntriesAsync(key: string, userScope: SettingsUserScope, scopeName?: string, scopeValue?: string): IPromise<{
        [key: string]: any;
    }>;
    /**
     * Set the specified settings entries
     *
     * @param {{ [key: string] : any; }} entries - The entries to set
     * @param {string} userScope - User-Scope at which to set the values. Should be Me for the current user or Host for all users.
     * @param {string} scopeName - Scope at which to set the settings on (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @return Promise<void>
     */
    setEntries(entries: {
        [key: string]: any;
    }, userScope: SettingsUserScope, scopeName?: string, scopeValue?: string): IPromise<void>;
    /**
     * Remove the entry or entries under the specified path
     *
     * @param {string} key - Root key of the entry or entries to remove
     * @param {string} userScope - User-Scope at which to remove the value. Should be Me for the current user or Host for all users.
     * @param {string} scopeName - Scope at which to get the setting for (e.g. "project" or "team")
     * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
     * @return Promise<void>
     */
    removeEntries(key: string, userScope: SettingsUserScope, scopeName?: string, scopeValue?: string): IPromise<void>;
}
/**
 * Get the settings service for the web context default host type.
 *
 * @param webContext optional web context to use for the connection
 * @return Collection-level or Application-level service
 */
export function getService(webContext?: WebContext): ISettingsService;
}
declare module "VSS/SignalR/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export interface SignalRObject {
    identifier: string;
    version: string;
}
export interface SignalROperation {
    objects: SignalRObject[];
}
}
declare module "VSS/Telemetry/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
export interface CustomerIntelligenceEvent {
    area: string;
    feature: string;
    properties: {
        [key: string]: any;
    };
}
}
declare module "VSS/Telemetry/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Telemetry/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected eventsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {Contracts.CustomerIntelligenceEvent[]} events
     * @return IPromise<void>
     */
    publishEvents(events: Contracts.CustomerIntelligenceEvent[]): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class CustomerIntelligenceHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class CustomerIntelligenceHttpClient extends CustomerIntelligenceHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return CustomerIntelligenceHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): CustomerIntelligenceHttpClient4_1;
}
declare module "VSS/Telemetry/Services" {
/**
 * Event data that can be published
 */
export class TelemetryEventData {
    area: string;
    feature: string;
    properties: {
        [key: string]: any;
    };
    elapsedTime: number;
    serviceInstanceType?: string;
    /**
     * Constructor for CIPublishPropertiesOptions.
     *
     * @param area The Customer Intelligence Area to publish to.
     * @param feature The feature name.
     * @param properties The key:value list of event properties.
     * @param elapsedTime The elapsedTime for the event. Defaults to Date.now() - startTime if startTime is supplied.
     * @param startTime The Date.now() at the start of the event process.
     * @param serviceInstanceType The id of the service instance type to send the telemetry to
     */
    constructor(area: string, feature: string, properties: {
        [key: string]: any;
    }, startTime?: number, elapsedTime?: number, serviceInstanceType?: string);
    /**
     * Create Telemetry event data from a single property
     */
    static fromProperty(area: string, feature: string, property: string, value: any, startTime?: number, elapsedTime?: number): TelemetryEventData;
    /**
     * Create telemetry event data for an explicit service instance type
     */
    static forService(area: string, feature: string, serviceInstanceType: string, properties?: {
        [key: string]: any;
    }): TelemetryEventData;
}
/**
 * Handler that can modify properties of telemetry events before they are sent to the server
 */
export interface ITelemetryEventHandler {
    (event: TelemetryEventData): void;
}
/**
 * Gets all the events published to the service.
 * Intended to be used internally for analysing telemetry data.
 */
export function getPublishedEvents(): TelemetryEventData[];
/**
 * Publish event data to the CustomerIntelligence service and App Insights.
 * (events are queued and sent in delayed batches unless immediate = true is supplied)
 *
 * @param eventData {TelemetryEventData} telemetry event to publish
 * @param immediate {boolean} If true, make ajax calls to publish the event immediately. Otherwise queue the event and send in delayed batches.
 */
export function publishEvent(eventData: TelemetryEventData, immediate?: boolean): void;
/**
 * Flush queued event data to be sent to CustomerIntelligence service and App Insights
 */
export function flush(): IPromise<void>;
/**
 * Register a function to be called each time an event is published
 *
 * @param handler Handler that can modify properties of telemetry events before they are sent to the server
 */
export function addTelemetryEventHandler(handler: ITelemetryEventHandler): void;
/**
 * Unregister a function called each time an event is published
 *
 * @param handler Handler to remove
 */
export function removeTelemetryEventHandler(handler: ITelemetryEventHandler): void;
}
declare module "VSS/Token/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Common_Contracts = require("VSS/WebApi/Contracts");
export interface AccessToken {
    accessId: string;
    authorizationId: string;
    isRefresh: boolean;
    isValid: boolean;
    refreshed: Date;
    refreshToken: VSS_Common_Contracts.JsonWebToken;
    token: VSS_Common_Contracts.JsonWebToken;
    tokenType: string;
    validFrom: Date;
    validTo: Date;
}
export interface AccessTokenResult {
    accessToken: VSS_Common_Contracts.JsonWebToken;
    accessTokenError: TokenError;
    authorizationId: string;
    errorDescription: string;
    hasError: boolean;
    refreshToken: RefreshTokenGrant;
    tokenType: string;
    validTo: Date;
}
export enum AppSessionTokenError {
    None = 0,
    UserIdRequired = 1,
    ClientIdRequired = 2,
    InvalidUserId = 3,
    InvalidUserType = 4,
    AccessDenied = 5,
    FailedToIssueAppSessionToken = 6,
    InvalidClientId = 7,
    AuthorizationIsNotSuccessfull = 8
}
export interface AppSessionTokenResult {
    appSessionToken: string;
    appSessionTokenError: AppSessionTokenError;
    expirationDate: Date;
    hasError: boolean;
}
export interface AppTokenSecretPair {
    /**
     * This class is used while exchanging an app session token with oauth2 user token with API call.
     */
    appToken: string;
    clientSecret: string;
}
export interface AuthorizationGrant {
    grantType: GrantType;
}
export enum CreatedByOptions {
    VstsWebUi = 1,
    NonVstsWebUi = 2,
    All = 3
}
export enum DisplayFilterOptions {
    Active = 1,
    Revoked = 2,
    Expired = 3,
    All = 4
}
export enum GrantType {
    None = 0,
    JwtBearer = 1,
    RefreshToken = 2,
    Implicit = 3,
    ClientCredentials = 4
}
export interface PagedSessionTokens {
    nextRowNumber: number;
    sessionTokens: SessionToken[];
}
export interface RefreshTokenGrant extends AuthorizationGrant {
    jwt: VSS_Common_Contracts.JsonWebToken;
}
export interface SessionToken {
    accessId: string;
    /**
     * This is populated when user requests a compact token. The alternate token value is self describing token.
     */
    alternateToken: string;
    authorizationId: string;
    clientId: string;
    displayName: string;
    hostAuthorizationId: string;
    isPublic: boolean;
    isValid: boolean;
    publicData: string;
    scope: string;
    source: string;
    targetAccounts: string[];
    /**
     * This is computed and not returned in Get queries
     */
    token: string;
    userId: string;
    validFrom: Date;
    validTo: Date;
}
export enum SessionTokenType {
    SelfDescribing = 0,
    Compact = 1
}
export enum SortByOptions {
    DisplayName = 1,
    DisplayDate = 2,
    Status = 3
}
/**
 * Used to transmit an SSH public key in the RemovePublicKey API
 */
export interface SshPublicKey {
    value: string;
}
export enum TokenError {
    None = 0,
    GrantTypeRequired = 1,
    AuthorizationGrantRequired = 2,
    ClientSecretRequired = 3,
    RedirectUriRequired = 4,
    InvalidAuthorizationGrant = 5,
    InvalidAuthorizationScopes = 6,
    InvalidRefreshToken = 7,
    AuthorizationNotFound = 8,
    AuthorizationGrantExpired = 9,
    AccessAlreadyIssued = 10,
    InvalidRedirectUri = 11,
    AccessTokenNotFound = 12,
    InvalidAccessToken = 13,
    AccessTokenAlreadyRefreshed = 14,
    InvalidClientSecret = 15,
    ClientSecretExpired = 16,
    ServerError = 17,
    AccessDenied = 18,
    AccessTokenKeyRequired = 19,
    InvalidAccessTokenKey = 20,
    FailedToGetAccessToken = 21,
    InvalidClientId = 22,
    InvalidClient = 23,
    InvalidValidTo = 24,
    InvalidUserId = 25,
    FailedToIssueAccessToken = 26,
    AuthorizationGrantScopeMissing = 27,
    InvalidPublicAccessTokenKey = 28,
    InvalidPublicAccessToken = 29,
    PublicFeatureFlagNotEnabled = 30,
    SSHPolicyDisabled = 31
}
export var TypeInfo: {
    AccessToken: any;
    AccessTokenResult: any;
    AppSessionTokenError: {
        enumValues: {
            "none": number;
            "userIdRequired": number;
            "clientIdRequired": number;
            "invalidUserId": number;
            "invalidUserType": number;
            "accessDenied": number;
            "failedToIssueAppSessionToken": number;
            "invalidClientId": number;
            "authorizationIsNotSuccessfull": number;
        };
    };
    AppSessionTokenResult: any;
    AuthorizationGrant: any;
    CreatedByOptions: {
        enumValues: {
            "vstsWebUi": number;
            "nonVstsWebUi": number;
            "all": number;
        };
    };
    DisplayFilterOptions: {
        enumValues: {
            "active": number;
            "revoked": number;
            "expired": number;
            "all": number;
        };
    };
    GrantType: {
        enumValues: {
            "none": number;
            "jwtBearer": number;
            "refreshToken": number;
            "implicit": number;
            "clientCredentials": number;
        };
    };
    PagedSessionTokens: any;
    RefreshTokenGrant: any;
    SessionToken: any;
    SessionTokenType: {
        enumValues: {
            "selfDescribing": number;
            "compact": number;
        };
    };
    SortByOptions: {
        enumValues: {
            "displayName": number;
            "displayDate": number;
            "status": number;
        };
    };
    TokenError: {
        enumValues: {
            "none": number;
            "grantTypeRequired": number;
            "authorizationGrantRequired": number;
            "clientSecretRequired": number;
            "redirectUriRequired": number;
            "invalidAuthorizationGrant": number;
            "invalidAuthorizationScopes": number;
            "invalidRefreshToken": number;
            "authorizationNotFound": number;
            "authorizationGrantExpired": number;
            "accessAlreadyIssued": number;
            "invalidRedirectUri": number;
            "accessTokenNotFound": number;
            "invalidAccessToken": number;
            "accessTokenAlreadyRefreshed": number;
            "invalidClientSecret": number;
            "clientSecretExpired": number;
            "serverError": number;
            "accessDenied": number;
            "accessTokenKeyRequired": number;
            "invalidAccessTokenKey": number;
            "failedToGetAccessToken": number;
            "invalidClientId": number;
            "invalidClient": number;
            "invalidValidTo": number;
            "invalidUserId": number;
            "failedToIssueAccessToken": number;
            "authorizationGrantScopeMissing": number;
            "invalidPublicAccessTokenKey": number;
            "invalidPublicAccessToken": number;
            "publicFeatureFlagNotEnabled": number;
            "sSHPolicyDisabled": number;
        };
    };
};
}
declare module "VSS/Token/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import Contracts = require("VSS/Token/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods2To5 extends VSS_WebApi.VssHttpClient {
    protected accessTokensApiVersion: string;
    protected appSessionTokensApiVersion: string;
    protected appTokenPairsApiVersion: string;
    protected sessionTokensApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} authorizationId
     * @param {boolean} isPublic
     * @return IPromise<void>
     */
    revokeSessionToken(authorizationId: string, isPublic?: boolean): IPromise<void>;
    /**
     * [Preview API]
     *
     * @return IPromise<void>
     */
    revokeAllSessionTokensOfUser(): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.SshPublicKey} publicData
     * @param {boolean} remove
     * @return IPromise<void>
     */
    removePublicKey(publicData: Contracts.SshPublicKey, remove: boolean): IPromise<void>;
    /**
     * [Preview API]
     *
     * @param {Contracts.DisplayFilterOptions} displayFilterOption
     * @param {Contracts.CreatedByOptions} createdByOption
     * @param {Contracts.SortByOptions} sortByOption
     * @param {boolean} isSortAscending
     * @param {number} startRowNumber
     * @param {number} pageSize
     * @param {string} pageRequestTimeStamp
     * @param {boolean} isPublic
     * @param {boolean} includePublicData
     * @return IPromise<Contracts.PagedSessionTokens>
     */
    getSessionTokensPage(displayFilterOption: Contracts.DisplayFilterOptions, createdByOption: Contracts.CreatedByOptions, sortByOption: Contracts.SortByOptions, isSortAscending: boolean, startRowNumber: number, pageSize: number, pageRequestTimeStamp: string, isPublic?: boolean, includePublicData?: boolean): IPromise<Contracts.PagedSessionTokens>;
    /**
     * [Preview API]
     *
     * @param {boolean} isPublic
     * @param {boolean} includePublicData
     * @return IPromise<Contracts.SessionToken[]>
     */
    getSessionTokens(isPublic?: boolean, includePublicData?: boolean): IPromise<Contracts.SessionToken[]>;
    /**
     * [Preview API]
     *
     * @param {string} authorizationId
     * @param {boolean} isPublic
     * @return IPromise<Contracts.SessionToken>
     */
    getSessionToken(authorizationId: string, isPublic?: boolean): IPromise<Contracts.SessionToken>;
    /**
     * [Preview API]
     *
     * @param {Contracts.SessionToken} sessionToken
     * @param {Contracts.SessionTokenType} tokenType
     * @param {boolean} isPublic
     * @param {boolean} isRequestedByTfsPatWebUI
     * @return IPromise<Contracts.SessionToken>
     */
    createSessionToken(sessionToken: Contracts.SessionToken, tokenType?: Contracts.SessionTokenType, isPublic?: boolean, isRequestedByTfsPatWebUI?: boolean): IPromise<Contracts.SessionToken>;
    /**
     * [Preview API]
     *
     * @param {Contracts.AppTokenSecretPair} appInfo
     * @return IPromise<Contracts.AccessTokenResult>
     */
    exchangeAppToken(appInfo: Contracts.AppTokenSecretPair): IPromise<Contracts.AccessTokenResult>;
    /**
     * [Preview API]
     *
     * @param {string} clientId
     * @param {string} userId
     * @return IPromise<Contracts.AppSessionTokenResult>
     */
    issueAppSessionToken(clientId: string, userId?: string): IPromise<Contracts.AppSessionTokenResult>;
    /**
     * [Obsolete - Use ExchangeAccessTokenKey instead.  This endpoint should be removed after all services are updated to M123.]
     *
     * @param {string} key
     * @param {boolean} isPublic
     * @return IPromise<Contracts.AccessToken>
     */
    getAccessToken(key?: string, isPublic?: boolean): IPromise<Contracts.AccessToken>;
    /**
     * [Preview API]
     *
     * @param {string} accessTokenKey
     * @param {boolean} isPublic
     * @return IPromise<Contracts.AccessToken>
     */
    exchangeAccessTokenKey(accessTokenKey: string, isPublic?: boolean): IPromise<Contracts.AccessToken>;
}
/**
 * @exemptedapi
 */
export class TokenHttpClient5 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient4_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient4 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient3_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient3_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient2_3 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient2_2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient2_1 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class TokenHttpClient2 extends CommonMethods2To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class TokenHttpClient extends TokenHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return TokenHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): TokenHttpClient4_1;
}
declare module "VSS/UserAccountMapping/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\useraccountmapping.genclient.json
 */
export enum UserRole {
    Member = 1,
    Owner = 2
}
export enum VisualStudioLevel {
    None = 0,
    Professional = 1,
    TestManager = 2
}
export var TypeInfo: {
    UserRole: {
        enumValues: {
            "member": number;
            "owner": number;
        };
    };
    VisualStudioLevel: {
        enumValues: {
            "none": number;
            "professional": number;
            "testManager": number;
        };
    };
};
}
declare module "VSS/UserMapping/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\usermapping.genclient.json
 */
export enum UserType {
    Member = 1,
    Owner = 2
}
export var TypeInfo: {
    UserType: {
        enumValues: {
            "member": number;
            "owner": number;
        };
    };
};
}
declare module "VSS/UserMapping/RestClient" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\usermapping.genclient.json
 */
import Contracts = require("VSS/UserMapping/Contracts");
import VSS_WebApi = require("VSS/WebApi/RestClient");
export class CommonMethods3_1To5 extends VSS_WebApi.VssHttpClient {
    static serviceInstanceId: string;
    protected userAccountMappingsApiVersion: string;
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
    /**
     * [Preview API]
     *
     * @param {string} userId
     * @param {Contracts.UserType} userType
     * @param {boolean} useEqualsCheckForUserTypeMatch
     * @param {boolean} includeDeletedAccounts
     * @return IPromise<string[]>
     */
    queryAccountIds(userId: string, userType: Contracts.UserType, useEqualsCheckForUserTypeMatch?: boolean, includeDeletedAccounts?: boolean): IPromise<string[]>;
    /**
     * [Preview API]
     *
     * @param {string} userId
     * @param {string} accountId
     * @param {Contracts.UserType} userType
     * @return IPromise<void>
     */
    activateUserAccountMapping(userId: string, accountId: string, userType?: Contracts.UserType): IPromise<void>;
}
/**
 * @exemptedapi
 */
export class UserMappingHttpClient5 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class UserMappingHttpClient4_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class UserMappingHttpClient4 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class UserMappingHttpClient3_2 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * @exemptedapi
 */
export class UserMappingHttpClient3_1 extends CommonMethods3_1To5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
export class UserMappingHttpClient extends UserMappingHttpClient5 {
    constructor(rootRequestPath: string, options?: VSS_WebApi.IVssHttpClientOptions);
}
/**
 * Gets an http client targeting the latest released version of the APIs.
 *
 * @return UserMappingHttpClient4_1
 */
export function getClient(options?: VSS_WebApi.IVssHttpClientOptions): UserMappingHttpClient4_1;
}
declare module "VSS/User/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\user.genclient.json
 */
/**
 * Host accessed by a user.
 */
export interface AccessedHost {
    accessTime: Date;
    hostId: string;
}
/**
 * Request to update a user's accessed hosts.
 */
export interface AccessedHostsParameters {
    accessedHosts: AccessedHost[];
    userDescriptor: string;
}
/**
 * The user's picture.
 */
export interface Avatar {
    /**
     * The raw avatar image data, in either jpg or png format.
     */
    image: number[];
    /**
     * True if the avatar is dynamically generated, false if user-provided.
     */
    isAutoGenerated: boolean;
    /**
     * The date/time at which the avatar was last modified.
     */
    lastModified: Date;
    /**
     * The size of the avatar, e.g. small, medium, or large.
     */
    size: AvatarSize;
}
/**
 * The avatar size, as scaled to one of several predefined settings.
 */
export enum AvatarSize {
    /**
     * 34 x 34 pixels
     */
    Small = 0,
    /**
     * 44 x 44 pixels
     */
    Medium = 1,
    /**
     * 220 x 220 pixels
     */
    Large = 2
}
/**
 * Used at the time of initial user creation.
 */
export interface CreateUserParameters {
    /**
     * The user's country of residence or association.
     */
    country: string;
    data: {
        [key: string]: any;
    };
    /**
     * The user's unique identifier, and the primary means by which the user is referenced.
     */
    descriptor: string;
    /**
     * The user's name, as displayed throughout the product.
     */
    displayName: string;
    /**
     * The user's preferred email address.
     */
    mail: string;
    /**
     * Identifier to mark whether user's profile is pending
     */
    pendingProfileCreation: boolean;
    /**
     * The region in which the user resides or is associated.
     */
    region: string;
}
export interface MailConfirmationParameters {
    /**
     * The unique code that proves ownership of the email address.
     */
    challengeCode: string;
    /**
     * The email address to be confirmed.
     */
    mailAddress: string;
}
/**
 * Used for updating a user's attributes.
 */
export interface SetUserAttributeParameters {
    /**
     * The date/time at which the attribute was last modified.
     */
    lastModified: Date;
    /**
     * The unique group-prefixed name of the attribute, e.g. "TFS.TimeZone".
     */
    name: string;
    /**
     * The attribute's revision, for change tracking.
     */
    revision: number;
    /**
     * The value of the attribute.
     */
    value: string;
}
/**
 * Used for updating a user's data.
 */
export interface UpdateUserParameters {
    /**
     * The collection of properties to set.  See "User" for valid fields.
     */
    properties: any;
}
export interface User {
    /**
     * A short blurb of "about me"-style text.
     */
    bio: string;
    /**
     * A link to an external blog.
     */
    blog: string;
    /**
     * The company at which the user is employed.
     */
    company: string;
    /**
     * The user's country of residence or association.
     */
    country: string;
    /**
     * The date the user was created in the system
     */
    dateCreated: Date;
    /**
     * The user's unique identifier, and the primary means by which the user is referenced.
     */
    descriptor: string;
    /**
     * The user's name, as displayed throughout the product.
     */
    displayName: string;
    /**
     * The date/time at which the user data was last modified.
     */
    lastModified: Date;
    /**
     * A set of readonly links for obtaining more info about the user.
     */
    links: any;
    /**
     * The user's preferred email address.
     */
    mail: string;
    /**
     * The attribute's revision, for change tracking.
     */
    revision: number;
    /**
     * The status of the user
     */
    state: UserState;
    /**
     * The user's preferred email address which has not yet been confirmed.
     */
    unconfirmedMail: string;
    /**
     * The unique name of the user.
     */
    userName: string;
}
export interface UserAttribute {
    /**
     * The date/time at which the attribute was last modified.
     */
    lastModified: Date;
    /**
     * The unique group-prefixed name of the attribute, e.g. "TFS.TimeZone".
     */
    name: string;
    /**
     * The attribute's revision, for change tracking.
     */
    revision: number;
    /**
     * The value of the attribute.
     */
    value: string;
}
export interface UserAttributes {
    /**
     * Collection of attributes
     */
    attributes: UserAttribute[];
    /**
     * Opaque string to get the next chunk of results Server would return non-null string here if there is more data Client will need then to pass it to the server to get more results
     */
    continuationToken: string;
}
export enum UserState {
    Wellformed = 0,
    PendingProfileCreation = 1,
    Deleted = 2
}
export var TypeInfo: {
    AccessedHost: any;
    AccessedHostsParameters: any;
    Avatar: any;
    AvatarSize: {
        enumValues: {
            "small": number;
            "medium": number;
            "large": number;
        };
    };
    SetUserAttributeParameters: any;
    User: any;
    UserAttribute: any;
    UserAttributes: any;
    UserState: {
        enumValues: {
            "wellformed": number;
            "pendingProfileCreation": number;
            "deleted": number;
        };
    };
};
}
declare module "VSS/User/Services" {
export namespace UserClaims {
    /**
     * User is not authenticated.
     */
    const Anonymous = "anonymous";
    /**
     * User carrying this claim is not a member of the current project but a member of the current account.
     */
    const Public = "public";
    /**
     * User carrying this claim is a member of the current project.
     */
    const Member = "member";
}
export interface IUserClaimsService {
    /**
     * Checks whether current user has the specified claim or not.
     *
     * @param {string} claim User claim to check.
     * @returns {boolean}
     */
    hasClaim: (claim: string) => boolean;
}
export function getService(): IUserClaimsService;
}
declare module "VSS/Utils/Accessibility" {
/**
 * Causes screen readers to read the given message.
 * @param message
 * @param assertive if true, the screen reader will read the announcement immediately, instead of waiting for "the next graceful opportunity"
 */
export function announce(message: string, assertive?: boolean): void;
export interface MultiProgressAnnouncerOptions {
    /**
     * The amount of time to wait after the operation has begun before announcing the start (in
     * milliseconds).
     */
    announceStartDelay?: number;
    /**
     * The amount of time to wait after the operation has completed before announcing completion (in
     * milliseconds).
     */
    announceEndDelay?: number;
    /**
     * The message to announce to the user at the start of the operation.
     */
    announceStartMessage: string;
    /**
     * The message to announce to the user at the end of the operation.
     */
    announceEndMessage: string;
    /**
     * Function that the ProgressAnnouncer can call to get the number of currently active operations.
     */
    getActiveCount: () => number;
}
/**
 * Class for announcing, through a screen reader, when an operation, composed of multiple
 * suboperations, begins and ends. Supports a delay before the starting announcement to keep quick
 * operations from being announced, and delays before the ending announcment in case the operation
 * wasn't actually quite over, or a new one starts.
 *
 * To use, create a MultiProgressAnnouncer, and then whenever the number of active operations has
 * potentially changed, call .update().
 */
export class MultiProgressAnnouncer {
    private _state;
    private _options;
    private _announceDelay;
    constructor(options: MultiProgressAnnouncerOptions);
    /**
     * Call this when the number of active operations may have changed. ProgressAnnouncer will
     * then make appropriate announcements.
     */
    update(): void;
    private _startAnnounceTimer;
    private _cancelAnnounceTimer;
}
export interface ProgressAnnouncerOptions {
    /**
     * The amount of time to wait after the operation has begun before announcing the start (in
     * milliseconds).
     */
    announceStartDelay?: number;
    /**
     * The message to announce to the user at the start of the operation. Leave blank or undefined
     * for no announcement.
     */
    announceStartMessage?: string;
    /**
     * The message to announce to the user at the end of the operation. Leave blank or undefined
     * for no announcement.
     */
    announceEndMessage?: string;
    /**
     * The message to announce to the user if the operation fails. Leave blank or undefined for no
     * announcement.
     */
    announceErrorMessage?: string;
    /**
     * Always announce the end message.
     */
    alwaysAnnounceEnd?: boolean;
}
/**
 * Class for announcing, through a screen reader, when a single operation begins and ends. Supports
 * a delay before the starting announcement so that quick operations don't trigger announcements.
 *
 * To use, create a ProgressAnnouncer, and call completed()
 */
export class ProgressAnnouncer {
    private _options;
    private _announceDelay;
    private _startAnnounced;
    private _completed;
    constructor(options: ProgressAnnouncerOptions);
    /**
     * Create a ProgressAnnouncer for a promise that will announce promise start and completion/rejection.
     * @param promise
     * @param options
     */
    static forPromise<T>(promise: IPromise<T>, options: ProgressAnnouncerOptions): void;
    private _start;
    /**
     * Call this method when the operation has completed. This will cause the end message to be
     * announced if the start message was announced or if alwaysAnnounceEnd is set to true.
     */
    announceCompleted(): void;
    /**
     * Call this method if the operation completes with an error. This will cause the error message
     * to be announced regardless of whether or not the start message was announced.
     */
    announceError(): void;
}
}
declare module "VSS/Utils/Array" {
/**
* Returns the first element of an array that matches the predicate.
*
* @param array Array used to perform predicate.
* @param predicate The Predicate function.
* @return The first element that matches the predicate.
*/
export function first<T>(array: T[], predicate?: (value: T) => boolean): T;
export function arrayContains<S, T>(value: S, target: T[], comparer?: (s: S, t: T) => boolean): boolean;
export function arrayEquals<S, T>(source: S[], target: T[], comparer?: (s: S, t: T) => boolean, nullResult?: boolean, sorted?: boolean): boolean;
/**
* Compares two arrays for member-wise equality.
*
* @param arrayA First array to compare.
* @param arrayB Other array to compare.
* @return True if both arrays are the same length, and every index has the same value in both arrays. "Same value" in this
*         case means "===" equality. Also true if both arrays are null. Otherwise, returns false.
*/
export function shallowEquals(arrayA: any[], arrayB: any[]): boolean;
/**
    * Take an array of values and convert it to a dictionary/lookup table.
    * @param array Values to convert
    * @param getKey Function to get the key for a given item
    * @param getValue Optional function to get teh value for a given item (defaults to the item itself)
    * @param throwOnDuplicateKeys Optional value indicating to throw an error when duplicate keys are present. Otherwise just overwrite any duplicates
    * @return
    */
export function toDictionary<TArray, TValue>(array: TArray[], getKey: (item: TArray, index: number) => string, getValue?: (item: TArray, index: number) => TValue, throwOnDuplicateKeys?: boolean): IDictionaryStringTo<TValue>;
/**
    * @param array
    * @param value
    * @param comparer
    * @return
    */
export function contains<T>(array: T[], value: T, comparer?: IComparer<any>): boolean;
/**
    * @param array
    * @param predicate
    * @return
    */
export function findIndex<T>(array: T[], predicate: IFunctionPR<T, boolean>): number;
/**
    * @param arrayA
    * @param arrayB
    * @param comparer
    * @return
    */
export function intersect<T>(arrayA: T[], arrayB: T[], comparer?: IComparer<T>): T[];
/**
    * Helper method used to intersect arrays of strings or numbers
    *
    * @param arrayA
    * @param arrayB
    * @param caseInsensitive
    * @return
    */
export function intersectPrimitives<T>(arrayA: T[], arrayB: T[], caseInsensitive?: boolean): T[];
/**
    * @param arrayA
    * @param arrayB
    * @param comparer
    * @return
    */
export function union<T>(arrayA: T[], arrayB: T[], comparer?: IComparer<T>): T[];
/**
    * Sorts and removes duplicate elements
    *
    * @param array
    * @param comparer
    * @return
    */
export function uniqueSort<T>(array: T[], comparer?: IComparer<T>): T[];
/**
    * @param array
    * @param comparer
    * @return
    */
export function unique<T>(array: T[], comparer?: IComparer<T>): T[];
/**
    * @param arrayA
    * @param arrayB
    * @param comparer
    * @return
    */
export function subtract<T>(arrayA: T[], arrayB: T[], comparer?: IComparer<T>): T[];
/**
    * Reorders an array by moving oldIndex + the "count" next elements to the newIndex in the array
    *
    * @param array
    * @param oldIndex The index of the array element to move
    * @param newIndex The index of the array to insert the element at
    * @param count The number of subsequent, contiguous elements to take with the oldIndex in the reorder
    */
export function reorder<T>(array: T[], oldIndex: number, newIndex: number, count: number): T[];
/**
    * @param array
    * @param comparer
    * @return
    */
export function flagSorted<T>(array: T[], comparer: IComparer<T>): void;
/**
    * @param toArray
    * @param fromArray
    * @return
    */
export function copySortFlag<T>(toArray: T[], fromArray: T[]): void;
/**
    * @param array
    * @param comparer
    * @return
    */
export function isSorted<T>(array: T[], comparer: IComparer<T>): boolean;
/**
    * @param array
    * @param comparer
    * @return
    */
export function sortIfNotSorted<T>(array: T[], comparer: IComparer<T>): boolean;
/**
    * @param array
    * @return
    */
export function clone<T>(array: T[]): T[];
/**
    * @param array
    * @param item
    * @return
    */
export function indexOf<T>(array: T[], item: T): number;
/**
    * @param array
    * @param item
    */
export function add<T>(array: T[], item: T): void;
/**
    * @param array
    * @param items
    */
export function addRange<T>(array: T[], items: T[]): void;
/**
    * @param array
    * @param item
    * @return
    */
export function remove<T>(array: T[], item: T): boolean;
/**
 * Remove items from array that satisfy the predicate.
 * @param array
 * @param predicate
 */
export function removeWhere<T>(array: T[], predicate: (element: T) => boolean, count?: number, startAt?: number): void;
/**
 * Removes the given index from the array
 * @param array
 * @param index
 * @return boolean false if the index is out of bounds.
 */
export function removeAtIndex<T>(array: T[], index: number): boolean;
/**
 * Removes all of the given indexes from array
 * @param array
 * @param indexes
 * @return boolean false if any index is out of bounds
 */
export function removeAllIndexes<T>(array: T[], indexes: number[]): boolean;
/**
    * @param array
    */
export function clear<T>(array: T[]): void;
/**
 * Returns an array which is the sorted intersection of values between two other arrays.
 * This function is optimized to work only with sorted arrays with unique values.
 * @param sortedUniqueArray1 Input array - which must already be sorted and only contain unique values
 * @param sortedUniqueArray2 Input array - which must already be sorted and only contain unique values
 * @param comparer A comparer for values of type T
 * @returns An array that is the intersection of the values from the two input arrays (as determined by the comparer). The result array will be sorted. If there is no intersection, an empty array is returned.
 */
export function intersectUniqueSorted<T>(sortedUniqueArray1: T[], sortedUniqueArray2: T[], comparer?: IComparer<T>): T[];
/**
 * Flattens an array made of arrays, returning a list where inner lists are put together in a single list.
 * It's like Linq.SelectMany.
 */
export function flatten<T>(listOfLists: T[][]): T[];
/** Merges two sorted lists of T into one sorted list of T
* @param listA The first list
* @param listB The second list
* @param comparer The comparer to use
*/
export function mergeSorted<T>(listA: T[], listB: T[], comparer?: IComparer<T>): T[];
export class StableSorter<T> {
    private cmpFunc;
    constructor(cmpFunc: (a: T, b: T) => number);
    private msort;
    private merge_sort;
    private merge;
    private arr_swap;
    private insert;
    /**
     * Returns a copy of array that is sorted using a stable sorting routine
     * @param array
     * @return sorted array
     */
    sort(array: T[], inPlace?: boolean): T[];
}
}
declare module "VSS/Utils/Clipboard" {
import Dialogs_NoRequire = require("VSS/Controls/Dialogs");
/**
 * Copies the specified data to the clipboard in the TEXT format using a progressively degrading experience.
 *
 * @param data The data to copy.
 */
export function copyToClipboard(data: string, options?: IClipboardOptions): void;
/**
 * Gets a boolean value indicating whether the current browser supports native clipboard access.
 */
export function supportsNativeCopy(): boolean;
/**
 * Gets a boolean value indicating whether the current browser supports native clipboard access for HTML content.
 */
export function supportsNativeHtmlCopy(): boolean;
/**
 * Options for Copy To Clipboard feature
 */
export interface IClipboardOptions {
    /**
     * Boolean specifying whether the data should be copied as plain text or html
     */
    copyAsHtml?: boolean;
    /**
     * Option for always using copy to clipboard dialog or browser native feature (if present)
     */
    showCopyDialog?: boolean;
    /**
     * Options passed to copy dialog if needed
     */
    copyDialogOptions?: Dialogs_NoRequire.CopyContentDialogOptions;
}
}
declare module "VSS/Utils/Constants" {
/**
* URL-related constants.
*/
export module UrlConstants {
    /**
    * Approved list of URL schemes.
    */
    var SafeUriSchemes: string[];
}
}
declare module "VSS/Utils/Core" {
/**
 * Wrap a function to ensure that a specific value of 'this' is passed to the function when it is invoked (regardless of the caller).
 *
 * @param instance The object that will be set to the value of 'this' when the function is invoked.
 * @param method The function to wrap.
 * @param data Arguments that will be appended to the arguments passed when the delegate is invoked.
 * @return The wrapper function
 */
export function delegate(instance: any, method: Function, data?: any): IArgsFunctionR<any>;
/**
 *     Curries a function with a set of arguments and returns the resulting function.
 *     When eventually evaluated, the returned function will call the original function
 *     with the current arguments prepended to the list of arguments.
 *
 *     var add3, result;
 *     function add(x, y) {
 *         return x + y;
 *     }
 *     add3 = add.curry(3);
 *     results = add3(4); // result === 7
 *
 *     See http://en.wikipedia.org/wiki/Curry_function
 *
 * @param fn
 * @param args
 */
export function curry(fn: Function, ...args: any[]): IArgsFunctionR<any>;
export class DelayedFunction {
    private _interval;
    private _func;
    private _timeoutHandle;
    private _cooldownHandle;
    private _name;
    private _invokeOnCooldownComplete;
    /**
     * Creates an object that can be used to delay-execute the specified method.
     *
     * @param instance Context to use when calling the provided function
     * @param ms Delay in milliseconds to wait before executing the Function
     * @param name Name to use when tracing this delayed function
     * @param method Method to execute
     * @param data Arguments to pass to the method
     */
    constructor(instance: any, ms: number, name: string, method: Function, data?: any[]);
    /**
     * Starts the timer (if not already started) which will invoke the method once expired.
     */
    start(): void;
    /**
     * Resets the timer (cancel, then re-start) which will invoke the method once expired.
     */
    reset(): void;
    /**
     * Cancels any pending operation (stops the timer).
     */
    cancel(clearCooldown?: boolean): void;
    /**
     * Clears the current cooldown
     * @param cancelScheduledInvocation (boolean) true to ignore any invocation that is
     *        scheduled to occur after the cooldown is finished.
     */
    clearCooldown(cancelScheduledInvocation?: boolean): void;
    /**
     * Resets the cooldown back to [delay] ms.
     */
    extendCooldown(): void;
    /**
     * Invokes the method immediately (canceling an existing timer).
     */
    invokeNow(): void;
    /**
     * Modifies the length of the delay timer (for subsequent starts).
     *
     * @param ms Delay in milliseconds to wait before executing the Function
     */
    setDelay(ms: number): void;
    /**
     * Modify the method being executed.
     *
     * @param instance Context to use when calling the provided function
     * @param method Method to execute
     * @param data (Optional) arguments to pass to the method
     */
    setMethod(instance: any, method: Function, data?: any[]): void;
    /**
     * Is the timer currently running (operation in progress)
     *
     * @return True if this operation is already in progress
     */
    isPending(): boolean;
    /**
     * Is the delayed function in a "cooldown" state (operation
     * completed recently)
     *
     * @return True if it has been less than [delay] ms since
     * the last invocation of the function.
     */
    isCoolingDown(): boolean;
    /**
     * Schedule this delayed function to execute when the cooldown is complete.
     */
    invokeOnCooldownComplete(): void;
    /**
     * Invokes the delegate and starts (or restars) the cooldown period.
     */
    private _invoke;
    private _startCooldown;
}
/**
 * Executes the provided function after the specified amount of time
 *
 * @param instance Context to use when calling the provided function
 * @param ms Delay in milliseconds to wait before executing the Function
 * @param method Method to execute
 * @param data Arguments to pass to the method
 * @return The delayed function that was started
 */
export function delay(instance: any, ms: number, method: Function, data?: any[]): DelayedFunction;
/**
 * Options to control the behavior of the Throttled Delegate.
 * Note, these are flags, so multiple options can be OR'd together.
 */
export enum ThrottledDelegateOptions {
    /**
     * Never call the delegate until after the elapsed time has passed since the
     * most recent call to the delegate.
     */
    Default = 0,
    /**
     * This throttled delegate will be invoked immediately on the first call, then
     * at most every n milliseconds thereafter
     */
    Immediate = 1,
    /**
     * If Immediate is set, this determines if a call that is made during the cooldown
     * period will be ignored or queued up to be executed when the cooldown is done.
     */
    QueueNext = 2,
    /**
     * If set, subsequent calls to the delegate will result in a simple noop during
     * the cooldown period (as opposed to resetting the timer).
     * If not set, each call to the delegate will reset the timer. This means the function
     * might never get executed as long as the delegate continues to be called fast enough.
     */
    NeverResetTimer = 4
}
/**
 * Creates a delegate that is delayed for the specified interval when invoked.
 * Subsequent calls to the returned delegate reset the timer. Using the options
 * parameter, callers can determine if the invocation happens on the rising
 * edge (immediately when the delegate is called) or on the falling edge (Default).
 *
 * @param instance Context to use when calling the provided function
 * @param ms Delay in milliseconds to wait before executing the Function
 * @param method Method to execute
 * @param data Arguments to pass to the method
 * @param options Specify the behavior of when the delegate gets invoked
 * @return The delayed delegate function.
 */
export function throttledDelegate(instance: any, ms: number, method: Function, data?: any[], options?: ThrottledDelegateOptions): IArgsFunctionR<any>;
/**
 * Splits a string that contains a list of comma-separated (signed) integer values into an array
 *
 * @param stringRepresentation String representation of comma-separated integer array
 * @return Array of parsed integers
 */
export function parseIntArray(stringRepresentation: string): number[];
export class Cancelable {
    private _callbacks;
    canceled: boolean;
    context: any;
    /**
     * Manage cancellable operations.
     *
     * @param context The context for the cancellable operation.
     * The context is passed to actions when they are called.
     */
    constructor(context: any);
    /**
     * Perform the action if not cancelled.
     *
     * @param action The action to call if the current operation has not been cancelled.
     */
    perform(action: Function): void;
    /**
     * Wrap an action to make it cancellable.
     *
     * @param action The action to wrap.
     * @return The cancellable action.
     */
    wrap(action: Function): Function;
    /**
     * Cancel the operation.
     */
    cancel(): void;
    /**
     * Register a callback to be called when the object is cancelled.
     *
     * @param callback The callback function.
     */
    register(callback: Function): void;
}
export class DisposalManager implements IDisposable {
    /**
     * List of disposables.
     */
    private _disposables;
    constructor();
    /**
     * Add the specified disposable to the list.
     *
     * @param disposable Disposable to be added to the list.
     */
    addDisposable<TDisposable extends IDisposable>(disposable: TDisposable): TDisposable;
    /**
     * Disposes all disposables.
     */
    dispose(): void;
}
/**
* Deserialize an "MSJSON" formatted string into the corresponding JSON object. This converts a
* string like "\\/Date(1448375104308)\\/" into the corresponding Date object.
*
* Returns null if not a valid JSON string.
*
* @param data The JSON string to deserialize
* @param secure Unused parameter
*/
export function tryParseMSJSON(data: any, secure?: boolean): any;
/**
* Deserialize an "MSJSON" formatted string into the corresponding JSON object. This converts a
* string like "\\/Date(1448375104308)\\/" into the corresponding Date object.
*
* Throws if not a valid JSON string.
*
* @param data The JSON string to deserialize
* @param secure Unused parameter
*/
export function parseMSJSON(data: any, secure?: boolean): any;
/**
* Serialize a JSON object into "MSJSON" format which has date objects serialized in the
* format: "\\/Date(1448375104308)\\/"
*
* @param object The JSON object to serialize
*/
export function stringifyMSJSON(object: any): string;
/**
 * Parse data from a JSON Island into an object
 *
 * @param $context The context in which to search for the JSON data
 * @param selectionFilter An optional selector that will filter the selection of JSON islands found.
 * @param remove .
 * @return
 */
export function parseJsonIsland($context: JQuery, selectionFilter?: string, remove?: boolean): any;
/**
 * Converts the specified value to a display string.
 *
 * @param value The value to convert.
 * @param format The value to convert.
 */
export function convertValueToDisplayString(value: any, format?: string): string;
export function domToXml(xmlNode: any): string;
export function parseXml(xml: string): any;
/**
 * Compare two objects value are deep equal, order matters in array comparision.
 *
 * @param first The first object
 * @param second The second object
 * @return True if two objects are deepEqual, otherwise false.
 */
export function equals(first: any, second: any): boolean;
/**
 * Executes the provided function after the specified amount of time
 * @param functionDelegate Function to execute
 * @param delay Delay in milliseconds to wait before executing the Function
 * @param maxAttempt The max number of attemp should try, if not specified, it will continus polling
 * @param firstDelay Delay in milliseconds to wait before executing the Function for the first time (default 0)
 * @param shouldStopDelegate Callback to determine whether to stop the poll or not
 * @param reachMaxAttemptCallback Callback when max attempted is reached
 */
export function poll(functionDelegate: (sucessCallback: IResultCallback, errorCallback?: IErrorCallback) => void, delay: number, maxAttempt: number, firstDelay?: number, shouldStopDelegate?: (result: any) => boolean, reachMaxAttemptCallback?: () => void): void;
/**
 * Set a cookie
 * @param name Name of cookie
 * @param value Value of cookie
 * @param path Path for which to set cookie, defaults to '/'
 * @param expires Optional, data in GMTString format, indicating the time of expiration
 * @param maxAge Optional, maximum age of the cookie in seconds
 */
export function setCookie(name: string, value: string, path?: string, expires?: string, maxAge?: number): void;
export function deleteCookie(cookieName: string): void;
export var documentSelection: any;
}
declare module "VSS/Utils/Culture" {
/**
* Culture-related settings
*/
export interface ICultureInfo {
    name: string;
    numberFormat: INumberFormatSettings;
    dateTimeFormat: IDateTimeFormatSettings;
    numberShortForm: INumberShortForm;
}
/**
* Number Short form setting
* it is the same internal class from the ClientCultureInfo.cs
*/
export interface INumberShortForm {
    QuantitySymbols: string[];
    NumberGroupSize: number;
    ThousandSymbol: string;
}
/**
* Number formatting culture settings
*/
export interface INumberFormatSettings {
    CurrencyDecimalDigits: number;
    CurrencyDecimalSeparator: string;
    CurrencyGroupSizes: number[];
    NumberGroupSizes: number[];
    PercentGroupSizes: number[];
    CurrencyGroupSeparator: string;
    CurrencySymbol: string;
    NaNSymbol: string;
    CurrencyNegativePattern: number;
    NumberNegativePattern: number;
    PercentPositivePattern: number;
    PercentNegativePattern: number;
    NegativeInfinitySymbol: string;
    NegativeSign: string;
    NumberDecimalDigits: number;
    NumberDecimalSeparator: string;
    NumberGroupSeparator: string;
    CurrencyPositivePattern: number;
    PositiveInfinitySymbol: string;
    PositiveSign: string;
    PercentDecimalDigits: number;
    PercentDecimalSeparator: string;
    PercentGroupSeparator: string;
    PercentSymbol: string;
    PerMilleSymbol: string;
    NativeDigits: string[];
    DigitSubstitution: number;
}
/**
* DateTime-format related culture settings
*/
export interface IDateTimeFormatSettings {
    AMDesignator: string;
    Calendar: {
        MinSupportedDateTime: string;
        MaxSupportedDateTime: string;
        AlgorithmType: number;
        CalendarType: number;
        Eras: any[];
        TwoDigitYearMax: number;
        convert?: {
            fromGregorian: (date: Date) => number[];
            toGregorian: (year: number, month: number, day: number) => Date;
        };
    };
    DateSeparator: string;
    FirstDayOfWeek: number;
    CalendarWeekRule: number;
    FullDateTimePattern: string;
    LongDatePattern: string;
    LongTimePattern: string;
    MonthDayPattern: string;
    PMDesignator: string;
    RFC1123Pattern: string;
    ShortDatePattern: string;
    ShortTimePattern: string;
    SortableDateTimePattern: string;
    TimeSeparator: string;
    UniversalSortableDateTimePattern: string;
    YearMonthPattern: string;
    AbbreviatedDayNames: string[];
    ShortestDayNames: string[];
    DayNames: string[];
    AbbreviatedMonthNames: string[];
    MonthNames: string[];
    NativeCalendarName: string;
    AbbreviatedMonthGenitiveNames: string[];
    MonthGenitiveNames: string[];
    eras: any[];
}
/**
* Get culture settings for the invariant culture
*/
export function getInvariantCulture(): ICultureInfo;
/**
* Get culture settings for the current user's preferred culture
*/
export function getCurrentCulture(): ICultureInfo;
/**
* Get the name of the current culture being used on this page
*/
export function getCurrentCultureName(): string;
/**
* Get the number format settings for the current culture
*/
export function getNumberFormat(): INumberFormatSettings;
/**
* Get the DateTime format settings for the current culture
*/
export function getDateTimeFormat(): IDateTimeFormatSettings;
/**
* Get the Number Short Form setting for the current culture
*/
export function getNumberShortForm(): INumberShortForm;
}
declare module "VSS/Utils/Date" {
import Contracts_Platform = require("VSS/Common/Contracts/Platform");
export var utcOffset: number;
export var timeZoneMap: Contracts_Platform.DaylightSavingsAdjustmentEntry[];
export var MILLISECONDS_IN_MINUTE: number;
export var MILLISECONDS_IN_HOUR: number;
export var MILLISECONDS_IN_DAY: number;
export var MILLISECONDS_IN_WEEK: number;
export var DATETIME_MINDATE_UTC_MS: number;
/**
 * Checks whether the specified datestring is in ISO 8601 date format or not.
 * @param dateString
 */
export function isIsoDate(dateString: string): boolean;
/**
    * Checks whether this date object corresponds to a min date or not
    *
    * @return
    */
export function isMinDate(date: Date): boolean;
/**
    * Compares two date objects. Returns a number:
    *    Less than 0 if date1 is earlier than date2
    *    Zero if date1 is the same as date2
    *    Greater than zero if date1 is later than date2
    *
    * If an argument is not an instance of a Date then it is considered earlier than
    * the other argument, or the same if the other argument is also not an instance of
    * a Date
    *
    * @param date1 Date object to compare
    * @param date2 Date object to compare
    * @return
    */
export function defaultComparer(date1: Date, date2: Date): number;
/**
    * Compare two dates to see if they are equal - returning true if they are equal.
    *
    * @param date1 The first value to compare
    * @param date2 The second value to compare
    * @return
    */
export function equals(date1: Date, date2: Date): boolean;
/**
    * Shifts the date to match the UTC date.  This is done by creating a new date with the same UTC year, month,
    * date and time all converted to UTC.
    *
    * @param date The date to be converted.
    * @return
    */
export function shiftToUTC(date: Date): Date;
/**
    * Shifts the date to match the local date.  This is done by adding the timezone offset to the date.
    *
    * @param date The date to be converted.
    * @return
    */
export function shiftToLocal(date: Date): Date;
/**
    * Parses the string into a date.
    *
    * @param dateString Date string to parse.
    * @param parseFormat Optional format string to use in parsing the date. May be null or undefined
    * @param ignoreTimeZone
    *     Optional value indicating to ignore the time zone set set in user preferences?
    *     Should be set to true when a Date string should be parsed irrespective of the user's time zone (e.g. calendar control).
    *
    * @return
    */
export function parseDateString(dateString: string, parseFormat?: string, ignoreTimeZone?: boolean): Date;
/**
    * Returns the number of days between the two dates. Note that any time component is ignored and the dates
    * can be supplied in any order
    *
    * @param startDate The first date
    * @param endDate The second date
    * @param exclusive If true then the result is exclusive of the second date (Mon->Fri==4).
    * Otherwise the date includes the later date (Mon->Fri==5)
    */
export function daysBetweenDates(startDate: Date, endDate: Date, exclusive?: boolean): number;
/**
    * @param value Date string
    * @param formats Date string formats
    * @param ignoreTimeZone
    * @return
    */
export function parseLocale(value: string, formats?: string[] | string, ignoreTimeZone?: boolean): Date;
/**
    * @param date The Date object to format
    * @param format Date string format
    * @param ignoreTimeZone
    * @return
    */
export function localeFormat(date: Date, format?: string, ignoreTimeZone?: boolean): string;
/**
    * Converts a time from the client (e.g. new Date()) to the user's preferred timezone
    *
    * @param date The Date object to convert
    * @param adjustOffset
    *     If true, consider the date portion when converting (get the timezone offset at that particular date).
    *     False indicates to use the current (today's) timezone offset regardless of the date given.
    *
    */
export function convertClientTimeToUserTimeZone(date: Date, adjustOffset?: boolean): Date;
/**
    * Converts a time from the user's preferred timezone to the client (e.g. new Date()) timezone
    *
    * @param date The Date object to convert
    * @param adjustOffset
    *     If true, consider the date portion when converting (get the timezone offset at that particular date).
    *     False indicates to use the current (today's) timezone offset regardless of the date given.
    *
    */
export function convertUserTimeToClientTimeZone(date: Date, adjustOffset?: boolean): Date;
/**
    * Strip the time from the given date (return a new date) such that the new date is of 12:00:00 AM
    */
export function stripTimeFromDate(date: Date): Date;
/**
    * Get the equivalent of "Now" in the user's time zone.
    */
export function getNowInUserTimeZone(): Date;
/**
    * Get the equivalent of "Today" (date as of midnight) in the user's time zone
    */
export function getTodayInUserTimeZone(): Date;
/**
    * @param date The Date object to format
    * @param format Date string format
    * @return
    */
export function format(date: Date, format?: string): string;
/**
    * Generate a string indicating how long ago the date is.
    *
    * @param date The Date object to format
    * @param now
    * @return A friendly string
    */
export function ago(date: Date, now?: Date): string;
/**
    * Adds days to a given date
    *
    * @param date The Date object to add to
    * @param days Number of days to add
    * @param adjustOffset is true then the offset will be adjusted if the offset between the date passed
    * and the date obtained after adding days is different.
    *
    */
export function addDays(date: Date, days: number, adjustOffset?: boolean): Date;
/**
    * Adds hours to a given date
    *
    * @param date The Date object to add to
    * @param hours Number of hours to add
    * @param adjustOffset is true then the offset will be adjusted if the offset between the date passed
    * and the date obtained after adding hours is different.
    *
    */
export function addHours(date: Date, hours: number, adjustOffset?: boolean): Date;
/**
    * Adds minutes to a given date
    *
    * @param date The Date object to add to
    * @param minutes Number of minutes to add
    * @param adjustOffset is true then the offset will be adjusted if the offset between the date passed
    * and the date obtained after adding minutes is different.
    *
    */
export function addMinutes(date: Date, minutes: number, adjustOffset?: boolean): Date;
/**
    * Adjusts the time zone offset by applying the time difference in the offsets.
    *
    * @param oldDate The Date object which was used before time zone changed.
    * @param newDate The Date object which was used after time zone changed.
    */
export function adjustOffsetForTimes(oldDate: Date, newDate: Date, applicationDate?: Date): Date;
/**
    * Gets the offset of the date passed in.
    *
    * @param date The Date object for which the offset is required.
    * @param defaultToUtcOffset A value indicating whether the server side set utc offset should be returned if no offset for date is returned.
    */
export function getOffsetForDate(date: Date): number;
/**
    * Checks whether given day is today in user timezone
    *
    * @param date The Date object to check
    */
export function isGivenDayToday(date: Date): boolean;
/**
    * Checks whether given day is a day in past in user timezone
    *
    * @param date The Date object to check
    */
export function isGivenDayInPast(date: Date): boolean;
/**
    * Checks whether given day is a day in future in user timezone
    *
    * @param date The Date object to check
    */
export function isGivenDayInFuture(date: Date): boolean;
/**
    * Get a user friendly string for a date that indicates how long ago the date was. e.g. "4 hours ago", "Tuesday", "7/4/2012".
    *
    * @param date The Date object to format
    * @param now
    * @return A string version of the date.
    */
export function friendly(date: Date, now?: Date): string;
}
declare module "VSS/Utils/Draggable" {
/// <amd-dependency path="jQueryUI/draggable" />
export {};
}
declare module "VSS/Utils/File" {
/**
* File encoding values.
*/
export enum FileEncoding {
    Unknown = 0,
    Binary = 1,
    ASCII = 2,
    UTF8 = 3,
    UTF32_BE = 4,
    UTF32_LE = 5,
    UTF16_BE = 6,
    UTF16_LE = 7
}
export function tryDetectFileEncoding(base64Content: string): FileEncoding;
/**
* Combine 2 path segments using the given separator ("/" is the default)
*
* @param path1 First path segment
* @param path2 Second path segment
* @param pathSeparator Optional path separator ("/" is the default)
* @return combined string
*/
export function combinePaths(path1: string, path2: string, pathSeparator?: string): string;
/**
* Ensure that the given path ends with a separator. If not, add the separator to the end.
*
* @param path Path to verify
* @param pathSeparator Optional path separator ("/" is the default)
* @return resulting string that ends with the separator
*/
export function ensureTrailingSeparator(path: string, pathSeparator?: string): string;
/**
 * Get parts of a path.
 *
 * @param path Path to extract parts.
 * @param pathSeparator Path separator (default '/').
 */
export function getPathParts(path: string, pathSeparator?: string): string[];
export function getRootDirectory(path: string, pathSeparator?: string): string;
/**
 * Gets the directory part of the specified path.
 *
 * @param path Path to extract directory name.
 * @param pathSeparator Path separator (default '/').
 * @returns {string}
 */
export function getDirectoryName(path: string, pathSeparator?: string): string;
/**
 * Gets the filename part of the specified path.
 *
 * @param path Path to extract file name.
 * @param pathSeparator Path separator (default '/').
 * @returns {string}
 */
export function getFileName(path: string, pathSeparator?: string): string;
/**
 * Normalize a path by using correct slash characters, removing duplicate slashes, and trimming trailing slashes
 * @param path The path to normalize
 * @param useBackslash Normalize to a backslash path if true. @default false
 */
export function normalizePath(path: string, useBackslash?: boolean): string;
}
declare module "VSS/Utils/Html" {
export module HtmlNormalizer {
    /**
     * Normalizes the given html by removing the attributes like script and fixing incomplete tags.
     *
     * @param html Html to normalize.
     * @return {string}
     */
    function normalize(html: string): string;
    /**
     * Normalizes the given html by removing the attributes like script and fixing incomplete tags.
     * Also allows the caller to specify additional attributes to remove, like 'class'
     *
     * @param html Html to normalize
     * @param additionalInvalidAttributes Additional attributes to remove
     * @param additionalValidAttributes Additional attributes to keep
     * @param additionalInvalidStyles Additional styles to remove
     * @param additionalValidStyles Additional styles to keep
     * @param encodeUnknownText
     * @param additionalInvalidProtocols Specify what link protocols to block (eg data to stop embedded images that may contain malicious content)
     * @return {string}
     */
    function normalizeStripAttributes(html: string, additionalInvalidAttributes: string[], additionalValidAttributes?: string[], additionalInvalidStyles?: string[], additionalValidStyles?: string[], encodeUnknownText?: boolean, additionalInvalidProtocols?: string[]): string;
    /**
     * Sanitizes the specified HTML by removing also all formatting.
     *
     * @param html Html to sanitize and remove formatting.
     * @return {string}
     */
    function removeFormatting(html: string): string;
    /**
     * Sanitizes the given html by fixing incomplete tags and encoding unsafe text.
     *
     * @param html Html to sanitize.
     * @return {string}
     */
    function sanitize(html: string): string;
    /**
     * Removes all tags from the specified html and attempts keep newlines in the proper places (best effort).
     *
     * @param html Html to convert to plain text.
     * @returns {string}
     */
    function convertToPlainText(html: string): string;
}
export class TemplateEngine {
    /**
     * Replaces simple tokens, such as ${Foo}, in the input HTML template.
     *
     * @param template The HTML markup or text to use as a a template.
     * @param data The data to render.
     * @return The HTML string with template replacements.
     */
    private static _replaceSimpleTemplateTokens;
    /**
     * Replaces simple tokens which will not be HTML encoded, such as {{html Foo}}, in the input HTML template.
     *
     * @param template The HTML markup or text to use as a a template.
     * @param data The data to render.
     * @return The HTML string with template replacements.
     */
    private static _replaceUnencodedTemplateTokens;
    /**
     * Replaces foreach style tokens, such as {{each Foo}}, in the input HTML template.
     *
     * @param template The HTML markup or text to use as a a template.
     * @param data The data to render.
     * @return The HTML string with template replacements.
     */
    private static _replaceForEachTemplateTokens;
    /**
     * Replaces a Regex match within some text with a replacement.
     *
     * @param text The original text.
     * @param match A regex match within that text.
     * @param replacement The replacement string.
     * @return The updated string.
     */
    private static _replaceMatch;
    private static _getEncodedTextPropertyValue;
    private static _getTextPropertyValue;
    /**
     * Obtains a value from a given data object using a string property path.
     *
     * @param data An object.
     * @param propertyPath A dot separrated property path. Undefined or empty string returns the plain data object.
     * @return The resolved data property value or undefined if property was not found.
     */
    private static _getPropertyValue;
    /**
     * A poor man's implementation of $.tmpl() from jquery templates. Renderes the
     * specified HTML content as a template, using the specified data.
     *
     * @param template The HTML markup or text to use as a a template.
     * @param data The data to render.
     * @return A jquery element.
     */
    static tmpl(template: string, data: any): string;
    /**
     * A static template engine for applying JS objects to a "jquery-tmpl" like template.
     */
    constructor();
}
export module Utils {
    const ISEMPTY_MINIMAL_CONTENT_LENGTH = 500;
    /**
     * Checks whether html is visually empty.
     * 1. Not empty if content length is over the minimal threshold. See ISEMPTY_MINIMAL_CONTENT_LENGTH.
     * 2. If content length is less than the minimal threshold, we remove the formatting before checking whether it matches any "empty" case.
     */
    function isEmpty(value: string): boolean;
}
}
declare module "VSS/Utils/HtmlTableFormatter" {
export interface IHtmlTableFormatterColumn {
    /**
     * Index of the column
     */
    index: number;
    /**
     * Name of the column
     */
    name: string;
    /**
     * True to disable HTML encoding and treat cell values of the column as HTML (default is treat as text)
     */
    isValueHtml?: boolean;
}
export interface ITableFormatterOptions {
    /**
     * Optional HTML text to extend at the end.
     */
    extendedHtml?: string;
}
export class HtmlTableFormatter {
    protected _rows: string[][];
    protected _columns: IHtmlTableFormatterColumn[];
    protected _options?: ITableFormatterOptions;
    private static readonly HEADER_BACKGROUND_COLOR;
    private static readonly HEADER_COLOR;
    private static readonly FONT_SIZE;
    private static readonly FONT_FAMILY;
    private static readonly BORDER_COLLAPSE;
    private static readonly COLUMN_BORDER;
    private static readonly COLUMN_VERTICAL_ALIGN;
    private static readonly COLUMN_PADDING;
    private static readonly ROW_BACKGROUND_COLOR;
    private static readonly ROW_ALT_BACKGROUND_COLOR;
    private static readonly COLUMN_STYLE;
    private static readonly HEADER_STYLE;
    private static readonly TABLE_STYLE;
    constructor(_rows: string[][], _columns: IHtmlTableFormatterColumn[], _options?: ITableFormatterOptions);
    protected _getCellValue(rowIndex: number, column: IHtmlTableFormatterColumn): string;
    private _getSafeCellValue;
    /**
     * Iterates through the rows and builds a HTML table containing the results.
     * @return HTML table containing all rows and all columns
     */
    getHtml(): string;
}
}
declare module "VSS/Utils/Mobile" {
export enum MobileOperatingSystem {
    iOS = 0,
    Android = 1,
    WindowsPhone = 2,
    Other = 3
}
export function getMobileOperatingSystem(): MobileOperatingSystem;
/**
* Determines if the mobile OS supports the left to right and right to left swipe for
* navigating back and forward in history
*/
export function isNavigationSwipeSupported(): boolean;
}
declare module "VSS/Utils/Number" {
import Culture = require("VSS/Utils/Culture");
/**
    * @param a
    * @param b
    * @return
    */
export function defaultComparer(a: any, b: any): number;
/**
    * Converts this number to a string in the current culture's locale
    * without specifying a precision. So, for example, with Spanish culture,
    * (3) gets translated to "3", and (3.1416) becomes "3,1416". The jQuery's
    * localeFormat requires a precision (the default is "2" if not specified).
    * So 3.localeFormat("N") become "3,00".
    *
    * @param num  The Number to format
    * @param includeGroupSeparators If true, use locale-specific
    * group separators (i.e. 3,000) in the output
    * @param cultureInfo Culture info (CurrentCulture if not specified)
    * @return
    */
export function toDecimalLocaleString(num: number, includeGroupSeparators?: boolean, cultureInfo?: Culture.ICultureInfo): string;
/**
    * @param value
    * @return
    */
export function isPositiveNumber(value: any): boolean;
/**
    * @param value
    * @return
    */
export function parseLocale(value: string): number;
/**
    * @param value
    * @return
    */
export function parseInvariant(value: string): number;
/**
    * @param value
    * @param format
    * @return
    */
export function localeFormat(value: number, format: string): string;
/**
 * Format a given number to the AbbreviatedShortForm with the given locale.
 * For example (US) 10,000 -> 10k ; 9,200 -> 9.2K (JA) 10,000 -> 1万 ; 9,200 -> 9.2千
 * @param count - the number to format with
 * @param cultureInfo - the cultureInfo, use user's default if not given.
 */
export function formatAbbreviatedNumber(count: number, cultureInfo?: Culture.ICultureInfo): string;
}
declare module "VSS/Utils/Object" {
/**
 * Describes the behavior to use in a deep merge when the source and target
 * both have the same property which is an array. Either take the source array
 * or combine the two arrays
 */
export const enum MergeArrayOptions {
    /**
     * When a source property is an array, override the target property with
     * the source array.
     */
    replace = 0,
    /**
     * When a source property and its target property are both arrays, concatenate
     * the values in the source array into the target array.
     */
    concat = 1
}
/**
 * Options when performing a deep merge
 */
export interface IMergeOptions {
    /**
     * Describes the behavior to use in a deep merge when the source and target
     * both have the same property which is an array. Either take the source array
     * or combine the two arrays
     */
    arrayOptions?: MergeArrayOptions;
    /**
     * If true, clone all objects including their child/descendant properties when
     * merging values into the new object. Ensures that no properties in the resulting merged
     * object (including sub-properties, recursively) are "===" to any objects in the source.
     */
    deepClone?: boolean;
}
/**
 * Performs a deep merge of the given source objects into the target. The sources are merged-in left-to-right.
 * So for properties with collisions, the right-most value "wins". Clones all properties and sub-properties
 * recursively so that no objects referenced in the resulting target are "===" to objects in the sources.
 *
 * Specifically works on standard JSON objects, not classes/functions with property accessors, etc.
 *
 * @param target The target object to merge values into
 * @param sources Source objects to merge into the target
 * @returns The target parameter
 */
export function deepMerge(target: any, ...sources: any[]): any;
/**
 * Performs a deep merge of the given source objects into the target. The sources are merged-in left-to-right.
 * So for properties with collisions, the right-most value "wins".
 *
 * Specifically works on standard JSON objects, not classes/functions with property accessors, etc.
 *
 * @param options Options describing the merge behavior
 * @param target The target object to merge values into
 * @param sources Source objects to merge into the target
 * @returns The target parameter
 */
export function deepMergeWithOptions(options: IMergeOptions, target: any, ...sources: any[]): any;
}
declare module "VSS/Utils/String" {
import Culture = require("VSS/Utils/Culture");
export var EmptyGuidString: string;
export var empty: string;
export var newLine: string;
export var tab: string;
export var lineFeed: string;
/**
    * 		HTML Encodes the string. Use this method to help prevent cross site scripting attacks
    *     by cleaning text which may contain HTML elements before the string is display in a web page.
    *
    *
    * @param str The string to be encoded
    * @return A copy of the current string which has been HTML encoded
    */
export function htmlEncode(str: string): string;
/**
    * 		HTML Encodes the string. Use this method to help prevent cross site scripting attacks
    *     by cleaning text which may contain HTML elements before the string is display in a web page.
    *     Does not encode single quotes.
    *
    *
    * @param str The string to be encoded
    * @return A copy of the current string which has been HTML encoded
    */
export function htmlEncodeJavascriptAttribute(str: string): string;
/**
    * 		HTML Decodes the string.
    *
    *
    * @param str The string to be decoded
    * @return A copy of the current string which has been HTML decoded
    */
export function htmlDecode(str: string): string;
/**
    * 		HTML Decodes the string.
    *
    *
    * @param str The string to be decoded
    * @return
    *    A copy of the current string which has been HTML decoded.
    *    > < etc are converted back to HTML form(<, > etc)
    *
    */
export function decodeHtmlSpecialChars(str: string): string;
/**
    * 		HTML encodes the string and replaces newlines with HTML break tags.
    * 		Use this method to maintain line breaks when displaying strings.
    *
    *
    * @param str The string to be encoded.
    * @return A copy of the current string which has been HTML encoded
    */
export function nl2br(str: string): string;
/**
*	returns a string with the first letter as UpperCase and the rest lower case
*   Assumes the string is trimmed (no leading white-space) and starts with a valid character
*   if the first char is not an alphabet, no char will be made upper case
* @param str  The string to be converted.</param>
* @return A copy of the current string which has been sentence cased
*/
export function toSentenceCase(str: string): string;
/**
    * @param a
    * @param b
    * @return
    */
export function defaultComparer(a: string, b: string): number;
/**
    * @param a
    * @param b
    * @return
    */
export function ignoreCaseComparer(a: string, b: string): number;
/**
    * @param a
    * @param b
    * @return
    */
export function localeComparer(a: string, b: string): number;
/**
    * @param a
    * @param b
    * @return
    */
export function localeIgnoreCaseComparer(a: string, b: string): number;
/**
* Compares 2 strings for equality.
*
* @param a First string to compare
* @param b Second string to compare
* @param ignoreCase If true, do a case-insensitive comparison.
*/
export function equals(a: string, b: string, ignoreCase?: boolean): boolean;
/**
    * @param str
    * @param prefix
    * @param comparer
    * @return
    */
export function startsWith(str: string, prefix: string, comparer?: IComparer<string>): boolean;
/**
    * @param str
    * @param suffix
    * @param comparer
    * @return
    */
export function endsWith(str: string, suffix: string, comparer?: IComparer<string>): boolean;
/**
    * @param str
    * @param subStr
    * @return
    */
export function caseInsensitiveContains(str: string, subStr: string): boolean;
/**
    * @param format
    * @param args
    * @return
    */
export function format(format: string, ...args: any[]): string;
/**
    * @param format
    * @param args
    * @return
    */
export function localeFormat(format: string, ...args: any[]): string;
export function dateToString(value: Date, useLocale?: boolean, format?: string): string;
export function numberToString(value: number, useLocale?: boolean, format?: string): string;
export function parseDateString(value: string, cultureInfo?: Culture.ICultureInfo, formats?: string[]): Date;
export function containsControlChars(str: string): boolean;
export function containsMismatchedSurrogateChars(str: string): boolean;
/**
    *  Base64 encodes the string. Uses the native version if available.
    *  @param s The string that should be encoded.
    *  @return The string in base64 encoding.
    */
export function base64Encode(s: string): string;
export function isGuid(str: string): boolean;
export function isEmptyGuid(str: string): boolean;
/** Returns a new, pseudo-random uid */
export function generateUID(): string;
/**
* Result from a singleSplit operation
*/
export interface ISingleSplitResult {
    /**
    * The part of the string before the split (or the original string if no match)
    */
    part1: string;
    /**
    * The segment of the string after the split
    */
    part2: string;
    /**
    * Whether or not the separator was found in the string
    */
    match: boolean;
}
/**
* Split a string into 2 parts by finding the first (or optionally, last) match of a given separator.
* This is close to the C# String.Split API using 2 as the "count". In javascript, supplying the count ignores everything
* in the string after that number of segments. For example calling "a b c".split(" ", 2) returns ["a", "b"] where in C#
* this would return ["a", "b c"]. This method works like the C# version where singleSplit("a b c", " ") will return
* { part1: "a", part2: "b c"}.
*
* @param value The string to split
* @param separator The separator string to split on
* @param ignoreCase Optional parameter to ignore case of the separator
* @param lastMatch If true, search in the reverse direction (find the last instance of the separator). By default, the first instance of the separator is used.
*/
export function singleSplit(value: string, separator: string, ignoreCase?: boolean, lastMatch?: boolean): ISingleSplitResult;
export class StringBuilder {
    private _textBuilder;
    /**
     * Utility class for building strings - similar to the System.Text.StringBuilder .NET class.
     *
     * @param initialText The initial text for the builder
     */
    constructor(initialText?: string);
    /**
     * Appends the specified text to the end of the string buffer.
     *
     * @param text The text to append.
     */
    append(text: string | any): void;
    /**
     * Appends a new-line to the current text buffer.
     */
    appendNewLine(): void;
    /**
     * Concatenates all text in the string buffer into a single string value.
     *
     * @return The string version of the accumulated text.
     */
    toString(): string;
}
}
declare module "VSS/Utils/Tree" {
/**
 * Traverse a given tree pre-order
 * @param root Root node of tree
 * @param getChildren Given a tree node, returns its children
 * @param visitor Callback to be called for each node in the tree, in order. If visitor returns false, children of the current node will not be traversed.
 */
export function traversePreOrder<TNode>(root: TNode, getChildren: (node: TNode) => TNode[], visitor: (node: TNode, parentNode?: TNode, level?: number, childrenCount?: number) => boolean | void): void;
/** Result of a `filterTree` operation. */
export interface IFilterResult {
    /** Map of nodes included as part of the  */
    [key: string]: {
        /** Node matches the filter predicat */
        isPredicateMatch: boolean;
        /** Node has a matching descendant */
        hasMatchingDescendant: boolean;
    };
}
/**
 * Filters a given tree by a given predicate. The result of this operation will include
 * - all nodes that match the predicate (`isPredicateMatch` set to true)
 * - all nodes that have a predicate matching descendant (`hasMatchingDescendant` set to true)
 * - all descendants of predicate matching nodes.
 *
 * Example (* denotes predicate matching nodes):
 *       R
 *     / | \
 *    A* X  B
 *    |  |  |
 *    C  Y  D*
 *
 * Result set (isPredicateMatch iPM, hasMatchingDescendant hMD):
 * Node | hMD | iPM
 *  R      x
 *  A            x
 *  C
 *  B      x
 *  D            x
 *
 * @param root Root node of tree to filter
 * @param predicate Filter predicate
 * @param getKey Given a tree node, returns a unique identifier
 * @param getChildren Given a tree node, returns its children
 * @param preFilter Previous filter result, any node that didn't match previously will not be considered again
 */
export function filterTree<TNode>(root: TNode, predicate: (node: TNode) => boolean, getKey: (node: TNode) => string, getChildren: (node: TNode) => TNode[], preFilter?: IFilterResult): IFilterResult;
}
declare module "VSS/Utils/UI" {
import "jQueryUI/core";
export function getWheelDelta(e?: any): number;
/**
 * @param element
 * @param enable
 */
export function enableElement(element: Element | JQuery, enable: boolean): void;
export function makeElementUnselectable(element: any): void;
/**
 * Best-effort attempt to set focus on the specified element. Exceptions will be caught and logged to console.
 *
 * @param element Element to set focus on (DomElement or jQuery element)
 * @param delay Optional delay in ms before calling focus
 */
export function tryFocus(element: any, delay?: number): void;
export function alignWidth(element: any, baseWidth: any): void;
/**
* Is the given element in the DOM hierarchy
*
* @param element Element to check if it exists somewhere in the current document
*/
export function isInDomTree(element: any): boolean;
export function getCustomData(element: any, key: any): any;
export enum KeyCode {
    ALT = 18,
    BACKSPACE = 8,
    CAPS_LOCK = 20,
    COMMA = 188,
    CONTROL = 17,
    DELETE = 46,
    DOWN = 40,
    END = 35,
    ENTER = 13,
    ESCAPE = 27,
    HOME = 36,
    INSERT = 45,
    LEFT = 37,
    PAGE_DOWN = 34,
    PAGE_UP = 33,
    PERIOD = 190,
    RIGHT = 39,
    SEMI_COLON = 186,
    FIREFOX_SEMI_COLON = 59,
    SHIFT = 16,
    SPACE = 32,
    TAB = 9,
    UP = 38,
    F1 = 112,
    F2 = 113,
    F6 = 117,
    F10 = 121,
    IME_INPUT = 229,
    M = 77,
    N = 78,
    P = 80,
    Q = 81,
    S = 83,
    E = 69,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    T = 84,
    U = 85,
    QUESTION_MARK = 191,
    CONTEXT_MENU = 93
}
export module KeyUtils {
    /**
     * Check if only the ctrl key modifier was pressed.
     *
     * @param e The event object.
     */
    function isExclusivelyCtrl(e: JQueryKeyEventObject): boolean;
    /**
     * Check if any modifier keys were pressed
     *
     * @param e The event object.
     */
    function isModifierKey(e: JQueryKeyEventObject): boolean;
    /**
     * Check if only Meta is pressed on Mac/OSX or if Ctrl is pressed on Windows. This
     * should generally be used unless you have a specific reason to not use the key that
     * is expected on a Mac.
     *
     * @param e The event object.
     */
    function isExclusivelyCommandOrMetaKeyBasedOnPlatform(e: JQueryKeyEventObject | KeyboardEvent): boolean;
    /**
     * Determines if we are running in an OS that prefers use of Meta key instead of Control key.
     * MacOSx and IOS prefer Meta, Windows/Linux prefer Control
     */
    function shouldUseMetaKeyInsteadOfControl(): boolean;
}
export module Constants {
    var HtmlNewLine: string;
    var BlurTimeout: any;
}
/**
 * @param tagName
 * @param className
 */
export function domElem(tagName: string, className?: string): HTMLElement;
export function htmlEncode(input: any): any;
export module Positioning {
    enum VerticalScrollBehavior {
        Default = 0,
        Top = 1,
        Middle = 2,
        Bottom = 3
    }
    interface IPositionOptions {
        /**
         * where to align the element (horizontal-vertical)
         */
        elementAlign?: string;
        /**
         * where to align the element against base element (horizontal-vertical)
         */
        baseAlign?: string;
        /**
         * behavior when the element overflows the window (horizontal-vertical)
         */
        overflow?: string;
        /**
         * flag to specify that markers should be used to horizontally align the elements rather than the elements themselves.
         */
        alignToMarkerHorizontal?: boolean;
        /**
         * flag to specify that markers should be used to vertically align the elements rather than the elements themselves.
         */
        alignToMarkerVertical?: boolean;
        /**
         * jQuery object inside the element that should be aligned with the base
         */
        elementAlignmentMarker?: JQuery;
        /**
         * jQuery object inside the base element that should be aligned with the element
         */
        baseAlignmentMarker?: JQuery;
        /**
         * Indicates whether the scroll should by browser window or the specified marker or not.
         */
        scrollByMarker?: boolean;
        /**
         * how much extra left offset (if any) should be given to the target element versus the reference element.
         */
        leftOffsetPixels?: number;
        /**
         * how much extra top offset (if any) should be given to the target element versus the reference element.
         */
        topOffsetPixels?: number;
        supportScroll?: boolean;
        /**
         * prevent setting z-index on the target element
         */
        skipZIndexSetting?: boolean;
    }
    interface ILocation {
        left: number;
        top: number;
        width?: number;
        height?: number;
    }
    function _topOverflow(top: any): number;
    function _bottomOverflow(bottom: any): number;
    function _fitHorizontal(position: JQueryCoordinates, data: {
        leftOffsetPixels?: number;
        elementMeasure: number;
        adjustedWidth: number;
    }): void;
    function _flipHorizontal(position: JQueryCoordinates, data: {
        baseMeasure: number;
        elementMeasure: number;
        elementAlign: string;
        adjustedWidth: number;
    }): void;
    /**
     * Tries to fit the positioned element by using the base element if any overflow exists.
     * If still overflow exists after flipping, it shrinks the element where it best fits.
     */
    function _fitVertical(position: JQueryCoordinates, data: any): {
        top: any;
        shrink: number;
    };
    /**
     * Tries to flip the positioned element by using the base element if any overflow exists.
     * If still overflow exists after flipping, it shrinks the element where it best fits.
     */
    function _flipVertical(position: JQueryCoordinates, data: {
        elementMeasure: number;
        baseMeasure: number;
        elementAlign: string;
        baseAlign: string;
    }): {
        top: number;
        shrink: number;
    };
    /**
     * Positions the given element at a location, making sure it fits on screen.
     *
     * @param element The element to position
     * @param location The location to position the element at
     * @param options Options for positioning
     */
    function positionAtLocation(element: any, location: ILocation, options?: IPositionOptions): void;
    /**
     * Positions the given element by taking the given base element
     * as a reference using the options provided
     *
     * @param element Element to position
     * @param baseElement Reference element for positioning
     * @param options Options for positioning
     */
    function position(element: any, baseElement: any, options?: IPositionOptions): void;
    /**
     * Get the first parent of the given element that allows scrolling
     *
     * @param $element Element to scroll into view
     */
    function getVerticalScrollContainer($element: JQuery): JQuery;
    /**
     * Sets the scroll (top) position of the $container element so that the $element is visible.
     * This is a no-op if the element is already visible.
     *
     * @param $element Element to scroll into view
     * @param position The destination position of the element after scrolling (top, middle, bottom)
     * @param scrollIfAlreadyVisible
     *    If true, perform the scroll even if the element is already in view
     *
     * @param scrollAnimationDuration
     *    If true, scroll with animation using the given animation time
     *
     */
    function scrollIntoViewVertical($element: JQuery, position?: Positioning.VerticalScrollBehavior, scrollIfAlreadyVisible?: boolean, scrollAnimationDuration?: number): void;
}
export function attachResize(element: any, handler: (e: JQueryEventObject, args?: any) => void): void;
export function detachResize(element: any): void;
export function clearResizeHandlers(): void;
export interface SelectionRange {
    $startNode: JQuery;
    $endNode: JQuery;
    startNodeOffset: number;
    endNodeOffset: number;
}
export interface IBrowserInformation {
    msie?: boolean;
    edge?: boolean;
    chrome?: boolean;
    safari?: boolean;
    mozilla?: boolean;
    webkit?: boolean;
    version?: string;
    isWindows?: boolean;
    isMacintosh?: boolean;
    iOS?: boolean;
}
export module BrowserCheckUtils {
    function isFirefox(): boolean;
    function isChrome(): boolean;
    function isSafari(): boolean;
    function isMozilla(): boolean;
    /**
     * Returns true if browser is Internet Explorer 10 or earlier.
     */
    function isMsie(): boolean;
    /**
     *  Returns true if the browser is Internet Explorer
     */
    function isIE(): boolean;
    function isEdge(): boolean;
    function getVersion(): string;
    function isIEVersion(version: number): boolean;
    function isLessThanOrEqualToIE9(): boolean;
    function isLessThanOrEqualToIE8(): boolean;
    function isMacintosh(): boolean;
    function isWindows(): boolean;
    function isIOS(): boolean;
}
export module SelectionUtils {
    function getSelection(): SelectionRange;
    function selectInputText($input: JQuery, startPosition: number, endPosition: number, focus: boolean): void;
}
export module HtmlInsertionUtils {
    function pasteHtmlAtCaret(html: string, parentWindow?: Window): void;
}
export interface ISectionManager {
    identifySections: () => void;
    nextSection: () => boolean;
    previousSection: () => boolean;
}
export var sectionManager: ISectionManager;
export interface IFilterGroup {
    start: number;
    end: number;
    level: number;
}
export function updateFilterGroups(groups: IFilterGroup[], clauseNumber: number, insert: boolean): IFilterGroup[];
export function updateFilterGroupLevels(groups: IFilterGroup[]): number;
export function findTreeNode(path: string, separator: string, comparer: IComparer<string>, textField: string): any;
export function calculateTreePath(includeRoot: boolean, separator: string, textField: string, rootField: string): string;
export function walkTree(f: IFunctionPPR<any, any, void>): void;
export function injectStylesheets(cssReferenceUrls: string[], baseUrl?: string): void;
/**
 * When user presses space or enter on element, execute click handler and then move keyboard
 * focus to the next visible and tabbable element on the page.
 * @param element
 * @param handler
 */
export function accessible(element: JQuery, handler?: Function): JQuery;
/**
 * Keydown handler that, when the user presses enter or spacebar, executes the click event handler.
 * @param e
 */
export function buttonKeydownHandler(e: JQueryEventObject): void;
/**
 * Returns true if the contents of the element overflow its visible bounds.
 * @param element
 */
export function contentsOverflow(element: HTMLElement | JQuery): boolean;
export interface ITooltipIfOverflowOptions {
    /**
     * titleTarget element which will get the tooltip, and whose text will be used to populate the tooltip, only need specify if different than element argument passed in to tooltipIfOverflow()
     */
    titleTarget?: HTMLElement | HTMLInputElement;
    /**
     * element that generates the mouseenter, mouseleave, focus, and blur events we should listen for
     */
    eventSource?: HTMLElement;
    /**
     * titleText text to set the title to, otherwise use the titleTarget's .text() or .val()
     */
    titleText?: string;
    /**
     * Function that will add the tooltip on mouseenter or focus (default is to add title attribute).
     * The options object passed to this function will have titleTarget and titleText set to the correct values to use.
     */
    addTooltipDelegate?: (e: MouseEvent | FocusEvent, options: ITooltipIfOverflowOptions) => void;
    /**
     * Function that removes the tooltip on mouseleave or blur
     */
    removeTooltipDelegate?: (e: MouseEvent | FocusEvent, options: ITooltipIfOverflowOptions) => void;
}
/**
 * Show a tooltip on hover, only if the text of the element overflows the visible area.
 * @param element element with text-overflow set
 * @param options
 *
 */
export function tooltipIfOverflow(element: HTMLElement | HTMLInputElement, options?: ITooltipIfOverflowOptions): void;
/**
 * Gets the overflow element using the specified element or its children and grandchildren (optionally).
 *
 * @param elem DOM element to check the overflow.
 * @param recursive Determines whether to go deeper with children and grandchildren or not.
 */
export function getOverflowElement(elem: HTMLElement, recursive?: boolean): HTMLElement;
export function Watermark(element: JQuery, ...args: any[]): JQuery;
/**
 * Gets the global focus ring element. Messing with this element could break
 * focus in other UI.
 */
export function getFocusRing(): HTMLElement;
/**
 * Hides the global focus ring. It can only be shown again with a focus event
 */
export function hideFocusRing(): void;
/**
 * Gets a handler that is intended to be executed on a focus event. This handler
 * draws a box around the focused element if it is focused via the keyboard.
 * @param keyCodes List of keycodes that could lead to this focus event being called.
 * @param ringSize Size of the ring to draw around the focused element.
 */
export function getFocusRingFocusHandler(keyCodes?: number[], ringSize?: number): (event: FocusEvent) => void;
}
declare module "VSS/Utils/Url" {
export const MAX_URL_PATH_LENGTH = 2000;
/**
 * Check if specified URL is safe - i.e. part of an approved list of URL schemes.
 *
 * @param url Url to check.
 * @returns {boolean}
 */
export function isSafeProtocol(url: string): boolean;
/**
 * Return a new url that adds (if the given parameter name does not exist in the url),
 * or replaces the value of given parameter name with the given parameter value.
 *
 * @param url The original url.
 * @param paramName The parameter name to replace in the url.
 * @param paramValue The parameter value to replace in the url.
 * @returns {string}
 */
export function replaceUrlParam(url: string, paramName: string, paramValue: string): string;
/**
 * Verifies that the given url is within the constraints of 2000 characters.
 *
 * @param url The url to verify.
 * @returns {boolean}
 */
export function isUrlWithinConstraints(url: string): boolean;
export class UrlTranslatorService {
    private _urlTranslators;
    /**
     * Registers a URL translator function.
     *
     * @param translatorFunction The translator function of the form function(url, options, successCallback, errorCallback, nextTranslator){}
     * @param order The order of the translator function.
     */
    registerUrlTranslator(translatorFunction: Function, order?: number): void;
    beginTranslateUrl(url: string, options?: any, callback?: IFunctionPR<string, any>, errorCallback?: IErrorCallback): void;
}
export function getTranslatorService(): UrlTranslatorService;
/**
 * Extract query parameters as a dictionary
 */
export function getQueryParameters(url: string): IDictionaryStringTo<string>;
/**
* A single query parameter entry in a Uri
*/
export interface IQueryParameter {
    /**
    * Unencoded name of the query parameter
    */
    name: string;
    /**
    * Unencoded value of the query parameter
    */
    value: string;
    /**
     * Determines if this query paramter contains a empty value part ("a=").
     * We use this information to ensure we can recreate the same string. This
     * allows us to tell the different between this "a&b&c" versus "a=&b=&c=" which
     * matters to some customers.
     */
    hasEmptyValuePart?: boolean;
}
/**
* Options for parsing a Uri string
*/
export interface IUriParseOptions {
    /**
    * If true, throw if the Uri is not absolute
    */
    absoluteUriRequired?: boolean;
}
/**
* Class that represents a Uri and allows parsing/getting and setting of individual parts
*/
export class Uri {
    /**
    * The uri scheme such as http or https
    */
    scheme: string;
    /**
     * If true, do not emit the "//" separator after the scheme:
     * Set to true for schemes like mailto (e.g. mailto:foo@bar)
     */
    noSchemeSeparator: boolean;
    /**
    * The uri hostname (does not include port or scheme)
    */
    host: string;
    /**
    * The port number of the uri as supplied in the url. 0 if left out in the url (e.g. the default port for the scheme).
    */
    port: number;
    /**
    * The relative path of the uri
    */
    path: string;
    /**
    * The array of query parameters in the uri
    */
    queryParameters: IQueryParameter[];
    /**
    * The hash string of the uri
    */
    hashString: string;
    /**
    * Parse a uri string into a Uri member
    *
    * @param uri Uri string to parse
    * @param options Options for parsing the uri string
    */
    static parse(uri: string, options?: IUriParseOptions): Uri;
    /**
    * Create a new Uri.
    *
    * @param uri Optional uri string to populate values with
    */
    constructor(uri?: string);
    private _setFromUriString;
    private _decodeUriComponent;
    /**
    * Get the absolute uri string for this Uri
    */
    /**
    * Set the absolute uri string for this Uri. Replaces all existing values
    */
    absoluteUri: string;
    /**
     * Gets the effective port number, returning the default port number if omitted for the given scheme.
     */
    getEffectivePort(): number;
    /**
    * Get the query string for this Uri.
    */
    /**
    * Set the query string for this Uri. Replaces existing value
    */
    queryString: string;
    /**
    * Get the value of the query parameter with the given key
    *
    * @param name Query parameter name
    */
    getQueryParam(name: string): string;
    /**
    * Adds a query string parameter to the current uri
    *
    * @param name The Query parameter name
    * @param value The Query parameter value
    * @param replaceExisting If true, replace all existing parameters with the same name
    */
    addQueryParam(name: string, value: string, replaceExisting?: boolean): void;
}
/**
 * Determines whether the specified URL is absolute or not.
 *
 * @param url Url to check.
 * @returns {boolean}
 */
export function isAbsoluteUrl(url: string): boolean;
/**
 * Do the given urls have the same origin (scheme, host and port)
 *
 * @param url1 First url to check
 * @param url2 Second url to check
 */
export function isSameOrigin(url1: string, url2: string): boolean;
/**
 * Combines 2 url paths. If 'url' is an absolute url, then it is returned
 * without attempting to prepend baseUrl.
 *
 * @param baseUrl The root url that the resulting url should start with
 * @param url If a relative url, it is appended to baseUrl (with a "/" separator). If absolute, it is returned as-is.
 */
export function combineUrl(baseUrl: string, url: string): string;
/**
 * Checks if specified URL is an external URL to the current window.
 * If relative URL is provided - returns false.
 * @param url Url to check
 */
export function isExternalUrl(url: string): boolean;
/**
 * Represents a route parsed by parseRoute
 */
export interface IParsedRoute {
    /**
     * Array of the segements in the route
     */
    segments: IParsedRouteSegment[];
}
/**
 * And individual segment of the route (fixed text or a parameter)
 */
export interface IParsedRouteSegment {
    /**
     * If present, the fixed text for this segement. Either text or paramName will be defined for a segment, never both.
     */
    text?: string;
    /**
     * If present, the name of the route value parameter to substitute for this segment. Either text or paramName will be defined for a segment, never both.
     */
    paramName?: string;
    /**
     * For parameters, whether or not this parameter is a wildcard (*) parameter, which means it allows multiple path segments (i.e. don't escape "/")
     */
    isWildCardParam?: boolean;
    /**
     * Whether the parameter is required in order for the URL to be valid.
     */
    isRequiredParam?: boolean;
}
/**
 * Parse a route template into a structure that can be used to quickly do route replacements
 *
 * @param routeTemplate MVC route template string (like "/foo/{id}/{*params}")
 */
export function parseRouteTemplate(routeTemplate: string): IParsedRoute;
/**
 * Take a set of routes and route values and form a url using the best match. The best match
 * is the route with the highest number of replacements (of the given routeValues dictionary).
 * In the event of a tie (same number of replacements) the route that came first wins.
 *
 * @param routeCollection Array of parsed routes
 * @param routeValues Replacement values
 */
export function routeUrl(routeCollection: IParsedRoute[], routeValues: {
    [name: string]: string;
}): string;
/**
 * Take a set of routes and find the best match. The best match is the route with the highest number of replacements
 * (of the given routeValues dictionary). In the event of a tie (same number of replacements) the route that came first wins.
 *
 * @param routeCollection Array of parsed routes
 * @param routeValues Replacement values
 */
export function getBestRouteMatch(routeCollection: IParsedRoute[], routeValues: {
    [name: string]: string;
}): IRouteMatchResult | undefined;
/**
 * Result of a call to replace route values for a parsed route
 */
export interface IRouteMatchResult {
    /**
     * Resulting URL from the template replacement. Does NOT include any query parameters that would be added from extra route values.
     */
    url: string;
    /**
     * Dictionary of the route value keys that were used as replacements
     */
    matchedParameters: {
        [key: string]: boolean;
    };
    /**
     * The number of parameter replacements made
     */
    matchedParametersCount: number;
}
/**
 * Replace route values for a specific parsed route
 *
 * @param parsedRoute The route to evaluate
 * @param routeValues Dictionary of route replacement parameters
 * @param continueOnUnmatchedSegements If true, continue with replacements even after a miss. By default (false), stop replacements once a parameter is not present.
 */
export function replaceParsedRouteValues(parsedRoute: IParsedRoute, routeValues: {
    [name: string]: string;
}, continueOnUnmatchedSegements?: boolean): IRouteMatchResult | undefined;
/**
 * Take an MVC route template (like "/foo/{id}/{*params}") and replace the templated parts with values from the given dictionary
 *
 * @param routeTemplate MVC route template (like "/foo/{id}/{*params}")
 * @param routeValues Route value replacements
 */
export function replaceRouteValues(routeTemplate: string, routeValues: {
    [name: string]: string;
}): string;
}
declare module "VSS/VSS" {
import Q = require("q");
export var uiCulture: string;
export var errorHandler: ErrorHandler;
export var globalProgressIndicator: GlobalProgressIndicator;
export var globalMessageIndicator: GlobalMessageIndicator;
export var activtyStatsCollector: ActivtyStatsCollector;
/**
 * @param data
 */
export function queueCallbacks(context: any, callback: IResultCallback, errorCallback: IErrorCallback, data?: any): IQueueCallbacksResult;
export interface IQueueCallbacksResult {
    cookie: number;
    count: IFunctionPR<void, number>;
    finish: IArgsFunctionR<void>;
    error: IArgsFunctionR<void>;
    register: (callback: IResultCallback, errorCallback: IErrorCallback, data: any) => number;
    unregister: (cookie: number) => void;
}
/**
 * Queues a request for a piece of data.  Handles situations where the data has already been
 * retrieved as well as when multiple requests are pending for the same data.  When the data has
 * already been retrieved, the successCallback will be invoked immediately.  When multiple
 * requests are pending for the same data, each of the callers will be notified when the data
 * request has been completed (worker will only be invoked once).
 *
 * Sample usage:  This will invoke the worker function using the current object as the context.  The "_teamSettings"
 *                property of the current object will be checked for a value before invoking the worker.  If the value
 *                needs to be looked up, the worker will be invoked and it will make a request for the data.  If the
 *                request is completed successfully the data is passed to the succeeded callback.  If there is an error
 *                with the request the failed callback is invoked.
 *
 *     queueRequest(this, this, "_teamSettings", successCallback, errorCallback,
 *         function (succeeded, failed) {
 *             Ajax.getMSJSON(url, null, function (teamSettings) {
 *                 succeeded(teamSettings);
 *             }, failed);
 *         });
 *
 * @param context The "this" that the worker and successCallback functions will be invoked with.
 * @param target
 * The object which the propName property should be checked on to see if the request has already been performed.
 * If the property has a value (that is not a function), then the success callback is invoked immediately with the properties value as the result.
 * If the property does not have a value, the request is processed and the result is stored in the property.
 *
 * @param propName Name of the property on the target to store the result in and check to see if the request is needed.
 * @param successCallback Function invoked when the request is completed.  The function should take the "result" as its first parameter.
 * @param errroCallback Function invoked when the request has completed with an error. The function should take the "error" as its first parameter.
 * @param worker
 * This is the which performs the work to retrieve the data.  The function should have the following signature:
 *     function worker(succeeded, failed)
 *
 * The worker should invoke the "succeeded" function that it is provided passing it the result.  If an error occurs the worker should invoke the
 * "failed" function with the error.
 *
 * NOTE: It is important to note that the "successCallback" is not the same as the "succeeded" callback provided to the worker
 *       function.  It is important for the worker to invoke the callbacks it is provided with rather than the callbacks which are
 *       provided to the queueRequest method.  The same holds true for the failed callback provided to the worker function.
 *
 */
export function queueRequest(context: any, target: any, propName: string, successCallback: IResultCallback, errorCallback: IErrorCallback, worker: IResultCallback): void;
/**
 * Checks if a queued request has been completed.
 *
 * @param cachedResult The property passed to queueRequest as target[propName]
 */
export function queuedRequestHasResult(cachedResult: any): boolean;
export function getErrorMessage(errorString: string): string;
export function getErrorMessage(errorFunction: Function): string;
export function getErrorMessage(error: Error): string;
export interface errorPublisher {
    publishError(error: TfsError): void;
}
export class ErrorHandler {
    $error: JQuery;
    visible: boolean;
    private _errorPublishers;
    /**
     * Global error handler class which is attached to TFS
     */
    constructor();
    /**
     * (Internal function) Initializes error handler
     */
    initialize(): void;
    private attachWindowErrorHandler;
    static readonly ignoreRejectedPromiseTag: string;
    private attachQPromiseErrorHandler;
    private publishError;
    /**
     * (Internal function) Checks whether error container exists or not
     */
    exists(): boolean;
    /**
     * (Internal function) Shows error in the container
     */
    showError(message: string, status?: string, stackTrace?: string): void;
    /**
     * (Internal function) Hides the error when clicked
     */
    hideError(): void;
    /**
     * Displays error in a container. If no container is found, error
     * message is displayed in an alert dialog
     */
    show(error: TfsError): void;
    /**
     * Add error publisher to ErrorHander class
     */
    attachErrorPublisher(errorPublisher: errorPublisher): void;
    /**
     * Remove error publisher to ErrorHander class
     */
    detachErrorPublisher(errorPublisher: errorPublisher): void;
}
/**
 * @param callback
 * @param context
 */
export function handleError(error: TfsError, callback?: IErrorCallback, context?: any): void;
/**Remove in M91 **/
export class ClientActivtyStatistic {
    name: string;
    id: string;
    parentId: string;
    startOffset: number;
    duration: number;
    constructor();
}
export class ActivtyStatistic {
    name: string;
    id: string;
    parentId: string;
    status: number;
    actionDate: Date;
    constructor();
}
export interface ActivtyStatsCollectionAllowedCallback {
    (): boolean;
}
export class ActivtyStatsCollector {
    static ACTIVITY_COLLECTION_STATUS: string;
    static ACTIVITY_ID_STORAGE_ITEM: string;
    static ACTIVITY_CLIENT_STATE_STORAGE_ITEM: string;
    static CURRENT_PAGE: string;
    /**
     * Global handler for logging activity data
     */
    constructor();
    addActivtyStatsCollectionAllowedCallback(activtyStatsCollectionAllowedCallback: ActivtyStatsCollectionAllowedCallback): void;
    actionStarted(name: string): number;
    actionCompleted(id: number, jqXHR: JQueryXHR): void;
    logActivity(activityId: string, page: string): void;
    getClientStatistics(): IDictionaryStringTo<ClientActivtyStatistic[]>;
    getActivtyStatistics(): ActivtyStatistic[];
    clearStats(): void;
    collectStats(shouldCollect: boolean): void;
    getCurrentPage(): ActivtyStatistic;
    setCurrentPage(currentPage: ActivtyStatistic): void;
    isCollectingStats(): boolean;
}
export class GlobalProgressIndicator {
    private _progressPendingActions;
    private _progressPendingActionsCount;
    private _progressPendingActionsNewId;
    private _pageProgressElements;
    private _pageProgressDelayShowTimeout;
    private _pageProgressMinShowTimeout;
    private _showingProgress;
    /**
     * Global handler for displaying progress during page loads, module_ loads, ajax requests, or any other registered long-running operations
     */
    constructor();
    getProgressElements(): JQuery[];
    registerProgressElement(element: JQuery): void;
    unRegisterProgressElement(element: JQuery): void;
    private _addProgressElement;
    private _showProgressElements;
    private _hideProgressElements;
    actionStarted(name: string, immediate?: boolean): number;
    actionCompleted(id: number): void;
    getPendingActions(): string[];
}
export function hasUnloadRequest(): boolean;
export enum GlobalMessagePosition {
    default = 0,
    top = 1
}
export class GlobalMessageIndicator {
    updateGlobalMessageIfEmpty(message: string, messageLevel?: string, customIcon?: string, onDismiss?: () => void, position?: GlobalMessagePosition): HTMLElement;
    clearGlobalMessages(): void;
}
export function classExtend(ctor: any, members: any): any;
export function getTypeName(type: any): string;
export function initClassPrototype(ctor: Function, members: any): void;
export function getModuleBase(moduleName: string): string;
/**
* Options for which modules to include in any dynamic bundle calls for exclusion. The
* default is 'AllLoadedModules' which ensures the minimum set of scripts are included
* in the bundle. This results in smaller bundles, but most-likely unique bundles across
* different pages, as they will likely each have a unique set of already-loaded scripts.
* The 'CommonModules' option ensures that the bundle will be the same across all pages.
*/
export enum DynamicModuleExcludeOptions {
    /**
    * No modules are excluded. The resulting bundle is guaranteed to have the requested script and all dependencies.
    */
    NoExcludes = 0,
    /**
    * Modules from the common bundle are excluded. The resulting bundle should be the same across pages (given that the common bundle is the same across pages).
    */
    CommonModules = 1,
    /**
    * Modules from the common and area bundles are excluded. The resulting bundle should be the same across pages where the same area module is loaded.
    */
    CommonAndAreaModules = 2,
    /**
    * Modules from the common, area and view bundles are excluded. The resulting bundle should be always same on the particular page (may differ in other page).
    */
    AllPageBundles = 3
}
/**
* Options for async require modules call
*/
export interface IModuleLoadOptions {
    /**
    * Options for which modules to include in any dynamic bundle calls for exclusion.
    */
    excludeOptions?: DynamicModuleExcludeOptions;
}
/**
* Issue a require statement for the specified modules and invoke the given callback method once available.
* This is a wrapper around the requireJS 'require' statement which ensures that the missing modules are
* pulled in via the minimum number of resource requests.
*
* @param moduleNames An array of AMD modules to asynchronously require.
* @param callback Function to invoke when all the specified the modules are loaded.
* @param errorCallback Function to invoke if an error occurs during the load of the modules.
*/
export function using(moduleNames: string[], callback: Function, errorCallback?: Function): void;
/**
* Issue a require statement for the specified modules and invoke the given callback method once available.
* This is a wrapper around the requireJS 'require' statement which ensures that the missing modules are
* pulled in via the minimum number of resource requests. Rather than taking a callback, this method returns
* a promise for the resolved modules (as an array).
*
* @param moduleNames An array of AMD modules to asynchronously require
*/
export function requireModules(moduleNames: string[], options?: IModuleLoadOptions): Q.Promise<any>;
/**
 * Listen to the load complete of a module's all plugins.
 *
 * @param moduleName Name of the module (Not the full name, instead the name specified in VSS.tfsModuleLoaded).
 * @param callback A function to execute when all the plugins of a module loaded.
 */
export function modulePluginsLoaded(moduleName: string, callback: Function): void;
export function tfsModuleLoaded(moduleName: string, moduleExports: any): void;
}
declare module "VSS/WebApi/Constants" {
export module AccessMappingConstants {
    var PublicAccessMappingMoniker: string;
    var ServerAccessMappingMoniker: string;
    var ClientAccessMappingMoniker: string;
    var HostGuidAccessMappingMoniker: string;
    var RootDomainMappingMoniker: string;
    var AzureInstanceMappingMoniker: string;
    var ServicePathMappingMoniker: string;
    var ServiceDomainMappingMoniker: string;
    var LegacyPublicAccessMappingMoniker: string;
    var MessageQueueAccessMappingMoniker: string;
    var LegacyAppDotAccessMappingMoniker: string;
    var AffinitizedMultiInstanceAccessMappingMoniker: string;
    var VstsAccessMapping: string;
    var CodexAccessMapping: string;
    var ServiceAccessMappingMoniker: string;
}
export module AuthenticationResourceIds {
    var AuthenticationLocationId: string;
    var AreaId: string;
    var AuthenticationAreaName: string;
    var SessionTokenResource: string;
}
export module BlobCopyLocationIds {
    var ResourceId: string;
    var ResourceString: string;
    var ResouceName: string;
    var AreaName: string;
}
export module ClientTraceResourceIds {
    var EventsLocationId: string;
    var AreaId: string;
    var ClientTraceAreaName: string;
    var ClientTraceEventsResource: string;
}
export module CommonIdentityPickerResourceIds {
    var IdentitiesLocationId: string;
    var IdentityAvatarLocationId: string;
    var IdentityFeatureMruLocationId: string;
    var IdentityConnectionsLocationId: string;
    var ServiceArea: string;
    var IdentitiesResource: string;
}
export module ContributionsResourceIds {
    var DataProvidersQueryLocationId: string;
    var InstalledAppsLocationId: string;
    var InstalledAppsByNameLocationId: string;
    var VDiscId: string;
    var VersionDiscoveryLocationId: string;
    var VDiscCompatLocationId: string;
    var ContributionQueryLocationId: string;
    var LocalExtensionAssetsLocationId: string;
    var AreaId: string;
    var ContributionsAreaName: string;
    var ExtensionsAreaName: string;
    var AssetsResource: string;
    var DataProvidersQueryLocationIdString: string;
    var InstalledExtensionsLocationIdString: string;
    var InstalledExtensionsByNameLocationIdString: string;
    var VersionDiscoveryLocationIdString: string;
    var VDiscCompatLocationIdString: string;
    var ContributionQueryLocationIdString: string;
    var LocalExtensionAssetsLocationIdString: string;
}
export module CustomerIntelligenceResourceIds {
    var EventsLocationId: string;
    var AreaId: string;
    var CustomerIntelligenceAreaName: string;
}
export module DatabaseMigrationLocationIds {
    var ResourceId: string;
    var ResourceString: string;
    var ResouceName: string;
    var AreaName: string;
}
export module DirectoryEntityType {
    /**
    * This concrete type implies that the directory entity represents a user.
    */
    var User: string;
    /**
    * This concrete type implies that the directory entity represents a group.
    */
    var Group: string;
}
export module DirectoryName {
    /**
    * This is a concrete directory.
    */
    var VisualStudioDirectory: string;
    /**
    * This is a concrete directory.
    */
    var AzureActiveDirectory: string;
}
/**
* Mustache items names available in replacement oject while resolving a mustache template
*/
export module ExtensionTemplateContextItemNames {
    var ServiceInstanceType: string;
}
export module FeatureAvailabilityResourceIds {
    var FeatureFlagsLocationId: string;
    var AreaId: string;
    var FeatureAvailabilityAreaName: string;
}
export module FeatureManagementResourceIds {
    var FeaturesLocationId: string;
    var FeatureStatesLocationId: string;
    var NamedScopeFeatureStatesLocationId: string;
    var FeatureStatesQueryLocationId: string;
    var FeatureStatesQueryForScopeLocationId: string;
    var FeatureStatesQueryForDefaultScopeLocationId: string;
    var FeatureManagementAreaName: string;
    var FeaturesResource: string;
    var FeatureStatesResource: string;
    var FeatureStatesLocationIdString: string;
    var NamedScopeFeatureStatesLocationIdString: string;
    var FeatureStatesQueryResource: string;
    var FeatureStatesQueryLocationIdString: string;
    var FeatureStatesQueryForScopeLocationIdString: string;
    var FeatureStatesQueryForDefaultScopeLocationIdString: string;
}
export module GraphProfileResourceIds {
    var AreaIdGuid: string;
    var AreaId: string;
    var AreaName: string;
}
export module IdentityMruResourceIds {
    var MruIdentitiesLocationId: string;
    var AreaId: string;
    var AreaName: string;
    var MruIdentitiesResource: string;
}
export module LocationResourceIds {
    var ConnectionData: string;
    var ServiceDefinitions: string;
    var AccessMappings: string;
    var ResourceAreas: string;
    var SpsServiceDefinition: string;
    var LocationServiceArea: string;
    var ConnectionDataResource: string;
    var ServiceDefinitionsResource: string;
    var AccessMappingsResource: string;
    var ResourceAreasResource: string;
    var SpsServiceDefintionResource: string;
}
export module NameResolutionResourceIds {
    var EntriesLocationId: string;
    var AreaId: string;
    var AreaName: string;
    var EntriesResource: string;
}
export module OperationsResourceIds {
    var OperationsLocationId: string;
    var OperationsPluginLocationId: string;
    var AreaName: string;
    var OperationsResource: string;
    var OperationsRouteName: string;
    var OperationsPluginRouteName: string;
    var OperationsApi: string;
    var TagOperationsLocationId: string;
    var TagOperationsPluginLocationId: string;
}
export module OriginName {
    var AzureActiveDirectory: string;
    var MicrosoftAccount: string;
    var VisualStudioTeamServices: string;
}
export module PartitioningResourceIds {
    var PartitionContainers: string;
    var Partitions: string;
    var AreaName: string;
    var AreaId: string;
    var PartitionContainersResource: string;
    var PartitionsResource: string;
}
export module ServiceInstanceTypes {
    var MPS: string;
    var SPS: string;
    var TFS: string;
    var TFSOnPremises: string;
    var SpsExtension: string;
    var SDKSample: string;
    var MPSString: string;
    var SPSString: string;
    var TFSString: string;
    var TFSOnPremisesString: string;
    var SpsExtensionString: string;
    var SDKSampleString: string;
}
export module SettingsApiResourceIds {
    var SettingEntriesLocationId: string;
    var NamedScopeSettingEntriesLocationId: string;
    var SettingsAreaName: string;
    var SettingEntriesResource: string;
    var SettingEntriesLocationIdString: string;
    var NamedScopeSettingEntriesLocationIdString: string;
}
export module SubjectKind {
    var Group: string;
    var User: string;
}
export module SubjectType {
    var AadGroup: string;
}
export module UserMetaType {
    var Guest: string;
}
}
declare module "VSS/WebApi/Contracts" {
/**
 * ---------------------------------------------------------
 * Generated file, DO NOT EDIT
 * ---------------------------------------------------------
 *
 * See following wiki page for instructions on how to regenerate:
 *   https://dev.azure.com/mseng/VSOnline/_wiki/wikis/VSOnline.wiki?pagePath=%2FOrphaned%20pages%2FDocQuality%2FDocQuality%252DInProgress%2FRest%20Client%20Generation
 *
 * Configuration file:
 *   vssf\client\webapi\httpclients\clientgeneratorconfigs\genclient.json
 */
import VSS_Graph_Contracts = require("VSS/Graph/Contracts");
/**
 * Information about the location of a REST API resource
 */
export interface ApiResourceLocation {
    /**
     * Area name for this resource
     */
    area: string;
    /**
     * Unique Identifier for this location
     */
    id: string;
    /**
     * Maximum api version that this resource supports (current server version for this resource)
     */
    maxVersion: string;
    /**
     * Minimum api version that this resource supports
     */
    minVersion: string;
    /**
     * The latest version of this resource location that is in "Release" (non-preview) mode
     */
    releasedVersion: string;
    /**
     * Resource name
     */
    resourceName: string;
    /**
     * The current resource version supported by this resource location
     */
    resourceVersion: number;
    /**
     * This location's route template (templated relative path)
     */
    routeTemplate: string;
}
/**
 * Represents version information for a REST Api resource
 */
export interface ApiResourceVersion {
    /**
     * String representation of the Public API version. This is the version that the public sees and is used for a large group of services (e.g. the TFS 1.0 API)
     */
    apiVersion: string;
    /**
     * Is the public API version in preview
     */
    isPreview: boolean;
    /**
     * Internal resource version. This is defined per-resource and is used to support build-to-build compatibility of API changes within a given (in-preview) public api version. For example, within the TFS 1.0 API release cycle, while it is still in preview, a resource's data structure may be changed. This resource can be versioned such that older clients will still work (requests will be sent to the older version) and new/upgraded clients will talk to the new version of the resource.
     */
    resourceVersion: number;
}
export interface AuditLogEntry {
    /**
     * The action if for the event, i.e Git.CreateRepo, Project.RenameProject
     */
    actionId: string;
    /**
     * ActivityId
     */
    activityId: string;
    /**
     * The Actor's CUID
     */
    actorCUID: string;
    /**
     * The Actor's User Id
     */
    actorUserId: string;
    /**
     * Type of authentication used by the author
     */
    authenticationMechanism: string;
    /**
     * This allows us to group things together, like one user action that caused a cascade of event entries (project creation).
     */
    correlationId: string;
    /**
     * External data such as CUIDs, item names, etc.
     */
    data: {
        [key: string]: any;
    };
    /**
     * EventId, should be unique
     */
    id: string;
    /**
     * IP Address where the event was originated
     */
    iPAddress: string;
    /**
     * The org, collection or project Id
     */
    scopeId: string;
    /**
     * The type of the scope, collection, org, project, etc.
     */
    scopeType: AuditScopeType;
    /**
     * The time when the event occurred in UTC
     */
    timestamp: Date;
    /**
     * The user agent from the request
     */
    userAgent: string;
}
/**
 * The type of scope from where the event is originated
 */
export enum AuditScopeType {
    /**
     * The scope is not known or has not been set
     */
    Unknown = 0,
    /**
     * Deployment
     */
    Deployment = 1,
    /**
     * Organization
     */
    Organization = 2,
    /**
     * Collection
     */
    Collection = 4,
    /**
     * Project
     */
    Project = 8
}
/**
 * Enumeration of the options that can be passed in on Connect.
 */
export enum ConnectOptions {
    /**
     * Retrieve no optional data.
     */
    None = 0,
    /**
     * Includes information about AccessMappings and ServiceDefinitions.
     */
    IncludeServices = 1,
    /**
     * Includes the last user access for this host.
     */
    IncludeLastUserAccess = 2,
    /**
     * This is only valid on the deployment host and when true. Will only return inherited definitions.
     */
    IncludeInheritedDefinitionsOnly = 4,
    /**
     * When true will only return non inherited definitions. Only valid at non-deployment host.
     */
    IncludeNonInheritedDefinitionsOnly = 8
}
export enum DeploymentFlags {
    None = 0,
    Hosted = 1,
    OnPremises = 2
}
/**
 * Defines an "actor" for an event.
 */
export interface EventActor {
    /**
     * Required: This is the identity of the user for the specified role.
     */
    id: string;
    /**
     * Required: The event specific name of a role.
     */
    role: string;
}
/**
 * Defines a scope for an event.
 */
export interface EventScope {
    /**
     * Required: This is the identity of the scope for the type.
     */
    id: string;
    /**
     * Optional: The display name of the scope
     */
    name: string;
    /**
     * Required: The event specific type of a scope.
     */
    type: string;
}
export interface IdentityRef extends VSS_Graph_Contracts.GraphSubjectBase {
    directoryAlias: string;
    id: string;
    imageUrl: string;
    inactive: boolean;
    isAadIdentity: boolean;
    isContainer: boolean;
    isDeletedInOrigin: boolean;
    profileUrl: string;
    uniqueName: string;
}
export interface IdentityRefWithEmail extends IdentityRef {
    preferredEmailAddress: string;
}
/**
 * The JSON model for JSON Patch Operations
 */
export interface JsonPatchDocument {
}
/**
 * The JSON model for a JSON Patch operation
 */
export interface JsonPatchOperation {
    /**
     * The path to copy from for the Move/Copy operation.
     */
    from: string;
    /**
     * The patch operation
     */
    op: Operation;
    /**
     * The path for the operation
     */
    path: string;
    /**
     * The value for the operation. This is either a primitive or a JToken.
     */
    value: any;
}
export interface JsonWebToken {
}
export enum JWTAlgorithm {
    None = 0,
    HS256 = 1,
    RS256 = 2
}
export enum Operation {
    Add = 0,
    Remove = 1,
    Replace = 2,
    Move = 3,
    Copy = 4,
    Test = 5
}
/**
 * Represents the public key portion of an RSA asymmetric key.
 */
export interface PublicKey {
    /**
     * Gets or sets the exponent for the public key.
     */
    exponent: number[];
    /**
     * Gets or sets the modulus for the public key.
     */
    modulus: number[];
}
export interface Publisher {
    /**
     * Name of the publishing service.
     */
    name: string;
    /**
     * Service Owner Guid Eg. Tfs : 00025394-6065-48CA-87D9-7F5672854EF7
     */
    serviceOwnerId: string;
}
/**
 * The class to represent a REST reference link.  RFC: http://tools.ietf.org/html/draft-kelly-json-hal-06  The RFC is not fully implemented, additional properties are allowed on the reference link but as of yet we don't have a need for them.
 */
export interface ReferenceLink {
    href: string;
}
export interface ResourceRef {
    id: string;
    url: string;
}
export interface ServiceEvent {
    /**
     * This is the id of the type. Constants that will be used by subscribers to identify/filter events being published on a topic.
     */
    eventType: string;
    /**
     * This is the service that published this event.
     */
    publisher: Publisher;
    /**
     * The resource object that carries specific information about the event. The object must have the ServiceEventObject applied for serialization/deserialization to work.
     */
    resource: any;
    /**
     * This dictionary carries the context descriptors along with their ids.
     */
    resourceContainers: {
        [key: string]: any;
    };
    /**
     * This is the version of the resource.
     */
    resourceVersion: string;
}
export interface TeamMember {
    identity: IdentityRef;
    isTeamAdmin: boolean;
}
/**
 * A single secured timing consisting of a duration and start time
 */
export interface TimingEntry {
    /**
     * Duration of the entry in ticks
     */
    elapsedTicks: number;
    /**
     * Properties to distinguish timings within the same group or to provide data to send with telemetry
     */
    properties: {
        [key: string]: any;
    };
    /**
     * Offset from Server Request Context start time in microseconds
     */
    startOffset: number;
}
/**
 * A set of secured performance timings all keyed off of the same string
 */
export interface TimingGroup {
    /**
     * The total number of timing entries associated with this group
     */
    count: number;
    /**
     * Overall duration of all entries in this group in ticks
     */
    elapsedTicks: number;
    /**
     * A list of timing entries in this group. Only the first few entries in each group are collected.
     */
    timings: TimingEntry[];
}
/**
 * This class describes a trace filter, i.e. a set of criteria on whether or not a trace event should be emitted
 */
export interface TraceFilter {
    area: string;
    exceptionType: string;
    isEnabled: boolean;
    layer: string;
    level: number;
    method: string;
    /**
     * Used to serialize additional identity information (display name, etc) to clients. Not set by default. Server-side callers should use OwnerId.
     */
    owner: IdentityRef;
    ownerId: string;
    path: string;
    processName: string;
    service: string;
    serviceHost: string;
    timeCreated: Date;
    traceId: string;
    tracepoint: number;
    uri: string;
    userAgent: string;
    userLogin: string;
}
export interface VssJsonCollectionWrapper extends VssJsonCollectionWrapperBase {
    value: any[];
}
/**
 * This class is used to serialized collections as a single JSON object on the wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
 */
export interface VssJsonCollectionWrapperV<T> extends VssJsonCollectionWrapperBase {
    value: T;
}
export interface VssJsonCollectionWrapperBase {
    count: number;
}
/**
 * This is the type used for firing notifications intended for the subsystem in the Notifications SDK. For components that can't take a dependency on the Notifications SDK directly, they can use ITeamFoundationEventService.PublishNotification and the Notifications SDK ISubscriber implementation will get it.
 */
export interface VssNotificationEvent {
    /**
     * Optional: A list of actors which are additional identities with corresponding roles that are relevant to the event.
     */
    actors: EventActor[];
    /**
     * Optional: A list of artifacts referenced or impacted by this event.
     */
    artifactUris: string[];
    /**
     * Required: The event payload.  If Data is a string, it must be in Json or XML format.  Otherwise it must have a serialization format attribute.
     */
    data: any;
    /**
     * Required: The name of the event.  This event must be registered in the context it is being fired.
     */
    eventType: string;
    /**
     * How long before the event expires and will be cleaned up.  The default is to use the system default.
     */
    expiresIn: any;
    /**
     * The id of the item, artifact, extension, project, etc.
     */
    itemId: string;
    /**
     * How long to wait before processing this event.  The default is to process immediately.
     */
    processDelay: any;
    /**
     * Optional: A list of scopes which are are relevant to the event.
     */
    scopes: EventScope[];
    /**
     * This is the time the original source event for this VssNotificationEvent was created.  For example, for something like a build completion notification SourceEventCreatedTime should be the time the build finished not the time this event was raised.
     */
    sourceEventCreatedTime: Date;
}
export interface WrappedException {
    customProperties: {
        [key: string]: any;
    };
    errorCode: number;
    eventId: number;
    helpLink: string;
    innerException: WrappedException;
    message: string;
    stackTrace: string;
    typeKey: string;
    typeName: string;
}
export var TypeInfo: {
    AuditLogEntry: any;
    AuditScopeType: {
        enumValues: {
            "unknown": number;
            "deployment": number;
            "organization": number;
            "collection": number;
            "project": number;
        };
    };
    ConnectOptions: {
        enumValues: {
            "none": number;
            "includeServices": number;
            "includeLastUserAccess": number;
            "includeInheritedDefinitionsOnly": number;
            "includeNonInheritedDefinitionsOnly": number;
        };
    };
    DeploymentFlags: {
        enumValues: {
            "none": number;
            "hosted": number;
            "onPremises": number;
        };
    };
    JsonPatchOperation: any;
    JWTAlgorithm: {
        enumValues: {
            "none": number;
            "hS256": number;
            "rS256": number;
        };
    };
    Operation: {
        enumValues: {
            "add": number;
            "remove": number;
            "replace": number;
            "move": number;
            "copy": number;
            "test": number;
        };
    };
    TraceFilter: any;
    VssNotificationEvent: any;
};
}
declare module "VSS/WebApi/RestClient" {
import Q = require("q");
import Serialization = require("VSS/Serialization");
import WebApi_Contracts = require("VSS/WebApi/Contracts");
/**
* Parameters for sending a WebApi request
*/
export interface VssApiResourceRequestParams {
    /**
    * Name of the area for the resource
    */
    area: string;
    /**
    * Unique identifier for the resource's route to issue a request to. Used to lookup the route template
    * for this request if the routeTemplate parameter is not supplied or for version negotiation in S2S calls.
    * This is required to ensure any S2S calls work.
    */
    locationId: string;
    /**
    * Route template that is used to form the request path. If routeTemplate is NOT specified, then locationId
    * is used to lookup the template via an OPTIONS request.
    */
    routeTemplate?: string;
    /**
    * Name of the resource to use in route template replacements. Only used if routeTemplate is provided.
    */
    resource?: string;
    /**
    * Dictionary of route template replacement values
    */
    routeValues?: {
        [key: string]: any;
    };
    /**
    * Data to post. In this case of a GET, this indicates query parameters.
    * For other requests, this is the request body object (which will be serialized
    * into a JSON string unless isRawData is set to true).
    */
    data?: any;
    /**
    * Query parameters to add to the url. In the case of a GET, query parameters can
    * be supplied via 'data' or 'queryParams'. For other verbs such as POST, the
    * data object specifies the POST body, so queryParams is needed to indicate
    * parameters to add to the query string of the url (not included in the post body).
    */
    queryParams?: IDictionaryStringTo<any>;
    /**
    * HTTP verb (GET by default if not specified)
    */
    httpMethod?: string;
    /**
    * The http response (Accept) type. This is "json" (corresponds to application/json Accept header)
    * unless otherwise specified. Other possible values are "html", "text", "zip", or "binary" or their accept
    * header equivalents (e.g. application/zip).
    */
    httpResponseType?: string;
    /**
    * Contract metadata for the request body. This allows us to do the necessary serialization
    * for the provided 'data' object using VSS serialization settings.
    */
    requestType?: Serialization.ContractMetadata;
    /**
    * Contract metadata for the response. This allows us to do the necessary deserialization
    * for the response object using VSS serialization settings.
    */
    responseType?: Serialization.ContractMetadata;
    /**
    * Indicates that the response is expected to be a wrapped array, so unwrap the response to
    * a regular array.
    */
    responseIsCollection?: boolean;
    /**
    * Allows the caller to specify custom request headers.
    */
    customHeaders?: {
        [headerName: string]: any;
    };
    /**
    * Request timeout in milliseconds. The default is 5 minutes.
    */
    timeout?: number;
    /**
    * The api version string to send in the request (e.g. "1.0" or "2.0-preview.2")
    */
    apiVersion?: string;
    /**
    * If true, this indicates that no processing should be done on the 'data' object
    * before it is sent in the request. *This is rarely needed*. One case is when posting
    * an HTML5 File object.
    */
    isRawData?: boolean;
}
export interface IVssHttpClientOptions {
    /**
     * If true, the progress indicator will be shown while the request is executing. Defaults to true.
     */
    showProgressIndicator?: boolean;
    /**
    * Request timeout in milliseconds. The default is 5 minutes.
    */
    timeout?: number;
    /**
     * Current session id. Defaults to pageContext.diagnostics.sessionId.
     */
    sessionId?: string;
    /**
     * Current command for activity logging.
     */
    command?: string;
    /**
    * If true, include links and urls (typically Uri properties) in the JSON responses. If false (default), then
    * send an excludeUrls=true header to suppress the generation of links in the JSON responses of requests from this client.
    */
    includeUrls?: boolean;
    /**
     * Use the new platform serialization format
     */
    useNewPlatformSerialization?: boolean;
}
/**
* Base class that should be used (derived from) to make requests to VSS REST apis
*/
export class VssHttpClient {
    private static APIS_RELATIVE_PATH;
    private static DEFAULT_REQUEST_TIMEOUT;
    private static _legacyDateRegExp;
    private static cacheFromJsonIslands;
    private _locationsByAreaPromises;
    _rootRequestPath: string;
    authTokenManager: IAuthTokenManager<any>;
    private _initializationPromise;
    forceOptionsCallForAutoNegotiate: boolean;
    protected _options: IVssHttpClientOptions;
    constructor(rootRequestPath: string, options?: IVssHttpClientOptions);
    /**
     * Sets a promise that is waited on before any requests are issued. Can be used to asynchronously
     * set the request url and auth token manager.
     */
    _setInitializationPromise(promise: IPromise<any>): void;
    /**
    * Issue a request to a VSS REST endpoint.
    *
    * @param requestParams request options
    * @param useAjaxResult If true, textStatus and jqXHR are added to the success callback. In this case, spread (instead of then) needs to be used
    * @returns Q Promise for the response
    */
    _beginRequest<T>(requestParams: VssApiResourceRequestParams, useAjaxResult?: boolean): IPromise<T>;
    _autoNegotiateApiVersion(location: WebApi_Contracts.ApiResourceLocation, requestedVersion: string): string;
    private _beginRequestToResolvedUrl;
    /**
    * Issue a request to a VSS REST endpoint and makes sure the result contains jqXHR. Use spread to access jqXHR.
    *
    * @param requestParams request options
    * @returns Q Promise for the response
    */
    _beginRequestWithAjaxResult<T>(requestParams: VssApiResourceRequestParams): Q.Promise<T>;
    /**
     * Issue an AJAX request. This is a wrapper around jquery's ajax method that handles VSS authentication
     * and triggers events that can be listened to by other modules.
     *
     * @param requestUrl Url to send the request to
     * @param ajaxOptions jQuery.ajax options
     * @param useAjaxResult If true, textStatus and jqXHR are added to the success callback. In this case, spread (instead of then) needs to be used.
     */
    _issueAjaxRequest(requestUrl: string, ajaxOptions: JQueryAjaxSettings, useAjaxResult?: boolean, vssRequestOptions?: IVssAjaxOptions): IPromise<any>;
    /**
     * Gets information about an API resource location (route template, supported versions, etc.)
     *
     * @param area resource area name
     * @param locationId Guid of the location to get
     */
    _beginGetLocation(area: string, locationId: string): IPromise<WebApi_Contracts.ApiResourceLocation>;
    private static processOptionsRequestResponse;
    private static initializeLocationsByAreaJsonIslandCacheIfNecessary;
    private static createLocationsByAreaPromisesCache;
    private beginGetAreaLocations;
    protected getRequestUrl(routeTemplate: string, area: string, resource: string, routeValues: any, queryParams?: IDictionaryStringTo<any>): string;
    private convertQueryParamsValues;
    _getLinkResponseHeaders(xhr: XMLHttpRequest): {
        [relName: string]: string;
    };
}
}
